2024-09-22 04:45:40.990 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/lecopivo/SciLean (commit: 2d1a4e79acf3a256ba2ec8ac2848d13f219b9684)
2024-09-22 04:45:40.990 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/lecopivo/SciLean (commit: 2d1a4e79acf3a256ba2ec8ac2848d13f219b9684)
2024-09-22 04:45:51.223 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/teorth/pfr (commit: 861715b9bf9482d2442760169cb2a3ff54091f75)
2024-09-22 04:45:51.223 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/teorth/pfr (commit: 861715b9bf9482d2442760169cb2a3ff54091f75)

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 2d1a4e79acf3a256ba2ec8ac2848d13f219b9684)
================================================================================

Proved sorry theorems only in first database: 26

Theorem: SciLean.ContCDiffAt.id_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.id_rule (x : X) :
    ContCDiffAt K n (fun x : X => x) x :=
Proof:
  unfold SciLean.ContCDiffAt
  tauto


Theorem: SciLean.re_float
File path: SciLean/Core/FloatAsReal.lean
Theorem statement: theorem re_float  (a : Float)
  : RCLike.re a = a :=
Proof:
  exact RCLike.re_eq_self_of_le le_rfl


Theorem: SciLean.Distribution.action_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.action_iteD (A : Set X) (t e : 𝒟'(X,Y)) (φ : 𝒟 X) :
   iteD A t e φ =
        t.extAction (fun x => if x ∈ A then φ x else 0) (fun y ⊸ fun r ⊸ r • y) +
        e.extAction (fun x => if x ∉ A then φ x else 0) (fun y ⊸ fun r ⊸ r • y) :=
Proof:
  aesop


Theorem: SciLean.scalar_div_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_div_one (x : R) : x / 1 = x :=
Proof:
  simp


Theorem: Function.Bijective.Equiv.invFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.invFun.arg_a0.Bijective_rule (f : Y ≃ Z) (g : X → Z) (hf : Bijective g)
  : Bijective (fun x => f.invFun (g x)) :=
Proof:
  convert hf
  simp [hf]
  exact f.symm.bijective.comp hf


Theorem: SciLean.Measure.prod_volume
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_volume {X Y} [MeasureSpace X] [MeasureSpace Y]  :
    (Measure.prod (volume : Measure X) (volume : Measure Y)) = volume :=
Proof:
  rfl


Theorem: SciLean.ArrayType.ext
File path: SciLean/Data/ArrayType/Basic.lean
Theorem statement: theorem ext (x y : Cont) : (∀ i, x[i] = y[i]) → x = y :=
Proof:
  intro h
  apply SciLean.ArrayType.get_injective
  simp only [h]


Theorem: SciLean.ContCDiffMapFD_eta
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eta (f : X ⟿FD[K,n] Y) : (fun x ⟿FD[K,n] f x) = f :=
Proof:
  simp only [DFunLike.ext_iff]
  aesop


Theorem: SciLean.scalar_min_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_zero_one  : min (0 : R) (1 : R) = 0 :=
Proof:
  rw [min_comm]
  simp


Theorem: IsAffineMap.IsAffineMap_apply
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_apply (i : ι) : IsAffineMap R (fun f : (i : ι) → E i ↦ f i) :=
Proof:
  constructor
  constructor
  simp
  simp


Theorem: SciLean.ite_pull_ennreal_toReal
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_ennreal_toReal (c : Prop) [Decidable c] (x y : ENNReal)  :
    (if c then x else y).toReal
    =
    (if c then x.toReal else y.toReal) :=
Proof:
  split_ifs <;> rfl


Theorem: SciLean.CDifferentiableAt.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.id_rule (x : X)
  : CDifferentiableAt K (fun x : X => x) x
  :=
Proof:
  unfold SciLean.CDifferentiableAt
  tauto


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple'
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple'
  : Bijective (fun xy : X×Y => (xy.2, xy.1))
  :=
Proof:
  constructor <;> intro h
  all_goals aesop


Theorem: Function.invFun.id_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem id_rule
  : invFun (fun (x : X) => x)
    =
    fun x => x :=
Proof:
  ext x
  apply Function.leftInverse_invFun
  exact Function.injective_id


Theorem: IsLinearMap.isLinearMap_apply
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_apply (i : ι) : IsLinearMap R (fun f : (i : ι) → E i ↦ f i) :=
Proof:
  constructor
  all_goals aesop


Theorem: SciLean.SmoothLinearMap.zero_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.zero_apply : (0 : X⊸[K]Y) x = 0 :=
Proof:
  rfl


Theorem: SciLean.scalar_max_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_zero_one  : max (0 : R) (1 : R) = 1 :=
Proof:
  rw [max_comm]
  simp


Theorem: SciLean.ite_pull_measureOf
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_measureOf {X} [MeasurableSpace X] (c : Prop) [Decidable c] (μ ν : Measure X) (A : Set X) :
    (if c then μ else ν) A
    =
    (if c then μ A else ν A) :=
Proof:
  split_ifs <;> rfl


Theorem: SciLean.CDifferentiableAt.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.comp_rule
  (f : Y → Z) (g : X → Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : CDifferentiableAt K (fun x => f (g x)) x
  :=
Proof:
  rw [CDifferentiableAt] at *
  aesop


Theorem: SciLean.ContCDiffAt.comp_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.comp_rule (x : X)
    (f : Y → Z) (g : X → Y)
    (hf : ContCDiffAt K n f (g x)) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f (g x)) x :=
Proof:
  rw [ContCDiffAt] at *
  aesop


Theorem: SciLean.ContCDiffMap.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap.zero_apply : (0 : X ⟿[K,n] Y) x = 0 :=
Proof:
  rfl


Theorem: SciLean.ContCDiffMapFD.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD.zero_apply : (0 : X ⟿FD[K,n] Y) x = 0 :=
Proof:
  rfl


Theorem: Function.Bijective.Equiv.toFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.toFun.arg_a0.Bijective_rule (f : Y ≃ Z) (g : X → Y) (hf : Bijective g)
  : Bijective (fun x => f (g x)) :=
Proof:
  convert hf
  constructor <;> intro h
  exact hf
  exact f.bijective.comp h


Theorem: SciLean.CDifferentiable.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.id_rule
  : CDifferentiable K (fun x : X => x)
  :=
Proof:
  intro x
  unfold SciLean.CDifferentiableAt
  tauto


Theorem: IsLinearMap.isLinearMap_const_zero
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_const_zero
  : IsLinearMap R (fun _ : X => (0 : Y))
  :=
Proof:
  constructor
  all_goals aesop


Theorem: SciLean.norm₂_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm₂_scalar {R} [RealScalar R] (x : R) :
  ‖x‖₂[R] = Scalar.abs x :=
Proof:
  simp


Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/teorth/pfr (commit: 861715b9bf9482d2442760169cb2a3ff54091f75)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 6

Theorem: multiTau_min_sum_le
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_min_sum_le : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ℕ _
  exact multidist_eq_zero


Theorem: sub_condMultiDistance_le
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma sub_condMultiDistance_le : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ℕ _
  exact multidist_eq_zero


Theorem: multiTau_min_exists
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_min_exists : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ℕ _
  exact multidist_eq_zero


Theorem: sub_condMultiDistance_le'
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma sub_condMultiDistance_le' : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ℕ _
  exact multidist_eq_zero


Theorem: sub_multiDistance_le
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma sub_multiDistance_le : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ℕ _
  exact multidist_eq_zero


Theorem: multiDist_of_perm
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_of_perm {m:ℕ} {Ω: Fin m → Type*} (hΩ : (i : Fin m) → MeasureSpace (Ω i))
    (X : (i : Fin m) → (Ω i) → G) (φ : Equiv.Perm (Fin m)) :
    D[X ; hΩ] = D[fun i ↦ X (φ i); fun i ↦ hΩ (φ i)]:=
Proof:
  rfl


Common Proved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 2d1a4e79acf3a256ba2ec8ac2848d13f219b9684)
================================================================================

Unproved sorry theorems only in first database: 268

Theorem: SciLean.Neg.neg.arg_a0.cderiv_rule'
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Neg.neg.arg_a0.cderiv_rule' (x : X) (f : X → Y) :
    (cderiv K fun x => - f x) x
    =
    fun dx => - cderiv K f x dx :=


Theorem: SciLean.semiAdjoint.Prod.snd.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.semiAdjoint_rule
  (f : X → Y×Z) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).2)
    =
    (fun z => semiAdjoint K f (0,z)) :=


Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X → Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x - g x) x :=


Theorem: SciLean.semiAdjoint.Inner.inner.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X → Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => ⟪f x, y⟫[K])
    =
    fun z => (conj z) • semiAdjoint K f y :=


Theorem: SciLean.cderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.apply_rule (i : ι) :
    (cderiv K fun (x : (i : ι) → E i) => x i)
    =
    fun _ => fun dx => dx i :=


Theorem: SciLean.semiAdjoint.const_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem const_rule : semiAdjoint K (fun (_ : X) => (0 : Y)) = fun x => 0 :=


Theorem: SciLean.IndexType.sum.arg_f.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiable_rule
  (f : X → ι → Y) (hf : ∀ i, CDifferentiable K (fun x => f x i))
  : CDifferentiable K (fun x => ∑ i, f x i) :=


Theorem: IsLinearMap.sum_push
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_push
  {f : X → Y} (hf : IsLinearMap K f)
  (ι : Type) [IndexType.{_,u} ι] [IndexType.{_,v} ι] (x : ι → X)
  : (∑ i, f (x i)) = f (∑ i, x i) :=


Theorem: SciLean.Rand.mean_add'
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add' (x : Rand X) (x' : X) : x' + x.mean = (x' +  x).mean :=


Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.toDual x) x :=


Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiableAt (f : W → X ⟿FD[K,∞] Y) (g : W → X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=


Theorem: SciLean.scalar_abs_neg
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_neg (r : R) : Scalar.abs (- r) = Scalar.abs r :=


Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_field
  [Field R] [MulAction R Y]
  (r : R) (f : X → Y) (hf : Bijective f) (hr : r ≠ 0)
  : Bijective (fun x => r • f x)
  :=


Theorem: SciLean.cderiv.const_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.const_rule (x : X) :
    (cderiv K fun _ : Y => x) = fun _ => fun dx => 0 :=


Theorem: SciLean.cderiv.let_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule_at
  (f : X → Y → Z) (g : X → Y) (x : X)
  (hf : CDifferentiableAt K ↿f (x, g x))
  (hg : CDifferentiableAt K g x)
  : (cderiv K
      fun x : X =>
        let y := g x
        f x y) x
    =
    let y  := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K (fun xy : X×Y => f xy.1 xy.2) (x,y) (dx, dy)
      dz :=


Theorem: Function.Bijective.HVAdd.hVAdd.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HVAdd.hVAdd.arg_a1.Bijective_rule_group
  [AddGroup G] [AddAction G Y]
  (g : G) (f : X → Y) (hf : Bijective f)
  : Bijective (fun x => g +ᵥ f x)
  :=


Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_group
  [Group G] [MulAction G Y]
  (g : G) (f : X → Y) (hf : Bijective f)
  : Bijective (fun x => g • f x)
  :=


Theorem: SciLean.semiAdjoint.HSub.hSub.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.semiAdjoint_rule
  (f g : X → Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x - g x)
    =
    fun y =>
      let x₁ := semiAdjoint K f y
      let x₂ := semiAdjoint K g y
      x₁ - x₂ :=


Theorem: SciLean.semiAdjoint.IndexType.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem IndexType.sum.arg_f.semiAdjoint_rule
  (f : X → ι → Y) (hf : ∀ i, HasSemiAdjoint K (f · i))
  : semiAdjoint K (fun x => ∑ i, f x i)
    =
    (fun y => ∑ i, semiAdjoint K (f · i) y) :=


Theorem: IndexType.sum.arg_f.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsLinearMap_rule
  (f : X → ι → Y) (hf : ∀ i, IsLinearMap R (f · i))
  : IsLinearMap R fun x => ∑ i, f x i :=


Theorem: SciLean.semiAdjoint.HAdd.hAdd.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.semiAdjoint_rule
  (f g : X → Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x + g x)
    =
    fun y =>
      let x₁ := semiAdjoint K f y
      let x₂ := semiAdjoint K g y
      x₁ + x₂ :=


Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_int
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_int
    (c : ℤ) (f : X → Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c • f x :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.fromDual x) :=


Theorem: SciLean.cintegral.arg_f.parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem cintegral.arg_f.parDistribDeriv_rule (f : W → X → Y → Z) :
    parDistribDeriv (fun w => (fun x => ∫' y, f w x y).toDistribution (R:=R))
    =
    fun w dw =>
      let Tf := (fun w => (fun x => (fun y => f w x y).toDistribution (R:=R)).toDistribution (R:=R))
      parDistribDeriv Tf w dw |>.postComp (fun T ⊸ T.extAction (fun _ => (1:R)) (fun z ⊸ fun r ⊸ r • z)) :=


Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_group
  [Group Y]
  (y : Y) (f : X → Y) (hf : Bijective f)
  : Bijective (fun x => y * f x)
  :=


Theorem: GetElem.getElem.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.semiAdjoint_rule_simple (idx : Idx) :
    semiAdjoint K (fun cont : Cont => cont[idx])
    =
    fun elem => oneHot (X:=Cont) idx elem :=


Theorem: SciLean.Prod.mk.arg_fstsnd.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.cderiv_rule_at (x : X)
    (g : X → Y) (hg : CDifferentiableAt K g x)
    (f : X → Z) (hf : CDifferentiableAt K f x) :
    cderiv K (fun x => (g x, f x)) x
    =
    fun dx =>
      (cderiv K g x dx, cderiv K f x dx) :=


Theorem: SciLean.Inner.inner.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Inner.inner.arg_a0a1.cderiv_rule_at
  (f : X → Y) (g : X → Y) (x : X)
  (hf : CDifferentiableAt R f x) (hg : CDifferentiableAt R g x)
  : cderiv R (fun x => ⟪f x, g x⟫[R]) x
    =
    fun dx =>
      let y₁ := f x
      let dy₁ := cderiv R f x dx
      let y₂ := g x
      let dy₂ := cderiv R g x dx
      ⟪dy₁, y₂⟫[R] + ⟪y₁, dy₂⟫[R] :=


Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X → Y) (hf : Bijective f) (hf' : ∀ x, f x ≠ 0)
  : Bijective fun x => (f x)⁻¹
  :=


Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
    (c : ℕ) (f : X → Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c • f x :=


Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
    (c : ℤ) (f : X → Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c • f x) x :=


Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.semiAdjoint_rule
  (c : K) (f : X → K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => c * f x)
    =
    fun y => conj c • semiAdjoint K (fun x => f x) y :=


Theorem: SciLean.Prod.snd.arg_self.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiff_rule
    (f : X → Y×Z) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => (f x).2) :=


Theorem: SciLean.Distribution.sub_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.sub_extAction (T T' : 𝒟'(X,U)) (φ : X → V) (L : U ⊸ V ⊸ W) :
    (T - T').extAction φ L = T.extAction φ L - T'.extAction φ L :=


Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiff_rule
    (f g : X → Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x - g x) :=


Theorem: Function.Bijective.HSub.hSub.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X → Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x - y
  :=


Theorem: SciLean.scalar_sqrt_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_zero  : Scalar.sqrt (0 : R) = 0 :=


Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule (f : X → K) (g : X → K)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) (hx : ∀ x, g x ≠ 0) :
    (cderiv K fun x => f x / g x)
    =
    fun x =>
      let k := f x
      let k' := g x
      fun dx =>
        ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=


Theorem: SciLean.IndexType.sum.arg_f.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiableAt_rule
  (f : X → ι → Y) (x : X) (hf : ∀ i, CDifferentiableAt K (fun x => f x i) x)
  : CDifferentiableAt K (fun x => ∑ i, f x i) x :=


Theorem: SciLean.Prod.mk.arg_fstsnd.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.CDifferentiableAt_rule
  (x : X)
  (g : X → Y) (hg : CDifferentiableAt K g x)
  (f : X → Z) (hf : CDifferentiableAt K f x)
  : CDifferentiableAt K (fun x => (g x, f x)) x
  :=


Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X → Y) (y : Y)
  (hf : Bijective f)
  : Bijective (fun x => f x / y) :=


Theorem: SciLean.Rand.mean_add
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add  (x : Rand X) (x' : X) : x.mean + x' = (x  + x').mean :=


Theorem: SciLean.HasSemiAdjoint.SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
  (f : X → ι → Y) (hf : ∀ i, HasSemiAdjoint K fun x : X => f x i)
  : HasSemiAdjoint K fun x => ∑ i, f x i :=


Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule
    (f : X → ι → Y) (hf : ∀ i, CDifferentiable K (f · i)) :
    fwdDeriv K (fun x => ∑ i, f x i)
    =
    fun x dx =>
      let ydy := fun i => fwdDeriv K (f · i) x dx
      ∑ i, ydy i :=


Theorem: Set.HAdd.hAdd.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' + x) (Ioo a b)
    =
    Ioo (a - x') (b - x') :=


Theorem: SciLean.Distribution.iteD_same
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.iteD_same (A : Set X) (u : 𝒟'(X,Y)) :
   iteD A u u = u :=


Theorem: Function.invFun.Prod.mk.arg_fstsnd.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.invFun_rule
  (f : X₁ → Y) (g : X₂ → Z) (p₁ : X → X₁) (p₂ : X → X₂)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (p₁ x, p₂ x)))
  : invFun (fun x : X => (f (p₁ x), g (p₂ x)))
    =
    fun yz =>
      let x₁ := invFun f yz.1
      let x₂ := invFun g yz.2
      let x  := invFun (fun x => (p₁ x, p₂ x)) (x₁,x₂)
      x :=


Theorem: Function.Bijective.Neg.neg.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Neg.neg.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X → Y) (hf : Bijective f)
  : Bijective fun x => - f x
  :=


Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
    (c : ℕ) (f : X → Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c • f x) x :=


Theorem: SciLean.gaussian.arg_μx.cderiv_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_μx.cderiv_rule
    (μ : W → U) (σ : R) (x : W → U)
    (hμ : CDifferentiable R μ) (hx : CDifferentiable R x) :
    fwdDeriv R (fun w => gaussian (μ w) σ (x w))
    =
    fun w dw =>
      let μdμ := fwdDeriv R μ w dw
      let xdx := fwdDeriv R x w dw
      let xdx' := σ⁻¹ • (xdx - μdμ)
      let g := gaussian μdμ.1 σ xdx.1
      (g, - ⟪xdx'.1, xdx'.2⟫ * g) :=


Theorem: SciLean.Distribution.indextype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.indextype_sum_extAction {I} [IndexType I] (T : I → 𝒟'(X,U)) (φ : X → V) (L : U ⊸ V ⊸ W) :
    (∑ i, T i).extAction φ L = ∑ i, (T i).extAction φ L :=


Theorem: SciLean.Rand.flip.pdf
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf (x : R) :
    (flip x).pdf R .count
    =
    fun b =>
      let x := (x ⊔ 0) ⊓ 1
      if b then x else (1-x) :=


Theorem: SciLean.scalar_abs_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_one : Scalar.abs (1 : R) = 1 :=


Theorem: SciLean.HSub.hSub.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a1.cderiv_rule
    (f : X → Y) (y : Y) :
    (cderiv K fun x => y - f x)
    =
    fun x dx =>
      - cderiv K f x dx :=


Theorem: Function.invFun.HAdd.hAdd.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.invFun_rule
  [AddGroup Y]
  (y : Y)  (f : X → Y) (hf : Bijective f)
  : invFun (fun x => y + f x)
    =
    fun y' =>
      invFun f (-y + y')
  :=


Theorem: SciLean.scalar_min_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_one_zero  : min (1 : R) (0 : R) = 0 :=


Theorem: Function.invFun.HSub.hSub.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X → Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x - y)
    =
    fun y' =>
      invFun f (y' + y)
  :=


Theorem: SciLean.IndexType.sum.arg_f.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem IndexType.sum.arg_f.ContCDiffAt_rule
  (f : X → ι → Y) (x : X) (hf : ∀ i, ContCDiffAt K n (fun x => f x i) x)
  : ContCDiffAt K n (fun x => ∑ i, f x i) x :=


Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
    (c : K) (f : X → Y) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun x => c • f x :=


Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_field
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_field
  [Field Y]
  (f : X → Y) (hf : Bijective f) (hf' : ∀ x, f x ≠ 0)
  : invFun (fun x => (f x)⁻¹)
    =
    fun y =>
      invFun f (y⁻¹)
  :=


Theorem: SciLean.HAdd.hAdd.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.cderiv_rule
    (f : X → Y) (y : Y) :
    (cderiv K fun x => f x + y)
    =
    fun x dx =>
      cderiv K f x dx :=


Theorem: SciLean.SciLean.cderiv.arg_dx.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.cderiv_rule_at
  (f : Y → Z) (g : X → Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : cderiv K (fun dx' => cderiv K f y (g dx')) dx
    =
    fun ddx =>
      let ddy := cderiv K g dx ddx
      cderiv K f y ddy :=


Theorem: SciLean.CDifferentiable.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.apply_rule (i : ι)
  : CDifferentiable K (fun x : (i : ι) → E i => x i) :=


Theorem: SciLean.Basis.proj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => ℼ i x) :=


Theorem: SciLean.HasSemiAdjoint.HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
    (f g : X → Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x - g x :=


Theorem: SciLean.cintegral.arg_f.IsLinearMap_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.IsLinearMap_rule
    (f : X → β → Z) (μ : Measure β) (hf : ∀ y, IsLinearMap R (f · y)) :
    IsLinearMap R (fun x => ∫' y, f x y ∂μ) :=


Theorem: IsAffineMap.IsAffineMap_pi
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_pi (f : X → (i : ι) → E i) (hf : ∀ i, IsAffineMap R (f · i)) :
    IsAffineMap R (fun x i ↦ f x i) :=


Theorem: SciLean.IsContinuousLinearMap.starRingEnd.arg_a.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem starRingEnd.arg_a.IsContinuousLinearMap_rule
  (f : X → K) (_ : IsContinuousLinearMap K f)
  : IsContinuousLinearMap K fun x => conj (f x) :=


Theorem: SciLean.BasisDuality.toDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.toDual x) :=


Theorem: SciLean.Inner.inner.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Inner.inner.arg_a0a1.CDifferentiable_rule
    (f : X → Y) (g : X → Y)
    (hf : CDifferentiable R f) (hg : CDifferentiable R g) :
    CDifferentiable R (fun x => ⟪f x, g x⟫[R]) :=


Theorem: SciLean.toDistribution.linear_parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem toDistribution.linear_parDistribDeriv_rule (f : W → X → Y) (L : Y → Z)
    (hL : IsSmoothLinearMap R L) :
    parDistribDeriv (fun w => (fun x => L (f w x)).toDistribution)
    =
    fun w dw =>
      parDistribDeriv (fun w => (fun x => f w x).toDistribution) w dw |>.postComp (fun y ⊸ L y) :=


Theorem: SciLean.Prod.fst.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.fst.arg_self.CDifferentiable_rule
  (f : X → Y×Z) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).1)  :=


Theorem: Set.HAdd.hAdd.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x + x') (Ioo a b)
    =
    Ioo (a - x') (b - x') :=


Theorem: GetElem.getElem.arg_cont.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.revCDerivProj_rule
  {J ElemJ} [StructType Elem J ElemJ] [IndexType J] [LawfulIndexType J] [DecidableEq J]
  [∀ j, SemiInnerProductSpace K (ElemJ j)] [SemiInnerProductSpaceStruct K Elem J ElemJ]
  (f : X → Cont) (idx : Idx)
  (hf : HasAdjDiff K f)
  : revDerivProj K J (fun x => (f x)[idx])
    =
    fun x =>
      let ydf := revDerivProj K (Idx×J) f x
      (ydf.1[idx],
       fun j delem => ydf.2 (idx,j) delem) :=


Theorem: IsLinearMap.sum_pull
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_pull
  {f : X → Y} (hf : IsLinearMap K f)
  (ι : Type) [IndexType.{_,u} ι] [IndexType.{_,v} ι] (x : ι → X)
  : f (∑ i, x i) = ∑ i, f (x i) :=


Theorem: SciLean.revDerivProjUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X → ι → Y) (hf : ∀ i, HasAdjDiff K (f · i)) :
    (revDerivProjUpdate K Unit fun (x : X) (i : ι) => f x i)
    =
    fun x =>
      let ydf := fun i => revDerivUpdate K (f · i) x
      (fun i => (ydf i).1,
       fun _ df dx =>
         Fold.fold (IndexType.univ ι) (fun dx i => (ydf i).2 (df i) dx) dx) :=


Theorem: SciLean.SmoothLinearMap.apply_zero
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.apply_zero (f : X ⊸[K] Y) : f 0 = 0 :=


Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule_at (x : X)
    (f : X → ι → Y) (hf : ∀ i, CDifferentiableAt K (f · i) x) :
    fwdDeriv K (fun x => ∑ i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdDeriv K (f · i) x dx
      ∑ i, ydy i :=


Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X ⟿FD[K,n] Y)×X) => fx.1 fx.2) :=


Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.HasSemiAdjoint_rule
  (f : X → Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => ⟪y, f x⟫[K] :=


Theorem: SciLean.semiAdjoint.starRingEnd.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a0.semiAdjoint_rule
  (f : X → K)
  : semiAdjoint K (fun x => conj (f x))
    =
    fun z => semiAdjoint K f z :=


Theorem: IndexType.sum.arg_f.revDerivProjUpdate_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProjUpdate_rule [DecidableEq ι]
    (f : X → ι → Y') (hf : ∀ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProjUpdate K Yi (fun x => ∑ i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (ι×Yi) f x
      (∑ i, ydf.1 i,
       fun j dy dx =>
         Fold.fold (IndexType.univ ι) (fun dx i => ydf.2 (i,j) dy dx) dx) :=


Theorem: SciLean.Distribution.extAction_iteD'
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD' (A B : Set X) (t e : 𝒟'(X,U)) (φ : X → V) (L : U ⊸ V ⊸ W) :
    ((iteD A t e).restrict B).extAction φ L =
        (t.restrict B).extAction (fun x => if x ∈ A then φ x else 0) L +
        (e.restrict B).extAction (fun x => if x ∉ A then φ x else 0) L :=


Theorem: SciLean.cderiv.id_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.id_rule :
    (cderiv K fun x : X => x) = fun _ => fun dx => dx :=


Theorem: Function.invFun.HSub.hSub.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a1.invFun_rule
  [AddGroup Y]
   (y : Y) (f : X → Y) (hf : Bijective f)
  : invFun (fun x => y - f x )
    =
    fun y' =>
      invFun f (y - y')
  :=


Theorem: Set.HSub.hSub.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' - x) (Ioo a b)
    =
    Ioo (x' - b) (x' - a) :=


Theorem: Function.invFun.comp_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem comp_rule
  (f : Y → Z) (g : X → Y)
  (hf : Bijective f) (hg : Bijective g)
  : invFun (fun x => f (g x))
    =
    fun z =>
      let y := invFun f z
      let x := invFun g y
      x :=


Theorem: SciLean.CDifferentiable.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.const_rule (y : Y)
  : CDifferentiable K (fun _ : X => y)
  :=


Theorem: LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple :
    semiAdjoint K (fun f : Idx → Elem => Indexed.ofFn (C:=Cont) f)
    =
    fun (cont : Cont) idx => cont[idx] :=


Theorem: SciLean.parametric_inverse_bijection
File path: SciLean/Core/Integral/ParametricInverse.lean
Theorem statement: theorem parametric_inverse_bijection [Nonempty X] (f : X → Y) (hf : f.Bijective) (y : Y) :
    ParametricInverseAt f y
      (I := Unit) (X₁ := fun _ => Unit)
      (p := fun _ _ x => x)
      (g := fun _ _ => f.invFun y)
      (dom := fun _ => Set.univ) :=


Theorem: SciLean.semiAdjoint.Prod.mk.arg_fstsnd.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.semiAdjoint_rule
  (g : X → Y) (f : X → Z)
  (hg : HasSemiAdjoint K g) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (g x, f x))
    =
    fun yz =>
      let x₁ := semiAdjoint K g yz.1
      let x₂ := semiAdjoint K f yz.2
      x₁ + x₂ :=


Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X → Y) (y : Y) (hf : Bijective f) (hy : y ≠ 0)
  : Bijective (fun x => f x * y)
  :=


Theorem: SciLean.Basis.proj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Basis.proj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => ℼ i x) :=


Theorem: SciLean.HasSemiAdjoint.pi_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem pi_rule
    (f : X → (i : ι) → E i) (hf : ∀ i, HasSemiAdjoint K (f · i)) :
    HasSemiAdjoint K (fun x i => f x i) :=


Theorem: Function.Bijective.HSub.hSub.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a1.Bijective_rule
  [AddGroup Y]
   (y : Y) (f : X → Y) (hf : Bijective f)
  : Bijective fun x => y - f x
  :=


Theorem: SciLean.Prod.mk.arg_fstsnd.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.ContCDiffAt_rule (x : X)
  (g : X → Y) (hg : ContCDiffAt K n g x)
  (f : X → Z) (hf : ContCDiffAt K n f x)
  : ContCDiffAt K n (fun x => (g x, f x)) x
  :=


Theorem: IndexType.sum.arg_f.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsAffineMap_rule
  (f : X → ι → Y) (hf : ∀ i, IsAffineMap R (f · i))
  : IsAffineMap R fun x => ∑ i, f x i :=


Theorem: SciLean.odeSolve.arg_ft₀tx₀.fwdDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_ft₀tx₀.fwdDeriv_rule
  (f : W → R → X → X) (t₀ t : W → R) (x₀ : W → X)
  (hf : CDifferentiable R (fun (w,t,x) => f w t x))
  (ht₀ : CDifferentiable R t₀) (ht : CDifferentiable R t)
  (hx : CDifferentiable R x₀)
  : fwdDeriv R (fun w => odeSolve (f w) (t₀ w) (t w) (x₀ w))
    =
    fun w dw =>
      let t₀dt₀ := fwdDeriv R t₀ w dw
      let tdt   := fwdDeriv R t₀ w dw
      let x₀dx₀ := fwdDeriv R x₀ w dw
      let Tf := fwdDeriv R (fun wkx : W×R×X => f wkx.1 wkx.2.1 wkx.2.2)

      let F := fun (t : R) (xdx : X×X) =>
        let x  := xdx.1
        let dx := xdx.2
        Tf (w,t,x) (dw,t₀dt₀.2,dx)

      let xdx := odeSolve F (t₀dt₀.1) (tdt.1) x₀dx₀

      (xdx.1, xdx.2 + tdt.2 • f w tdt.1 xdx.1) :=


Theorem: SciLean.ContCDiffAt.apply_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.apply_rule
    (i : ι) (x) : ContCDiffAt K n (fun x : (i : ι) → E i => x i) x :=


Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X → Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x + g x) x :=


Theorem: SciLean.HasSemiAdjoint.Prod.snd.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.HasSemiAdjoint_rule
    (f : X → Y×Z) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).snd :=


Theorem: SciLean.Inner.inner.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Inner.inner.arg_a0a1.ContCDiffAt_rule
    (f : X → Y) (g : X → Y) (x : X)
    (hf : ContCDiffAt R n f x) (hg : ContCDiffAt R n g x) :
    ContCDiffAt R n (fun x => ⟪f x, g x⟫[R]) x :=


Theorem: SciLean.Distribution.smul_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.smul_extAction (r : R) (T : 𝒟'(X,U)) (φ : X → V) (L : U ⊸ V ⊸ W)  :
    (r • T).extAction φ L = r • T.extAction φ L :=


Theorem: SciLean.cderiv.arg_f.IsSmoothLinearMap_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.arg_f.IsSmoothLinearMap_rule
    (f : X → Y → Z) (hf : CDifferentiable K (fun (x,y) => f x y)) (hf' : ∀ y, IsLinearMap K (fun x => f x y)) :
    IsSmoothLinearMap K (fun x => cderiv K (f x ·)) :=


Theorem: SciLean.Prod.snd.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiffAt_rule (x : X)
    (f : X → Y×Z) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).2) x :=


Theorem: SciLean.Rand.flip.integral
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.integral (θ : R) (f : Bool → X) :
    ∫' x, f x ∂(flip θ).ℙ = θ • f true + (1-θ) • f false :=


Theorem: SciLean.norm₂_squared_nat
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm₂_squared_nat {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : ‖x‖₂[K] ^ 2 = ‖x‖₂²[K] :=


Theorem: SciLean.Rand.bind_E
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_E (r : Rand X) (f : X → Rand Y) (φ : Y → Z) :
    (r >>= f).𝔼 φ = r.𝔼 (fun x' => (f x').𝔼 φ) :=


Theorem: SciLean.Function.invFun.arg_f_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f_a1.cderiv_rule
  (f : X → Y → Z)
  (hf : ∀ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : X×Y => f xy.1 xy.2))
  : cderiv K (fun x z => invFun (f x) z)
    =
    fun x dx z =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=


Theorem: SciLean.explicitSymplecticEuler_eq_implicitSymplecticEulerV1
File path: SciLean/Modules/DifferentialEquations/OdeSolvers/Solvers.lean
Theorem statement: theorem explicitSymplecticEuler_eq_implicitSymplecticEulerV1
  (T V : X → R)
  (hT : HasAdjDiff R T) (hV : HasAdjDiff R V)
  : explicitSymplecticEuler (fun q p => T p + V q)
    =
    implicitSymplecticEulerV1 (fun q p => T p + V q) :=


Theorem: SciLean.SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule (w : W)
    (f : X → Y) (a0 : W → Y) (hf : CDifferentiable K f) (ha0 : HasAdjDiffAt K a0 w) :
    HasAdjDiffAt K (fun w => semiAdjoint K f (a0 w)) w :=


Theorem: Function.invFun.Equiv.toFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.toFun.arg_a0.invFun_rule (f : Y ≃ Z) (g : X → Y) (hf : Bijective g)
  : Function.invFun (fun x => f (g x))
    =
    fun z => Function.invFun g (f.invFun z) :=


Theorem: SciLean.semiAdjoint.Neg.neg.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.semiAdjoint_rule
  (f : X → Y)
  : semiAdjoint K (fun x => - f x)
    =
    fun y => - semiAdjoint K f y :=


Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule_at (x : X) (f : X → K) (g : X → K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) (hx : g x ≠ 0) :
    (cderiv K fun x => f x / g x) x
    =
    let k := f x
    let k' := g x
    fun dx =>
      ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=


Theorem: SciLean.Basis.proj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => ℼ i x) :=


Theorem: SciLean.Neg.neg.arg_a0.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiffAt_rule
    (x : X) (f : X → Y) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => - f x) x :=


Theorem: SciLean.semiAdjoint.comp_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem comp_rule
  (f : Y → Z) (g : X → Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => f (g x))
    =
    fun z =>
      let y := semiAdjoint K f z
      let x := semiAdjoint K g y
      x :=


Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.semiAdjoint_rule
  (c : K) (f : X → K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x * c)
    =
    fun y => conj c • semiAdjoint K (fun x => f x) y :=


Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => ℼ' i x) :=


Theorem: SciLean.Rand.uniformI.pdf
File path: SciLean/Core/Rand/Distributions/UniformI.lean
Theorem statement: theorem uniformI.pdf :
    (uniformI R).pdf R volume
    =
    fun x => if 0 < x ∧ x < 1 then 1 else 0 :=


Theorem: SciLean.Prod.fst.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.fst.arg_self.ContCDiffAt_rule (x : X)
    (f : X → Y×Z) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).1) x :=


Theorem: SciLean.HMul.hMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HMul.hMul.arg_a0a1.cderiv_rule_at (x : X) (f g : X → K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x * g x) x
    =
    let fx := f x
    let gx := g x
    fun dx =>
      (cderiv K g x dx) * fx + (cderiv K f x dx) * gx :=


Theorem: SciLean.Rand.E_smul
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem E_smul (r : Rand X) (φ : X → ℝ) (y : Y) :
    r.𝔼 (fun x' => φ x' • y) = r.𝔼 φ • y :=


Theorem: SciLean.norm₂.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem norm₂.arg_x.ContCDiffAt_rule
    (f : X → Y) (x : X)
    (hf : ContCDiffAt R n f x) (hx : f x≠0) :
    ContCDiffAt R n (fun x => ‖f x‖₂[R]) x :=


Theorem: SciLean.DualBasis.dualProj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => ℼ' i x) :=


Theorem: SciLean.HasSemiAdjoint.starRingEnd.arg_a.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a.HasSemiAdjoint_rule
  (f : X → K) (_ : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => conj (f x) :=


Theorem: SciLean.Distribution.neg_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.neg_extAction (T : 𝒟'(X,U)) (φ : X → V) (L : U ⊸ V ⊸ W) :
    (- T).extAction φ L = - T.extAction φ L :=


Theorem: SciLean.SmoothLinearMap.indextype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.indextype_sum_apply {I} [IndexType I] (f : I → X⊸[K] Y) (x : X) :
    (∑ i, f i) x = ∑ i, f i x  :=


Theorem: SciLean.ContCDiffAt.pi_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.pi_rule (x : X)
    (f : X → (i : ι) → E i)
    (hf : ∀ i, ContCDiffAt K n (f · i) x) :
    ContCDiffAt K n (fun x i => f x i) x :=


Theorem: SciLean.semiAdjoint.let_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem let_rule
    (f : X → Y → Z) (g : X → Y)
    (hf : HasSemiAdjoint K ↿f) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => let y := g x; f x y)
    =
    fun z =>
      let xy := semiAdjoint K (fun xy : X×Y => f xy.1 xy.2) z
      let x' := semiAdjoint K g xy.2
      xy.1 + x' :=


Theorem: SciLean.revDerivUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X → (i : I) → EI i) (hf : ∀ i, HasAdjDiff K (f · i)) :
    (revDerivUpdate K fun (x : X) (i : I) => f x i)
    =
    fun x =>
      let xdf := fun i => revDerivUpdate K (f · i) x
      (fun i => (xdf i).1,
       fun dy dx =>
         Fold.fold (IndexType.univ I) (fun dx i => (xdf i).2 (dy i) dx) dx) :=


Theorem: Set.HSub.hSub.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x - x') (Ioo a b)
    =
    Ioo (a + x') (b + x') :=


Theorem: SciLean.ite.arg_chte.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem ite.arg_chte.cderiv_rule
  (c : X → Prop) [dec : ∀ x, Decidable (c x)] (t e : X → Y)
  (ht : ∀ x ∈ closure c, CDifferentiableAt K t x) (he : ∀ x ∈ (interior c)ᶜ, CDifferentiableAt K e x)
  (hc : (∀ x, x ∈ frontier c → cderiv K t x = cderiv K e x))
  : cderiv K (fun x => ite (c x) (t x) (e x))
    =
    fun y =>
      ite (c y) (cderiv K t y) (cderiv K e y) :=


Theorem: SciLean.semiAdjoint.Inner.inner.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X → Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => ⟪y, f x⟫[K])
    =
    fun z => z • semiAdjoint K f y :=


Theorem: SciLean.HSub.hSub.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.CDifferentiable_rule
  (f g : X → Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x - g x)  :=


Theorem: SciLean.Rand.pull_E_affine
File path: SciLean/Core/Rand/PushPullExpectation.lean
Theorem statement: theorem pull_E_affine (r : Rand X) (φ : X → Y)
    (f : Y → Z) (hf : IsAffineMap ℝ f := by fun_prop) :
    (f (r.𝔼 φ)) = r.𝔼 (fun x => f (φ x)) :=


Theorem: SciLean.inner_proj_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_proj_dualProj {ι K X} {_ : IndexType ι} [LawfulIndexType ι] [DecidableEq ι] [RCLike K] [FinVec ι K X] (x y : X)
  : ⟪x, y⟫[K] = ∑ i, ℼ i x * ℼ' i y :=


Theorem: SciLean.Neg.neg.arg_a0.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Neg.neg.arg_a0.CDifferentiable_rule
  (f : X → Y) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => - f x)  :=


Theorem: SciLean.ContCDiffMap_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiableAt (f : W → X ⟿[K,∞] Y) (g : W → X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=


Theorem: SciLean.DualBasis.dualProj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => ℼ' i x) :=


Theorem: LeanColls.Range.fold_def
File path: .lake/packages/leancolls/LeanColls/Data/Range.lean
Theorem statement: theorem fold_def (r : Range) (f : β → Nat → β)
    : fold r f init =
      Fin.foldl (r.size) (fun acc i => f acc (r.get i)) init
  :=


Theorem: SciLean.Basis.proj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => ℼ i x) :=


Theorem: SciLean.Rand.swap_bind
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem swap_bind (f : X → Y → Z) (x : Rand X) (y : Rand Y) :
    (do let x' ← x; let y' ← y; pure (f x' y'))
    =
    (do let y' ← y; let x' ← x; pure (f x' y')) :=


Theorem: SciLean.CDifferentiable.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.pi_rule
  (f : X → (i : ι) → E i)
  (hf : ∀ i, CDifferentiable K (f · i))
  : CDifferentiable K (fun x i => f x i)
  :=


Theorem: SciLean.HSub.hSub.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a0.cderiv_rule
    (f : X → Y) (y : Y) :
    (cderiv K fun x => f x - y)
    =
    fun x dx =>
      cderiv K f x dx :=


Theorem: SciLean.HasSemiAdjoint.SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
  (f : X → Y) (a0 : W → Y) (ha0 : HasSemiAdjoint K a0)
  : HasSemiAdjoint K (fun w => semiAdjoint K f (a0 w)) :=


Theorem: SciLean.odeSolve.arg_x₀.semiAdjoint_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_x₀.semiAdjoint_rule
  (f : R → X → X) (t₀ t : R) (x₀ : W → X)
  (hf : ∀ t, HasSemiAdjoint R (f t)) (hx₀ : HasSemiAdjoint R x₀)
  : semiAdjoint R (fun w => odeSolve f t₀ t (x₀ w))
    =
    fun x₀' =>
      let f' := (fun s y => - semiAdjoint R (f s) y)
      let y := odeSolve f' t t₀ x₀'
      semiAdjoint R x₀ y :=


Theorem: SciLean.scalar_abs_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_zero : Scalar.abs (0 : R) = 0 :=


Theorem: SciLean.cderiv.comp_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule_at
  (f : Y → Z) (g : X → Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : (cderiv K fun x : X => f (g x)) x
    =
    let y := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K f y dy
      dz :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.fromDual x) :=


Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (y' : Y) (f : X → K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x • y')
    =
    fun y => semiAdjoint K (fun x => f x) ⟪y',y⟫[K] :=


Theorem: Function.Bijective.HAdd.hAdd.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.Bijective_rule
  [AddGroup Y]
  (y : Y)  (f : X → Y) (hf : Bijective f)
  : Bijective fun x => y + f x
  :=


Theorem: SciLean.parametric_inverse_affine
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine {n} (f : X → R) (c : R) (hf : IsAffineMap R f)
    (hn : n + 1 = card ι := by first | assumption | infer_var) :
    let u  := ∇ f 0
    let dec := planeDecomposition (R:=R) u hn
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / ‖u‖₂)
      (dom := fun _ => ⊤) :=


Theorem: SciLean.scalar_max_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_one_zero  : max (1 : R) (0 : R) = 1 :=


Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => ℼ' i x) x :=


Theorem: SciLean.HAdd.hAdd.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.CDifferentiable_rule
  (f g : X → Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x + g x)  :=


Theorem: SciLean.inner_basis_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_basis_dualProj (i : ι) (x : X)
  : ⟪x, ⅇ i⟫[K] = ℼ' i x :=


Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiable (f : W → X ⟿FD[K,∞] Y) (g : W → X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=


Theorem: SciLean.CDifferentiableAt.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.pi_rule
  (f : X → (i : ι) → E i) (x : X)
  (hf : ∀ i, CDifferentiableAt K (f · i) x)
  : CDifferentiableAt K (fun x i => f x i) x
  :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.fromDual x) :=


Theorem: SciLean.Distribution.extAction_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD (A : Set X) (t e : 𝒟'(X,U)) (φ : X → V) (L : U ⊸ V ⊸ W) :
    (iteD A t e).extAction φ L =
        t.extAction (fun x => if x ∈ A then φ x else 0) L +
        e.extAction (fun x => if x ∉ A then φ x else 0) L :=


Theorem: SciLean.gaussian.arg_μσx.CDifferentiableAt_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_μσx.CDifferentiableAt_rule (w : W)
    (μ : W → U) (σ : W → R) (x : W → U)
    (hμ : CDifferentiableAt R μ w) (hσ : CDifferentiableAt R σ w) (hx : CDifferentiableAt R x w)
    (hσ' : σ w ≠ 0) :
    CDifferentiableAt R (fun w => gaussian (μ w) (σ w) (x w)) w :=


Theorem: Function.invFun.let_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem let_rule
  (f : X₂ → Y → Z) (g : X₁ → Y) (p₁ : X → X₁) (p₂ : X → X₂)
  (hf : Bijective (fun xy : X₂×Y => f xy.1 xy.2)) (hg : Bijective g) (hp : Bijective (fun x => (p₁ x, p₂ x)))
  : invFun (fun x => let y := g (p₁ x); f (p₂ x) y)
    =
    fun z =>
      let x₂y := invFun (fun xy : X₂×Y => f xy.1 xy.2) z
      let x₁ := invFun g x₂y.2
      let x := invFun (fun x => (p₁ x, p₂ x)) (x₁,x₂y.1)
      x :=


Theorem: SciLean.HasSemiAdjoint.apply_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem apply_rule (i : ι) :
    HasSemiAdjoint K (fun x : (i : ι) → E i => x i) :=


Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X → Y) (y : Y) (hf : Bijective f)
  : Bijective (fun x => f x * y)
  :=


Theorem: SciLean.SciLean.norm₂.arg_x.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.norm₂.arg_x.HasAdjDiffAt_rule (x : X)
    (f : X → Y) (hf : HasAdjDiffAt R f x) (hfz : f x ≠ 0) :
    HasAdjDiffAt R (fun x => ‖f x‖₂[R]) x :=


Theorem: SciLean.odeSolve.arg_x₀.revCDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_x₀.revCDeriv_rule
  (f : R → X → X) (t₀ t : R) (x₀ : W → X)
  (hf : HasAdjDiff R (fun (t,x) => f t x))
  (hx : HasAdjDiff R x₀)
  : revDeriv R (fun w => odeSolve f t₀ t (x₀ w))
    =
    fun w =>
      let x₀dx₀ := revDeriv R x₀ w
      let x := fun s => odeSolve f t₀ s x₀dx₀.1
      let dfdx := fun s dx' => - gradient R (fun x' => f s x') (x s) dx'
      (x t,
       fun dx =>
         let dx := odeSolve dfdx t₀ t dx
         x₀dx₀.2 dx) :=


Theorem: SciLean.SciLean.norm₂.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem SciLean.norm₂.arg_x.CDifferentiable_rule
  (f : X → Y) (hf : CDifferentiable R f) (hx : f x≠0)
  : CDifferentiable R (fun x => ‖f x‖₂[R]) :=


Theorem: SciLean.cderiv.pi_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule_at
  (f : X → (i : ι) → E i) (x : X) (hf : ∀ i, CDifferentiableAt K (f · i) x)
  : (cderiv K fun (x : X) (i : ι) => f x i) x
    =
    fun dx => fun i =>
      cderiv K (f · i) x dx
  :=


Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X ⟿FD[K,∞] Y)×X) => fx.1 fx.2) :=


Theorem: SciLean.SciLean.cderiv.arg_dx.CDifferentiableAt_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.CDifferentiableAt_rule
  (f : Y → Z) (g : X → Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : CDifferentiableAt K (fun dx' => cderiv K f y (g dx')) dx :=


Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.HasSemiAdjoint_rule
  (y' : K) (f : X → K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => y' * f x :=


Theorem: SciLean.semiAdjoint.id_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem id_rule : semiAdjoint K (fun (x : X) => x) = fun x => x :=


Theorem: SciLean.HasSemiAdjoint.Finset.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.HasSemiAdjoint_rule {ι : Type _} [Fintype ι]
  (f : X → ι → Y) (_ : ∀ i, HasSemiAdjoint K fun x : X => f x i) (A : Finset ι)
  : HasSemiAdjoint K fun x => ∑ i in A, f x i :=


Theorem: SciLean.Measure.restrict_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.restrict_restrict {X} [MeasurableSpace X] (μ : Measure X) (A B : Set X) :
    (μ.restrict A).restrict B = μ.restrict (A ∩ B) :=


Theorem: SciLean.IsContinuousLinearMap.isContinuousLinearMap_differentiable
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem isContinuousLinearMap_differentiable (f : X → Y) (hf : IsContinuousLinearMap K f) :
    Differentiable K f :=


Theorem: SciLean.cderiv.comp_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule
  (f : Y → Z) (g : X → Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : (cderiv K fun x : X => f (g x))
    =
    fun x =>
      let y := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K f y dy
        dz :=


Theorem: SciLean.inner_dualBasis_basis
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_basis  (i j : ι)
  : ⟪ⅇ'[X] i, ⅇ j⟫[K] = if i=j then 1 else 0 :=


Theorem: SciLean.CDifferentiableAt.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.const_rule (y : Y) (x : X)
  : CDifferentiableAt K (fun _ : X => y) x
  :=


Theorem: SciLean.Function.toDistribution_zero
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Function.toDistribution_zero  :
    Function.toDistribution (fun (_ : X) => 0) = (0 : 𝒟'(X,Y)) :=


Theorem: SciLean.Function.invFun.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_a1.cderiv_rule
  (f : Y → Z) (g : X → Z)
  (hf : Diffeomorphism K f) (hg : CDifferentiable K g)
  : cderiv K (fun x => invFun f (g x))
    =
    fun x dx =>
      let z := g x
      let dz := cderiv K g x dx
      let y := invFun f z
      let dy := invFun (cderiv K f y) dz
      dy :=


Theorem: SciLean.Basis.proj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => ℼ i x) x :=


Theorem: SciLean.HasSemiAdjoint.comp_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem comp_rule
    (f : Y → Z) (g : X → Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K (fun x => f (g x)) :=


Theorem: SciLean.Function.invFun.arg_f.cderiv_rule'
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f.cderiv_rule'
  (f : X → Y → Z) (z : Z)
  (hf : ∀ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : X×Y => f xy.1 xy.2))
  : cderiv K (fun x => invFun (f x) z)
    =
    fun x dx =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=


Theorem: SciLean.decomposeSolution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decomposeSolution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys → Zs → Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs → Prop)       (Q₁ : Ys → Zs → Prop) (Q₂ : Ys → Zs → Prop) (equiv : ∀ ys zs, (Q₁ ys zs ∧ Q₂ ys zs) ↔ P (f ys zs))
  (unique : ∀ ys, HasUniqueSolution (Q₁ ys))
  : (solve xs, P xs)
    =
    let zs' := fun ys => (solve zs, Q₁ ys zs)
    let ys  := solve ys, Q₂ ys (zs' ys)
    let zs  := zs' ys
    f ys zs
  :=


Theorem: SciLean.parDistribFwdDeriv.bind_rule
File path: SciLean/Core/Distribution/ParametricDistribFwdDeriv.lean
Theorem statement: theorem bind_rule
    (f : X → Y → 𝒟'(Z,V)) (g : X → 𝒟'(Y,U)) (L : U ⊸ V ⊸ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    parDistribFwdDeriv (fun x => (g x).bind (f x) L)
    =
    fun x dx =>
      let ydy := parDistribFwdDeriv g x dx  let zdz := fun y => parDistribFwdDeriv (f · y) x dx ydy.bind zdz (fun (r,dr) ⊸ fun (s,ds) ⊸ (L r s, L r ds + L dr s)) :=


Theorem: SciLean.HSMul.hSMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSMul.hSMul.arg_a0a1.cderiv_rule_at (x : X) (f : X → K) (g : X → Y)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x • g x) x
    =
    let k := f x
    let y := g x
    fun dx =>
      k • (cderiv K g x dx) + (cderiv K f x dx) • y :=


Theorem: SciLean.semiAdjoint.Finset.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.semiAdjoint_rule {ι : Type _} [Fintype ι]
  (f : X → ι → Y) (hf : ∀ i, HasSemiAdjoint K (f · i))
  : semiAdjoint K (fun x => ∑ i, f x i)
    =
    (fun y => ∑ i, semiAdjoint K (f · i) y) :=


Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.HasSemiAdjoint_rule
  (f : X → Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => ⟪f x, y⟫[K] :=


Theorem: SciLean.split_integral_over_set_of_ite
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem split_integral_over_set_of_ite (φ ψ : X → R) (f g : X → Y) (A : Set X) :
    (∫' x in A, if ψ x ≤ φ x then f x else g x)
    =
    (∫' x in {x' | 0 ≤ φ x' - ψ x'} ∩ A, f x)
    +
    (∫' x in {x' | 0 ≤ ψ x' - φ x'} ∩ A, g x) :=


Theorem: Function.invFun.HAdd.hAdd.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X → Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x + y)
    =
    fun y' =>
      invFun f (y' - y)
  :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.fromDual x) :=


Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiff_rule
    (f g : X → Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x + g x) :=


Theorem: SciLean.Diffeomorphism.comp_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem comp_rule
  (f : Y → Z) (g : X → Y)
  (hf : Diffeomorphism K f) (hg : Diffeomorphism K g)
  : Diffeomorphism K (fun x => f (g x))
  :=


Theorem: SciLean.Rand.bind_pdf
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_pdf (ν : Measure Y) (x : Rand X) (f : X → Rand Y) :
    (x >>= f).pdf R ν = fun y => ∫ x', ((f x').pdf R ν y) ∂x.ℙ :=


Theorem: SciLean.parametric_inverse_affine'
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine' (f : X → R) (c : R) (hf : IsAffineMap R f) :
    let u  := ∇ f 0
    let dec := planeDecomposition (n:=card ι - 1) (R:=R) u sorry_proof
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / ‖u‖₂)
      (dom := fun _ => ⊤) :=


Theorem: SciLean.semiAdjoint.Prod.fst.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.semiAdjoint_rule
  (f : X → Y×Z) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).1)
    =
    (fun y => semiAdjoint K (fun x => f x) (y,0)) :=


Theorem: LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
    (cont : X → Cont) (idx : Idx) (elem : X → Elem)
    (hcont : HasAdjDiff K cont) (helem : HasAdjDiff K elem) :
    revDerivProj K Idx (fun x => Indexed.set (cont x) idx (elem x))
    =
    fun x =>
      let cdc := revDerivProj K Idx cont x
      let ede := revDeriv K elem x
      (Indexed.set cdc.1 idx ede.1,
       fun i delem =>
         if i = idx then
           ede.2 delem
         else
           cdc.2 i delem) :=


Theorem: SciLean.HasSemiAdjoint.HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
  (f : X → K) (hf : HasSemiAdjoint K f) (y : K)
  : HasSemiAdjoint K fun x => f x / y :=


Theorem: SciLean.Diffeomorphism.id_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem id_rule
  : Diffeomorphism K (fun x : X => x)
  :=


Theorem: Function.Bijective.HAdd.hAdd.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X → Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x + y
  :=


Theorem: SciLean.SmoothLinearMap.fintype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.fintype_sum_apply {I} [Fintype I] (f : I → X⊸[K] Y) (x : X) :
    (∑ i, f i) x = ∑ i, f i x  :=


Theorem: SciLean.DistribDiffrentiable.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem DistribDiffrentiable.comp_rule
    (f : Y → 𝒟'(Z,U)) (g : X → Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    DistribDifferentiable (fun x => f (g x)) :=


Theorem: SciLean.BasisDuality.toDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.toDual x) :=


Theorem: Set.Neg.neg.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem Neg.neg.arg_a1.preimage_rule_Ioo (a b : R)  :
    preimage (fun x : R => - x) (Ioo a b)
    =
    Ioo (-b) (-a) :=


Theorem: SciLean.norm₂_prod
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm₂_prod {R K X Y} [Scalar R K] [AddCommMonoid K] [Inner K X] [Inner K Y] (x : X) (y : Y) :
  ‖(x,y)‖₂[K] = Scalar.sqrt (‖x‖₂²[K] + ‖y‖₂²[K]) :=


Theorem: SciLean.cderiv.let_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule
  (f : X → Y → Z) (g : X → Y)
  (hf : CDifferentiable K fun xy : X×Y => f xy.1 xy.2) (hg : CDifferentiable K g)
  : (cderiv K fun x : X =>
       let y := g x
       f x y)
    =
    fun x =>
      let y  := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K (fun xy : X×Y => f xy.1 xy.2) (x,y) (dx, dy)
        dz :=


Theorem: LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple (idx : Idx) :
    IsLinearMap R (fun ((cont,elem) : Cont×Elem) => Indexed.set cont idx elem) :=


Theorem: SciLean.FwdFDeriv.FinType.sum.arg_f.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem FinType.sum.arg_f.fwdFDeriv_rule_at (x : X)
    (f : X → ι → Y) (hf : ∀ i, DifferentiableAt K (f · i) x) :
    fwdFDeriv K (fun x => ∑ i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdFDeriv K (f · i) x dx
      ∑ i, ydy i :=


Theorem: SciLean.scalar_sqrt_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_one  : Scalar.sqrt (1 : R) = 1 :=


Theorem: SciLean.cintegral.arg_f.CDifferentiable_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.CDifferentiable_rule
    (f : X → β → Z) (μ : Measure β) (hf : ∀ x, CDifferentiable R (f · x)) :
    CDifferentiable R (fun x => ∫' y, f x y ∂μ) :=


Theorem: SciLean.Neg.neg.arg_a0.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiff_rule
    (f : X → Y) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => - f x) :=


Theorem: SciLean.semiAdjoint.SciLean.semiAdjoint.arg_y.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.semiAdjoint_rule
  (f : X → Y) (a3 : W → Y) (hf : HasSemiAdjoint K f) (ha3 : HasSemiAdjoint K a3)
  : semiAdjoint K (fun w => semiAdjoint K f (a3 w))
    =
    fun x =>
      let y := f x
      semiAdjoint K a3 y :=


Theorem: SciLean.CDifferentiableAt.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.apply_rule
  (i : ι) (x)
  : CDifferentiableAt K (fun x : (i : ι) → E i => x i) x :=


Theorem: SciLean.Measure.prod_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_restrict {X Y} [MeasurableSpace X] [MeasurableSpace Y]
    (μ : Measure X) (ν : Measure Y) (A : Set X) (B : Set Y) :
    (Measure.prod (μ.restrict A) (ν.restrict B)) = (μ.prod ν).restrict (A ×ˢ B) :=


Theorem: SciLean.Rand.flip.pdf_wrt_flip
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf_wrt_flip (θ θ' : R) :
    (flip θ).pdf R (flip θ').ℙ
    =
    fun b => if b then θ / θ' else (1-θ) / (1-θ') :=


Theorem: SciLean.semiAdjoint.HDiv.hDiv.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.semiAdjoint_rule
  (f : X → K) (c : K)
  (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x / c)
    =
    fun y => (conj c)⁻¹ • semiAdjoint K f y :=


Theorem: Function.invFun.Equiv.invFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.invFun.arg_a0.invFun_rule (f : Y ≃ Z) (g : X → Z) (hf : Bijective g)
  : Function.invFun (fun x => f.invFun (g x))
    =
    fun z => Function.invFun g (f z) :=


Theorem: SciLean.HasSemiAdjoint.const_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem const_rule : HasSemiAdjoint K (fun _ : X => (0:Y)) :=


Theorem: SciLean.ContCDiffMap_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X ⟿[K,n] Y)×X) => fx.1 fx.2) :=


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple
  : Bijective (fun xy : X×Y => (xy.1, xy.2))
  :=


Theorem: SciLean.decompose_has_unique_solution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decompose_has_unique_solution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys → Zs → Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs → Prop)       (Q₁ : Ys → Zs → Prop) (Q₂ : Ys → Zs → Prop) (equiv : ∀ ys zs, (Q₁ ys zs ∧ Q₂ ys zs) ↔ P (f ys zs))
  (unique : ∀ ys, HasUniqueSolution (Q₁ ys))
  : HasUniqueSolution P
    ↔
    HasUniqueSolution fun ys => Q₂ ys (solve zs, Q₁ ys zs)
  :=


Theorem: SciLean.inner_dualBasis_proj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_proj  (i : ι) (x : X)
  : ⟪x, ⅇ' i⟫[K] = ℼ i x :=


Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X → Y) (hf : Bijective f)
  : Bijective fun x => (f x)⁻¹
  :=


Theorem: SciLean.HasSemiAdjoint.Prod.fst.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.HasSemiAdjoint_rule
    (f : X → Y×Z) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).fst :=


Theorem: SciLean.Prod.snd.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.snd.arg_self.CDifferentiable_rule
  (f : X → Y×Z) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).2)  :=


Theorem: SciLean.jacobian.comp_rule
File path: SciLean/Core/Integral/Jacobian.lean
Theorem statement: theorem jacobian.comp_rule (f : U → V) (g : U → U)
    (hf : HasAdjDiff R f) (hg : HasAdjDiff R g) :
    jacobian R (fun x => f (g x))
    =
    fun x => jacobian R f x * jacobian R g x :=


Theorem: SciLean.approx_consistency
File path: SciLean/Core/Approx/ApproxSolution.lean
Theorem statement: theorem approx_consistency {N} {lN : Filter N} [T2Space α] {spec : α → Prop}
  (approx : ApproxSolution lN spec)
  : ∀ a, a = (limit n ∈ lN, approx.val n) → spec a :=


Theorem: SciLean.CDifferentiable.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.comp_rule
  (f : Y → Z) (g : X → Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f (g x))
  :=


Theorem: SciLean.Rand.add_as_flip_E
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem add_as_flip_E {x y : X} (θ : R) (h : θ ∈ Set.Ioo 0 1) :
    x + y = (flip θ).𝔼 (fun b => if b then θ⁻¹ • x else (1-θ)⁻¹ • y) :=


Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a1.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a1.IsContinuousLinearMap_rule
  (f : X → Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ y (f x) :=


Theorem: SciLean.ContCDiffMap_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiable (f : W → X ⟿[K,∞] Y) (g : W → X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=


Theorem: SciLean.scalar_norm
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem scalar_norm {R} [RealScalar R] (r : R) : ‖r‖₂[R] = Scalar.abs r :=


Theorem: SciLean.norm2_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm2_scalar {R} [RealScalar R] (x : R) :
  ‖x‖₂²[R] = x^2 :=


Theorem: IsAffineMap.IsAffineMap_comp
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_comp {f : Y → Z} {g : X → Y}
    (hf : IsAffineMap R f) (hg : IsAffineMap R g) : IsAffineMap R (fun x ↦ f (g x)) :=


Theorem: SciLean.ContCDiffMap_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X ⟿[K,∞] Y)×X) => fx.1 fx.2) :=


Theorem: SciLean.norm₂_squared
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm₂_squared {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : ‖x‖₂[K] ^ (2:K) = ‖x‖₂²[K] :=


Theorem: SciLean.FwdFDeriv.HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at (x : X)
    (f : X → K) (g : X → K)
    (hf : DifferentiableAt K f x) (hg : DifferentiableAt K g x) (hx : g x ≠ 0) :
    (fwdFDeriv K fun x => f x / g x) x
    =
    fun dx =>
      let ydy := (fwdFDeriv K f x dx)
      let zdz := (fwdFDeriv K g x dx)
      (ydy.1 / zdz.1, (ydy.2 * zdz.1 - ydy.1 * zdz.2) / zdz.1^2) :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.fromDual x) x :=


Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_field
  [Field Y]
  (y : Y) (f : X → Y) (hf : Bijective f) (hy : y ≠ 0)
  : Bijective (fun x => y * f x)
  :=


Theorem: SciLean.cderiv.pi_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule
  (f : X → (i : ι) → E i) (hf : ∀ i, CDifferentiable K (f · i))
  : (cderiv K fun (x : X) (i : ι) => f x i)
    =
    fun x => fun dx => fun i =>
      cderiv K (f · i) x dx
  :=


Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a0.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a0.IsContinuousLinearMap_rule
  (f : X → Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ (f x) y :=


Theorem: SciLean.Distribution.postComp.arg_T.IsSmoothLinarMap_rule
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.postComp.arg_T.IsSmoothLinarMap_rule (T : W → 𝒟'(X,Y)) (f : Y ⊸ Z)
    (hT : IsSmoothLinearMap R T) :
    IsSmoothLinearMap R (fun w => (T w).postComp f) :=


Theorem: SciLean.DualBasis.dualProj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => ℼ' i x) :=


Theorem: SciLean.parDistribDeriv.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem parDistribDeriv.comp_rule
    (f : Y → 𝒟'(Z,U)) (g : X → Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    parDistribDeriv (fun x => f (g x))
    =
    fun x dx =>
      let ydy := fwdDeriv R g x dx
      parDistribDeriv f ydy.1 ydy.2 :=


Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.semiAdjoint_rule
  (c : K) (g : X → Y) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => c • g x)
    =
    fun y => (conj c) • semiAdjoint K g y :=


Theorem: SciLean.HasSemiAdjoint.HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule [ContinuousAdd Y]
    (f g : X → Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x + g x :=


Theorem: SciLean.ContCDiffAt.const_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.const_rule (y : Y) (x : X) :
    ContCDiffAt K n (fun _ : X => y) x :=


Theorem: SciLean.Distribution.fintype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.fintype_sum_extAction {I} [Fintype I] (T : I → 𝒟'(X,U)) (φ : X → V) (L : U ⊸ V ⊸ W) :
    (∑ i, T i).extAction φ L = ∑ i, (T i).extAction φ L :=


Theorem: SciLean.BasisDuality.toDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.toDual x) :=


Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_group
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_group
  [Group Y]
  (f : X → Y) (hf : Bijective f)
  : invFun (fun x => (f x)⁻¹)
    =
    fun y =>
      invFun f (y⁻¹)
  :=


Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.HasSemiAdjoint_rule
  (f : X → K) (y' : K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x * y' :=


Theorem: SciLean.fderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/FDeriv.lean
Theorem statement: theorem fderiv.apply_rule (i : ι) :
    (fderiv K fun (x : (i : ι) → E i) => x i)
    =
    fun _ => fun dx =>L[K] dx i :=


Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X → K) (y : Y) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x • y :=


Theorem: SciLean.proj_zero
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem proj_zero (i : ι)
  : ℼ i (0 : X) = 0 :=


Theorem: SciLean.IndexType.sum.arg_f.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.cderiv_rule_at
  (f : X → ι → Y) (x : X) (hf : ∀ i, CDifferentiableAt K (f · i) x)
  : cderiv K (fun x => ∑ i, f x i) x
    =
    fun dx => ∑ i, cderiv K (f · i) x dx :=


Theorem: SciLean.HasSemiAdjoint.Neg.neg.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.HasSemiAdjoint_rule
    (f : X → Y) : HasSemiAdjoint K fun x => - f x :=


Theorem: SciLean.Distribution.add_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.add_extAction (T T' : 𝒟'(X,U)) (φ : X → V) (L : U ⊸ V ⊸ W) :
    ((T + T') : 𝒟'(X,U)).extAction φ L = T.extAction φ L + T'.extAction φ L :=


Theorem: SciLean.Bind.bind.arg_fx.DistribDifferentiable_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem Bind.bind.arg_fx.DistribDifferentiable_rule
    (f : X → Y → 𝒟'(Z,V)) (g : X → 𝒟'(Y,U)) (L : U ⊸ V ⊸ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    DistribDifferentiable (fun x => (g x).bind (f x) L) :=


Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.toDual x) :=


Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X → Y) (y : Y)
  (hf : Bijective f) (hy : y ≠ 0)
  : Bijective (fun x => f x / y) :=


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule
  (f : X₁ → Y) (g : X₂ → Z) (p₁ : X → X₁) (p₂ : X → X₂)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (p₁ x, p₂ x)))
  : Bijective (fun x : X => (f (p₁ x), g (p₂ x)))
  :=


Theorem: SciLean.cintegral.arg_f.cderiv_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.cderiv_rule
    (f : X → β → Z) (μ : Measure β) (hf : ∀ y, CDifferentiable R (f · y)) :
    (cderiv R  fun x => ∫' y, f x y ∂μ)
    =
    fun x dx => ∫' y, cderiv R (f · y) x dx ∂μ :=


Theorem: IsLinearMap.isLinearMap_pi
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_pi (f : X → (i : ι) → E i) (hf : ∀ i, IsLinearMap R (f · i)) :
    IsLinearMap R (fun x i ↦ f x i) :=


Theorem: IndexType.sum.arg_f.revDerivProj_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProj_rule [DecidableEq ι]
    (f : X → ι → Y') (hf : ∀ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProj K Yi (fun x => ∑ i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (ι×Yi) f x
      (∑ i, ydf.1 i,
       fun j dy =>
         Fold.fold (IndexType.univ ι) (fun dx i => ydf.2 (i,j) dy dx) 0) :=


Theorem: SciLean.SciLean.norm₂.arg_x.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.norm₂.arg_x.cderiv_rule_at
  (f : X → Y) (x : X)
  (hf : CDifferentiableAt R f x) (hx : f x≠0)
  : cderiv R (fun x => ‖f x‖₂[R]) x
    =
    fun dx =>
      let y := f x
      let dy := cderiv R f x dx
      ‖y‖₂[R]⁻¹ * ⟪dy,y⟫[R] :=


Theorem: SciLean.HAdd.hAdd.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.cderiv_rule
    (f : X → Y) (y : Y) :
    (cderiv K fun x => y + f x)
    =
    fun x dx =>
      cderiv K f x dx :=


Theorem: Function.invFun.Neg.neg.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Neg.neg.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X → Y) (hf : Bijective f)
  : invFun (fun x => - f x)
    =
    fun y =>
      invFun f (-y)
  :=


Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/teorth/pfr (commit: 861715b9bf9482d2442760169cb2a3ff54091f75)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 18

Theorem: multiDist_indep
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_indep {m : ℕ} {Ω : Type*} (hΩ : MeasureSpace Ω) (X : Fin m → Ω → G)
    (hindep: iIndepFun (fun _ ↦ hG) X hΩ.volume) :
    D[X ; fun _ ↦ hΩ] = H[∑ i, X i ; hΩ.volume] - (∑ i, H[X i; hΩ.volume]) / m :=


Theorem: cond_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cond_multiDist_chainRule : 0 = 1 :=


Theorem: multidist_eq_zero
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_eq_zero : 0 = 1 :=


Theorem: ProbabilityTheory.kernel.iIndepFun.finsets
File path: PFR/Mathlib/Probability/Independence/Kernel.lean
Theorem statement: lemma iIndepFun.finsets [IsMarkovKernel κ] {J : Type*} [Fintype J]
    (S : J → Finset ι) (h_disjoint : Set.PairwiseDisjoint Set.univ S)
    (hf_Indep : iIndepFun m f κ μ) (hf_meas : ∀ i, Measurable (f i)) :
    iIndepFun (fun _ ↦ pi) (fun (j : J) ↦ fun a (i : S j) ↦ f i a) κ μ :=


Theorem: multiDist_nonneg
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_nonneg {m : ℕ} {Ω : Fin m → Type*} (hΩ: (i : Fin m) → MeasureSpace (Ω i))
    (X : (i : Fin m) → (Ω i) → G) : D[X ; hΩ] ≥ 0 :=


Theorem: multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_chainRule : 0 = 1 :=


Theorem: condMultiDist_eq
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma condMultiDist_eq : 0 = 1 :=


Theorem: ent_of_sum_le_ent_of_sum
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma ent_of_sum_le_ent_of_sum [IsProbabilityMeasure μ] {I : Type*} {s t : Finset I} (hdisj : Disjoint s t)
    (hs : Finset.Nonempty s) (ht : Finset.Nonempty t) (X : I → Ω → G) (hX : (i : I) → Measurable (X i))
    (hX' : (i : I) → FiniteRange (X i)) (hindep : iIndepFun (fun (i : I) => hG) X μ ) (f : I → I)
    (hf: Finset.image f t ⊆ s) :
    H[∑ i in t, X i; μ] ≤ H[∑ i in s, X i; μ] + ∑ i in t, (H[X i - X (f i); μ] - H[X (f i); μ]) :=


Theorem: iter_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule : 0 = 1 :=


Theorem: kvm_ineq_II
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma kvm_ineq_II {I : Type*} {i₀ : I} {s : Finset I} (hs : ¬ i₀ ∈ s) (hs' : Finset.Nonempty s)
    (Y : I → Ω → G)  (hY : (i : I) → Measurable (Y i)) (hindep : iIndepFun (fun (i : I) => hG) Y μ) :
    d[Y i₀; μ # ∑ i in s, Y i; μ] ≤ 2 * ∑ i in s, d[Y i₀; μ # Y i; μ] :=


Theorem: multidist_ruzsa_II
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_II : 0 = 1 :=


Theorem: multiDist_copy
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_copy {m:ℕ} {Ω : Fin m → Type*} {Ω' : Fin m → Type*} (hΩ : (i : Fin m) → MeasureSpace (Ω i))
    (hΩ': (i : Fin m) → MeasureSpace (Ω' i)) (X : (i : Fin m) → (Ω i) → G) (X' : (i : Fin m) → (Ω' i) → G)
    (hident: ∀ i, IdentDistrib (X i) (X' i) (hΩ i).volume (hΩ' i).volume) :
    D[X ; hΩ] = D[X' ; hΩ'] :=


Theorem: multidist_ruzsa_III
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_III : 0 = 1 :=


Theorem: multidist_ruzsa_IV
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_IV : 0 = 1 :=


Theorem: cor_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cor_multiDist_chainRule : 0 = 1 :=


Theorem: kvm_ineq_III
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma kvm_ineq_III {I : Type*} {i₀ : I} {s : Finset I} (hs : ¬ i₀ ∈ s) (hs' : Finset.Nonempty s)
    (Y : I → Ω → G) (hY : (i : I) → Measurable (Y i)) (hindep : iIndepFun (fun (i : I) => hG) Y μ)
    (i₁ : I) : d[Y i₀; μ # ∑ i in s, Y i; μ]
      ≤ d[Y i₀; μ # Y i₁; μ] + (2:ℝ)⁻¹ * ∑ i in s, (H[Y i; μ] - H[Y i₁; μ]) :=


Theorem: iter_multiDist_chainRule'
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule' : 0 = 1 :=


Theorem: multidist_ruzsa_I
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_I : 0 = 1 :=


Common Unproved sorry theorems: 0
