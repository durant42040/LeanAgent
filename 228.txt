, end=(286, 28), kind='commanddeclaration'), Premise(full_name='MeasureTheory.integrable_indicatorConstLp', code='theorem integrable_indicatorConstLp {E} [NormedAddCommGroup E] {p : ℝ≥0∞} {s : Set α}\n    (hs : Measur
ableSet s) (hμs : μ s ≠ ∞) (c : E) :\n    Integrable (indicatorConstLp p hs hμs c) μ', start=(289, 1), end=(295, 84), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableOn.restrict_toMeasurable', c
ode="theorem IntegrableOn.restrict_toMeasurable (hf : IntegrableOn f s μ) (h's : ∀ x ∈ s, f x ≠ 0) :\n    μ.restrict (toMeasurable μ s) = μ.restrict s", start=(299, 1), end=(315, 56), kind='commanddeclaration'), Premi
se(full_name='MeasureTheory.IntegrableOn.of_ae_diff_eq_zero', code="theorem IntegrableOn.of_ae_diff_eq_zero (hf : IntegrableOn f s μ) (ht : NullMeasurableSet t μ)\n    (h't : ∀ᵐ x ∂μ, x ∈ t \\ s → f x = 0) : Integrabl
eOn f t μ", start=(318, 1), end=(339, 31), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableOn.of_forall_diff_eq_zero', code="theorem IntegrableOn.of_forall_diff_eq_zero (hf : IntegrableOn f s μ)
 (ht : MeasurableSet t)\n    (h't : ∀ x ∈ t \\ s, f x = 0) : IntegrableOn f t μ", start=(342, 1), end=(346, 72), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableOn.integrable_of_ae_not_mem_eq_ze
ro', code="theorem IntegrableOn.integrable_of_ae_not_mem_eq_zero (hf : IntegrableOn f s μ)\n    (h't : ∀ᵐ x ∂μ, x ∉ s → f x = 0) : Integrable f μ", start=(349, 1), end=(355, 52), kind='commanddeclaration'), Premise(fu
ll_name='MeasureTheory.IntegrableOn.integrable_of_forall_not_mem_eq_zero', code="theorem IntegrableOn.integrable_of_forall_not_mem_eq_zero (hf : IntegrableOn f s μ)\n    (h't : ∀ x, x ∉ s → f x = 0) : Integrable f μ",
 start=(358, 1), end=(362, 82), kind='commanddeclaration'), Premise(full_name='MeasureTheory.integrableOn_iff_integrable_of_support_subset', code='theorem integrableOn_iff_integrable_of_support_subset (h1s : support f
 ⊆ s) :\n    IntegrableOn f s μ ↔ Integrable f μ', start=(365, 1), end=(370, 31), kind='commanddeclaration'), Premise(full_name='MeasureTheory.integrableOn_Lp_of_measure_ne_top', code='theorem integrableOn_Lp_of_measu
re_ne_top {E} [NormedAddCommGroup E] {p : ℝ≥0∞} {s : Set α}\n    (f : Lp E p μ) (hp : 1 ≤ p) (hμs : μ s ≠ ∞) : IntegrableOn f s μ', start=(373, 1), end=(379, 58), kind='commanddeclaration'), Premise(full_name='Measure
Theory.Integrable.lintegral_lt_top', code='theorem Integrable.lintegral_lt_top {f : α → ℝ} (hf : Integrable f μ) :\n    (∫⁻ x, ENNReal.ofReal (f x) ∂μ) < ∞', start=(383, 1), end=(387, 18), kind='commanddeclaration'),
Premise(full_name='MeasureTheory.IntegrableOn.set_lintegral_lt_top', code='theorem IntegrableOn.set_lintegral_lt_top {f : α → ℝ} {s : Set α} (hf : IntegrableOn f s μ) :\n    (∫⁻ x in s, ENNReal.ofReal (f x) ∂μ) < ∞',
start=(390, 1), end=(392, 33), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableAtFilter', code='def IntegrableAtFilter (f : α → E) (l : Filter α) (μ : Measure α := by volume_tac) :=\n  ∃ s ∈ l,
IntegrableOn f s μ', start=(395, 1), end=(398, 30), kind='commanddeclaration'), Premise(full_name='MeasurableEmbedding.integrableAtFilter_map_iff', code='theorem _root_.MeasurableEmbedding.integrableAtFilter_map_iff [
MeasurableSpace β] {e : α → β}\n    (he : MeasurableEmbedding e) {f : β → E} :\n    IntegrableAtFilter f (l.map e) (μ.map e) ↔ IntegrableAtFilter (f ∘ e) l μ', start=(403, 1), end=(409, 66), kind='commanddeclaration')
, Premise(full_name='MeasurableEmbedding.integrableAtFilter_iff_comap', code='theorem _root_.MeasurableEmbedding.integrableAtFilter_iff_comap [MeasurableSpace β] {e : α → β}\n    (he : MeasurableEmbedding e) {f : β →
E} {μ : Measure β} :\n    IntegrableAtFilter f (l.map e) μ ↔ IntegrableAtFilter (f ∘ e) l (μ.comap e)', start=(411, 1), end=(417, 65), kind='commanddeclaration'), Premise(full_name='MeasureTheory.Integrable.integrable
AtFilter', code='theorem Integrable.integrableAtFilter (h : Integrable f μ) (l : Filter α) :\n    IntegrableAtFilter f l μ', start=(419, 1), end=(421, 49), kind='commanddeclaration'), Premise(full_name='MeasureTheory.
IntegrableAtFilter.eventually', code='protected theorem IntegrableAtFilter.eventually (h : IntegrableAtFilter f l μ) :\n    ∀ᶠ s in l.smallSets, IntegrableOn f s μ', start=(424, 1), end=(426, 72), kind='commanddeclara
tion'), Premise(full_name='MeasureTheory.IntegrableAtFilter.add', code='protected theorem IntegrableAtFilter.add {f g : α → E}\n    (hf : IntegrableAtFilter f l μ) (hg : IntegrableAtFilter g l μ) :\n    IntegrableAtFi
lter (f + g) l μ', start=(429, 1), end=(435, 89), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableAtFilter.neg', code='protected theorem IntegrableAtFilter.neg {f : α → E} (hf : IntegrableAtFilt
er f l μ) :\n    IntegrableAtFilter (-f) l μ', start=(437, 1), end=(440, 24), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableAtFilter.sub', code='protected theorem IntegrableAtFilter.sub {f g :
 α → E}\n    (hf : IntegrableAtFilter f l μ) (hg : IntegrableAtFilter g l μ) :\n    IntegrableAtFilter (f - g) l μ', start=(442, 1), end=(446, 22), kind='commanddeclaration'), Premise(full_name='MeasureTheory.Integrab
leAtFilter.smul', code='protected theorem IntegrableAtFilter.smul {𝕜 : Type*} [NormedAddCommGroup 𝕜] [SMulZeroClass 𝕜 E]\n    [BoundedSMul 𝕜 E] {f : α → E} (hf : IntegrableAtFilter f l μ) (c : 𝕜) :\n    IntegrableAtFi
lter (c • f) l μ', start=(448, 1), end=(452, 27), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableAtFilter.norm', code='protected theorem IntegrableAtFilter.norm (hf : IntegrableAtFilter f l μ)
:\n    IntegrableAtFilter (fun x => ‖f x‖) l μ', start=(454, 1), end=(456, 52), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableAtFilter.filter_mono', code="theorem IntegrableAtFilter.filter_mon
o (hl : l ≤ l') (hl' : IntegrableAtFilter f l' μ) :\n    IntegrableAtFilter f l μ", start=(458, 1), end=(461, 18), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableAtFilter.inf_of_left', code="th
eorem IntegrableAtFilter.inf_of_left (hl : IntegrableAtFilter f l μ) :\n    IntegrableAtFilter f (l ⊓ l') μ", start=(464, 1), end=(466, 29), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableAtFil
ter.inf_of_right', code="theorem IntegrableAtFilter.inf_of_right (hl : IntegrableAtFilter f l μ) :\n    IntegrableAtFilter f (l' ⊓ l) μ", start=(469, 1), end=(471, 30), kind='commanddeclaration'), Premise(full_name='M
easureTheory.IntegrableAtFilter.inf_ae_iff', code='@[simp]\ntheorem IntegrableAtFilter.inf_ae_iff {l : Filter α} :\n    IntegrableAtFilter f (l ⊓ ae μ) μ ↔ IntegrableAtFilter f l μ', start=(474, 1), end=(480, 61), kin
d='commanddeclaration'), Premise(full_name='MeasureTheory.integrableAtFilter_top', code='@[simp]\ntheorem integrableAtFilter_top : IntegrableAtFilter f ⊤ μ ↔ Integrable f μ', start=(486, 1), end=(490, 78), kind='comma
nddeclaration'), Premise(full_name='MeasureTheory.IntegrableAtFilter.sup_iff', code="theorem IntegrableAtFilter.sup_iff {l l' : Filter α} :\n    IntegrableAtFilter f (l ⊔ l') μ ↔ IntegrableAtFilter f l μ ∧ IntegrableA
tFilter f l' μ", start=(492, 1), end=(496, 89), kind='commanddeclaration'), Premise(full_name='MeasureTheory.Measure.FiniteAtFilter.integrableAtFilter', code='theorem Measure.FiniteAtFilter.integrableAtFilter {l : Fil
ter α} [IsMeasurablyGenerated l]\n    (hfm : StronglyMeasurableAtFilter f l μ) (hμ : μ.FiniteAtFilter l)\n    (hf : l.IsBoundedUnder (· ≤ ·) (norm ∘ f)) : IntegrableAtFilter f l μ', start=(498, 1), end=(509, 32), kind
='commanddeclaration'), Premise(full_name='MeasureTheory.Measure.FiniteAtFilter.integrableAtFilter_of_tendsto_ae', code='theorem Measure.FiniteAtFilter.integrableAtFilter_of_tendsto_ae {l : Filter α}\n    [IsMeasurabl
yGenerated l] (hfm : StronglyMeasurableAtFilter f l μ) (hμ : μ.FiniteAtFilter l) {b}\n    (hf : Tendsto f (l ⊓ ae μ) (𝓝 b)) : IntegrableAtFilter f l μ', start=(512, 1), end=(516, 43), kind='commanddeclaration'), Premi
se(full_name='MeasureTheory.Measure.FiniteAtFilter.integrableAtFilter_of_tendsto', code='theorem Measure.FiniteAtFilter.integrableAtFilter_of_tendsto {l : Filter α}\n    [IsMeasurablyGenerated l] (hfm : StronglyMeasur
ableAtFilter f l μ) (hμ : μ.FiniteAtFilter l) {b}\n    (hf : Tendsto f l (𝓝 b)) : IntegrableAtFilter f l μ', start=(523, 1), end=(526, 54), kind='commanddeclaration'), Premise(full_name='MeasureTheory.Measure.integrab
leOn_of_bounded', code='lemma Measure.integrableOn_of_bounded (s_finite : μ s ≠ ∞) (f_mble : AEStronglyMeasurable f μ)\n    {M : ℝ} (f_bdd : ∀ᵐ a ∂(μ.restrict s), ‖f a‖ ≤ M) :\n    IntegrableOn f s μ :=\n  ⟨f_mble.res
trict, hasFiniteIntegral_restrict_of_bounded (C := M) s_finite.lt_top f_bdd⟩', start=(533, 1), end=(536, 90), kind='lemma'), Premise(full_name='MeasureTheory.integrable_add_of_disjoint', code='theorem integrable_add_o
f_disjoint {f g : α → E} (h : Disjoint (support f) (support g))\n    (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    Integrable (f + g) μ ↔ Integrable f μ ∧ Integrable g μ', start=(538, 1), end=(543, 82
), kind='commanddeclaration'), Premise(full_name='MeasureTheory.IntegrableAtFilter.eq_zero_of_tendsto', code="lemma IntegrableAtFilter.eq_zero_of_tendsto\n    (h : IntegrableAtFilter f l μ) (h' : ∀ s ∈ l, μ s = ∞) {a
: E}\n    (hf : Tendsto f l (𝓝 a)) : a = 0 := by\n  by_contra H\n  obtain ⟨ε, εpos, hε⟩ : ∃ (ε : ℝ), 0 < ε ∧ ε < ‖a‖ := exists_between (norm_pos_iff'.mpr H)\n  rcases h with ⟨u, ul, hu⟩\n  let v := u ∩ {b | ε < ‖f b‖}
\n  have hv : IntegrableOn f v μ := hu.mono_set (inter_subset_left _ _)\n  have vl : v ∈ l := inter_mem ul ((tendsto_order.1 hf.norm).1 _ hε)\n  have : μ.restrict v v < ∞ := lt_of_le_of_lt (measure_mono (inter_subset_
right _ _))\n    (Integrable.measure_gt_lt_top hv.norm εpos)\n  have : μ v ≠ ∞ := ne_of_lt (by simpa only [Measure.restrict_apply_self])\n  exact this (h' v vl)", start=(546, 1), end=(560, 23), kind='lemma'), Premise(
full_name='ContinuousOn.aemeasurable', code='theorem ContinuousOn.aemeasurable [TopologicalSpace α] [OpensMeasurableSpace α] [MeasurableSpace β]\n    [TopologicalSpace β] [BorelSpace β] {f : α → β} {s : Set α} {μ : Me
asure α}\n    (hf : ContinuousOn f s) (hs : MeasurableSet s) : AEMeasurable f (μ.restrict s)', start=(570, 1), end=(583, 92), kind='commanddeclaration'), Premise(full_name='ContinuousOn.aestronglyMeasurable_of_isSepar
able', code="theorem ContinuousOn.aestronglyMeasurable_of_isSeparable [TopologicalSpace α]\n    [PseudoMetrizableSpace α] [OpensMeasurableSpace α] [TopologicalSpace β]\n    [PseudoMetrizableSpace β] {f : α → β} {s : S
et α} {μ : Measure α} (hf : ContinuousOn f s)\n    (hs : MeasurableSet s) (h's : TopologicalSpace.IsSeparable s) :\n    AEStronglyMeasurable f (μ.restrict s)", start=(586, 1), end=(597, 78), kind='commanddeclaration')
, Premise(full_name='ContinuousOn.aestronglyMeasurable', code='theorem ContinuousOn.aestronglyMeasurable [TopologicalSpace α] [TopologicalSpace β]\n    [h : SecondCountableTopologyEither α β] [OpensMeasurableSpace α]
[PseudoMetrizableSpace β]\n    {f : α → β} {s : Set α} {μ : Measure α} (hf : ContinuousOn f s) (hs : MeasurableSet s) :\n    AEStronglyMeasurable f (μ.restrict s)', start=(600, 1), end=(614, 31), kind='commanddeclarat
ion'), Premise(full_name='ContinuousOn.aestronglyMeasurable_of_isCompact', code="theorem ContinuousOn.aestronglyMeasurable_of_isCompact [TopologicalSpace α] [OpensMeasurableSpace α]\n    [TopologicalSpace β] [PseudoMe
trizableSpace β] {f : α → β} {s : Set α} {μ : Measure α}\n    (hf : ContinuousOn f s) (hs : IsCompact s) (h's : MeasurableSet s) :\n    AEStronglyMeasurable f (μ.restrict s)", start=(617, 1), end=(628, 81), kind='comm
anddeclaration'), Premise(full_name='ContinuousOn.integrableAt_nhdsWithin_of_isSeparable', code="theorem ContinuousOn.integrableAt_nhdsWithin_of_isSeparable [TopologicalSpace α]\n    [PseudoMetrizableSpace α] [OpensMe
asurableSpace α] {μ : Measure α} [IsLocallyFiniteMeasure μ]\n    {a : α} {t : Set α} {f : α → E} (hft : ContinuousOn f t) (ht : MeasurableSet t)\n    (h't : TopologicalSpace.IsSeparable t) (ha : a ∈ t) : IntegrableAtF
ilter f (𝓝[t] a) μ", start=(631, 1), end=(638, 32), kind='commanddeclaration'), Premise(full_name='ContinuousOn.integrableAt_nhdsWithin', code='theorem ContinuousOn.integrableAt_nhdsWithin [TopologicalSpace α]\n    [S
econdCountableTopologyEither α E] [OpensMeasurableSpace α] {μ : Measure α}\n    [IsLocallyFiniteMeasure μ] {a : α} {t : Set α} {f : α → E} (hft : ContinuousOn f t)\n    (ht : MeasurableSet t) (ha : a ∈ t) : Integrable
AtFilter f (𝓝[t] a) μ', start=(641, 1), end=(647, 32), kind='commanddeclaration'), Premise(full_name='Continuous.integrableAt_nhds', code='theorem Continuous.integrableAt_nhds [TopologicalSpace α] [SecondCountableTopo
logyEither α E]\n    [OpensMeasurableSpace α] {μ : Measure α} [IsLocallyFiniteMeasure μ] {f : α → E}\n    (hf : Continuous f) (a : α) : IntegrableAtFilter f (𝓝 a) μ', start=(650, 1), end=(654, 80), kind='commanddeclar
ation'), Premise(full_name='ContinuousOn.stronglyMeasurableAtFilter', code='theorem ContinuousOn.stronglyMeasurableAtFilter [TopologicalSpace α] [OpensMeasurableSpace α]\n    [TopologicalSpace β] [PseudoMetrizableSpac
e β] [SecondCountableTopologyEither α β] {f : α → β}\n    {s : Set α} {μ : Measure α} (hs : IsOpen s) (hf : ContinuousOn f s) :\n    ∀ x ∈ s, StronglyMeasurableAtFilter f (𝓝 x) μ', start=(657, 1), end=(663, 71), kind=
'commanddeclaration'), Premise(full_name='ContinuousAt.stronglyMeasurableAtFilter', code='theorem ContinuousAt.stronglyMeasurableAtFilter [TopologicalSpace α] [OpensMeasurableSpace α]\n    [SecondCountableTopologyEith
er α E] {f : α → E} {s : Set α} {μ : Measure α} (hs : IsOpen s)\n    (hf : ∀ x ∈ s, ContinuousAt f x) : ∀ x ∈ s, StronglyMeasurableAtFilter f (𝓝 x) μ', start=(666, 1), end=(669, 77), kind='commanddeclaration'), Premis
e(full_name='Continuous.stronglyMeasurableAtFilter', code='theorem Continuous.stronglyMeasurableAtFilter [TopologicalSpace α] [OpensMeasurableSpace α]\n    [TopologicalSpace β] [PseudoMetrizableSpace β] [SecondCountab
leTopologyEither α β] {f : α → β}\n    (hf : Continuous f) (μ : Measure α) (l : Filter α) : StronglyMeasurableAtFilter f l μ', start=(672, 1), end=(675, 51), kind='commanddeclaration'), Premise(full_name='ContinuousOn
.stronglyMeasurableAtFilter_nhdsWithin', code='theorem ContinuousOn.stronglyMeasurableAtFilter_nhdsWithin {α β : Type*} [MeasurableSpace α]\n    [TopologicalSpace α] [OpensMeasurableSpace α] [TopologicalSpace β] [Pseu
doMetrizableSpace β]\n    [SecondCountableTopologyEither α β] {f : α → β} {s : Set α} {μ : Measure α}\n    (hf : ContinuousOn f s) (hs : MeasurableSet s) (x : α) :\n    StronglyMeasurableAtFilter f (𝓝[s] x) μ', start=
(678, 1), end=(685, 55), kind='commanddeclaration'), Premise(full_name="integrableOn_Icc_iff_integrableOn_Ioc'", code="theorem integrableOn_Icc_iff_integrableOn_Ioc' (ha : μ {a} ≠ ∞) :\n    IntegrableOn f (Icc a b) μ
↔ IntegrableOn f (Ioc a b) μ", start=(699, 1), end=(706, 17), kind='commanddeclaration'), Premise(full_name="integrableOn_Icc_iff_integrableOn_Ico'", code="theorem integrableOn_Icc_iff_integrableOn_Ico' (hb : μ {b} ≠
∞) :\n    IntegrableOn f (Icc a b) μ ↔ IntegrableOn f (Ico a b) μ", start=(709, 1), end=(716, 17), kind='commanddeclaration'), Premise(full_name="integrableOn_Ico_iff_integrableOn_Ioo'", code="theorem integrableOn_Ico
_iff_integrableOn_Ioo' (ha : μ {a} ≠ ∞) :\n    IntegrableOn f (Ico a b) μ ↔ IntegrableOn f (Ioo a b) μ", start=(719, 1), end=(724, 44), kind='commanddeclaration'), Premise(full_name="integrableOn_Ioc_iff_integrableOn_
Ioo'", code="theorem integrableOn_Ioc_iff_integrableOn_Ioo' (hb : μ {b} ≠ ∞) :\n    IntegrableOn f (Ioc a b) μ ↔ IntegrableOn f (Ioo a b) μ", start=(727, 1), end=(732, 44), kind='commanddeclaration'), Premise(full_nam
e="integrableOn_Icc_iff_integrableOn_Ioo'", code="theorem integrableOn_Icc_iff_integrableOn_Ioo' (ha : μ {a} ≠ ∞) (hb : μ {b} ≠ ∞) :\n    IntegrableOn f (Icc a b) μ ↔ IntegrableOn f (Ioo a b) μ", start=(735, 1), end=(
737, 92), kind='commanddeclaration'), Premise(full_name="integrableOn_Ici_iff_integrableOn_Ioi'", code="theorem integrableOn_Ici_iff_integrableOn_Ioi' (hb : μ {b} ≠ ∞) :\n    IntegrableOn f (Ici b) μ ↔ IntegrableOn f
(Ioi b) μ", start=(740, 1), end=(743, 80), kind='commanddeclaration'), Premise(full_name="integrableOn_Iic_iff_integrableOn_Iio'", code="theorem integrableOn_Iic_iff_integrableOn_Iio' (hb : μ {b} ≠ ∞) :\n    Integrabl
eOn f (Iic b) μ ↔ IntegrableOn f (Iio b) μ", start=(746, 1), end=(749, 80), kind='commanddeclaration'), Premise(full_name='integrableOn_Icc_iff_integrableOn_Ioc', code='theorem integrableOn_Icc_iff_integrableOn_Ioc :\
n    IntegrableOn f (Icc a b) μ ↔ IntegrableOn f (Ioc a b) μ', start=(754, 1), end=(756, 96), kind='commanddeclaration'), Premise(full_name='integrableOn_Icc_iff_integrableOn_Ico', code='theorem integrableOn_Icc_iff_i
ntegrableOn_Ico :\n    IntegrableOn f (Icc a b) μ ↔ IntegrableOn f (Ico a b) μ', start=(759, 1), end=(761, 96), kind='commanddeclaration'), Premise(full_name='integrableOn_Ico_iff_integrableOn_Ioo', code='theorem inte
grableOn_Ico_iff_integrableOn_Ioo :\n    IntegrableOn f (Ico a b) μ ↔ IntegrableOn f (Ioo a b) μ', start=(764, 1), end=(766, 96), kind='commanddeclaration'), Premise(full_name='integrableOn_Ioc_iff_integrableOn_Ioo',
code='theorem integrableOn_Ioc_iff_integrableOn_Ioo :\n    IntegrableOn f (Ioc a b) μ ↔ IntegrableOn f (Ioo a b) μ', start=(769, 1), end=(771, 96), kind='commanddeclaration'), Premise(full_name='integrableOn_Icc_iff_i
ntegrableOn_Ioo', code='theorem integrableOn_Icc_iff_integrableOn_Ioo :\n    IntegrableOn f (Icc a b) μ ↔ IntegrableOn f (Ioo a b) μ', start=(774, 1), end=(776, 84), kind='commanddeclaration'), Premise(full_name='inte
grableOn_Ici_iff_integrableOn_Ioi', code='theorem integrableOn_Ici_iff_integrableOn_Ioi :\n    IntegrableOn f (Ici b) μ ↔ IntegrableOn f (Ioi b) μ', start=(779, 1), end=(781, 96), kind='commanddeclaration'), Premise(f
ull_name='integrableOn_Iic_iff_integrableOn_Iio', code='theorem integrableOn_Iic_iff_integrableOn_Iio :\n    IntegrableOn f (Iic b) μ ↔ IntegrableOn f (Iio b) μ', start=(784, 1), end=(786, 96), kind='commanddeclaratio
n')]), PremiseFile(path=PosixPath('.lake/packages/mathlib/Mathlib/Probability/ProbabilityMassFunction/Integrals.lean'), imports=['.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/mathlib/Mathlib/MeasureTheory
/Integral/Bochner.lean', '.lake/packages/mathlib/Mathlib/Probability/ProbabilityMassFunction/Basic.lean', '.lake/packages/mathlib/Mathlib/Probability/ProbabilityMassFunction/Constructions.lean'], premises=[Premise(ful
l_name='PMF.integral_eq_tsum', code="theorem integral_eq_tsum (p : PMF α) (f : α → E) (hf : Integrable f p.toMeasure) :\n    ∫ a, f a ∂(p.toMeasure) = ∑' a, (p a).toReal • f a", start=(28, 1), end=(41, 56), kind='comm
anddeclaration'), Premise(full_name='PMF.integral_eq_sum', code='theorem integral_eq_sum [Fintype α] (p : PMF α) (f : α → E) :\n    ∫ a, f a ∂(p.toMeasure) = ∑ a, (p a).toReal • f a', start=(43, 1), end=(47, 70), kind
='commanddeclaration'), Premise(full_name='PMF.bernoulli_expectation', code='theorem bernoulli_expectation {p : ℝ≥0∞} (h : p ≤ 1) :\n    ∫ b, cond b 1 0 ∂((bernoulli p h).toMeasure) = p.toReal', start=(51, 1), end=(52
, 89), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/lean4/src/lean/lake/Lake/CLI.lean'), imports=['.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/lean4/src/lean/lake/Lake/CLI/Mai
n.lean'], premises=[]), PremiseFile(path=PosixPath('.lake/packages/lean4/src/lean/lake/Lake.lean'), imports=['.lake/packages/lean4/src/lean/lake/Lake/Version.lean', '.lake/packages/lean4/src/lean/lake/Lake/CLI/Actions
.lean', '.lake/packages/lean4/src/lean/lake/Lake/Toml.lean', '.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/lean4/src/lean/lake/Lake/Build.lean', '.lake/packages/lean4/src/lean/lake/Lake/DSL.lean', '.lake/
packages/lean4/src/lean/lake/Lake/Config.lean'], premises=[]), PremiseFile(path=PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/LLVMBindings.lean'), imports=['.lake/packages/lean4/src/lean/Init/System/IO.lea
n'], premises=[Premise(full_name='LLVM.CodegenFileType', code='structure CodegenFileType where\n  private mk :: val : UInt64', start=(20, 1), end=(21, 29), kind='commanddeclaration'), Premise(full_name='LLVM.CodegenFi
leType.AssemblyFile', code='def CodegenFileType.AssemblyFile : CodegenFileType := { val := 0 }', start=(23, 1), end=(23, 67), kind='commanddeclaration'), Premise(full_name='LLVM.CodegenFileType.ObjectFile', code='def
CodegenFileType.ObjectFile : CodegenFileType := { val := 1 }', start=(24, 1), end=(24, 65), kind='commanddeclaration'), Premise(full_name='LLVM.IntPredicate', code='structure IntPredicate where\n  private mk :: val :
UInt64', start=(27, 1), end=(28, 29), kind='commanddeclaration'), Premise(full_name='LLVM.IntPredicate.EQ', code='def IntPredicate.EQ : IntPredicate := { val := 32 }', start=(30, 1), end=(30, 52), kind='commanddeclara
tion'), Premise(full_name='LLVM.IntPredicate.NE', code='def IntPredicate.NE : IntPredicate := { val := IntPredicate.EQ.val + 1 }', start=(31, 1), end=(31, 73), kind='commanddeclaration'), Premise(full_name='LLVM.IntPr
edicate.UGT', code='def IntPredicate.UGT : IntPredicate := { val := IntPredicate.NE.val + 1 }', start=(32, 1), end=(32, 74), kind='commanddeclaration'), Premise(full_name='LLVM.AttributeIndex', code='structure Attribu
teIndex where\n  private mk :: val : UInt64', start=(35, 1), end=(36, 29), kind='commanddeclaration'), Premise(full_name='LLVM.AttributeIndex.AttributeReturnIndex', code='def AttributeIndex.AttributeReturnIndex : Attr
ibuteIndex := { val := 0 }', start=(38, 1), end=(38, 73), kind='commanddeclaration'), Premise(full_name='LLVM.AttributeIndex.AttributeFunctionIndex', code='def AttributeIndex.AttributeFunctionIndex : AttributeIndex :=
 { val := 18446744073709551615 }', start=(40, 1), end=(40, 94), kind='commanddeclaration'), Premise(full_name='LLVM.BasicBlock', code='structure BasicBlock (ctx : Context)  where\n  private mk :: ptr : USize', start=(
42, 1), end=(43, 28), kind='commanddeclaration'), Premise(full_name='LLVM.Builder', code='structure Builder (ctx : Context) where\n  private mk :: ptr : USize', start=(46, 1), end=(47, 28), kind='commanddeclaration'),
 Premise(full_name='LLVM.Context', code='structure Context where\n  private mk :: ptr : USize', start=(50, 1), end=(51, 28), kind='commanddeclaration'), Premise(full_name='LLVM.LLVMType', code='structure LLVMType (ctx
 : Context) where\n  private mk :: ptr : USize', start=(54, 1), end=(55, 28), kind='commanddeclaration'), Premise(full_name='LLVM.MemoryBuffer', code='structure MemoryBuffer (ctx : Context) where\n  private mk :: ptr
: USize', start=(58, 1), end=(59, 28), kind='commanddeclaration'), Premise(full_name='LLVM.Module', code='structure Module (ctx : Context) where\n  private mk :: ptr : USize', start=(62, 1), end=(63, 28), kind='comman
ddeclaration'), Premise(full_name='LLVM.PassManager', code='structure PassManager (ctx : Context) where\n  private mk :: ptr : USize', start=(66, 1), end=(67, 28), kind='commanddeclaration'), Premise(full_name='LLVM.P
assManagerBuilder', code='structure PassManagerBuilder (ctx : Context) where\n  private mk :: ptr : USize', start=(70, 1), end=(71, 28), kind='commanddeclaration'), Premise(full_name='LLVM.Target', code='structure Tar
get (ctx : Context) where\n  private mk :: ptr : USize', start=(74, 1), end=(75, 28), kind='commanddeclaration'), Premise(full_name='LLVM.TargetMachine', code='structure TargetMachine (ctx : Context) where\n  private
mk :: ptr : USize', start=(78, 1), end=(79, 28), kind='commanddeclaration'), Premise(full_name='LLVM.Value', code='structure Value (ctx : Context) where\n  private mk :: ptr : USize', start=(82, 1), end=(83, 28), kind
='commanddeclaration'), Premise(full_name='LLVM.Value.isNull', code='def Value.isNull (v : Value ctx) : Bool := v.ptr == 0', start=(86, 1), end=(87, 54), kind='commanddeclaration'), Premise(full_name='LLVM.Value.getNa
me', code='@[extern "lean_llvm_get_value_name2"]\nopaque Value.getName {ctx : Context} (value : Value ctx) : BaseIO String', start=(89, 1), end=(90, 73), kind='commanddeclaration'), Premise(full_name='LLVM.Attribute',
 code='structure Attribute (ctx : Context) where\n  private mk :: ptr : USize', start=(92, 1), end=(93, 28), kind='commanddeclaration'), Premise(full_name='LLVM.llvmInitializeTargetInfo', code='@[extern "lean_llvm_ini
tialize_target_info"]\nopaque llvmInitializeTargetInfo : BaseIO (Unit)', start=(96, 1), end=(97, 48), kind='commanddeclaration'), Premise(full_name='LLVM.createContext', code='@[extern "lean_llvm_create_context"]\nopa
que createContext : BaseIO (Context)', start=(99, 1), end=(100, 40), kind='commanddeclaration'), Premise(full_name='LLVM.createModule', code='@[extern "lean_llvm_create_module"]\nopaque createModule (ctx : Context) (n
ame : @&String) : BaseIO (Module ctx)', start=(102, 1), end=(103, 76), kind='commanddeclaration'), Premise(full_name='LLVM.moduleToString', code='@[extern "lean_llvm_module_to_string"]\nopaque moduleToString (m : Modu
le ctx) : BaseIO String', start=(105, 1), end=(106, 55), kind='commanddeclaration'), Premise(full_name='LLVM.writeBitcodeToFile', code='@[extern "lean_llvm_write_bitcode_to_file"]\nopaque writeBitcodeToFile (m : Modul
e ctx) (path : @&String) : BaseIO Unit', start=(108, 1), end=(109, 75), kind='commanddeclaration'), Premise(full_name='LLVM.addFunction', code='@[extern "lean_llvm_add_function"]\nopaque addFunction (m : Module ctx) (
name : @&String) (type : LLVMType ctx) : BaseIO (Value ctx)', start=(111, 1), end=(112, 97), kind='commanddeclaration'), Premise(full_name='LLVM.getFirstFunction', code='@[extern "lean_llvm_get_first_function"]\nopaqu
e getFirstFunction (m : Module ctx) : BaseIO (Value ctx)', start=(114, 1), end=(115, 62), kind='commanddeclaration'), Premise(full_name='LLVM.getNextFunction', code='@[extern "lean_llvm_get_next_function"]\nopaque get
NextFunction (glbl : Value ctx) : BaseIO (Value ctx)', start=(117, 1), end=(118, 63), kind='commanddeclaration'), Premise(full_name='LLVM.getNamedFunction', code='@[extern "lean_llvm_get_named_function"]\nopaque getNa
medFunction (m : Module ctx) (name : @&String) : BaseIO (Option (Value ctx))', start=(120, 1), end=(121, 89), kind='commanddeclaration'), Premise(full_name='LLVM.addGlobal', code='@[extern "lean_llvm_add_global"]\nopa
que addGlobal (m : Module ctx) (name : @&String) (type : LLVMType ctx) : BaseIO (Value ctx)', start=(123, 1), end=(124, 95), kind='commanddeclaration'), Premise(full_name='LLVM.getNamedGlobal', code='@[extern "lean_ll
vm_get_named_global"]\nopaque getNamedGlobal (m : Module ctx) (name : @&String) : BaseIO (Option (Value ctx))', start=(126, 1), end=(127, 87), kind='commanddeclaration'), Premise(full_name='LLVM.getFirstGlobal', code=
'@[extern "lean_llvm_get_first_global"]\nopaque getFirstGlobal (m : Module ctx) : BaseIO (Value ctx)', start=(129, 1), end=(130, 60), kind='commanddeclaration'), Premise(full_name='LLVM.getNextGlobal', code='@[extern
"lean_llvm_get_next_global"]\nopaque getNextGlobal (glbl : Value ctx) : BaseIO (Value ctx)', start=(132, 1), end=(133, 61), kind='commanddeclaration'), Premise(full_name='LLVM.buildGlobalString', code='@[extern "lean_
llvm_build_global_string"]\nopaque buildGlobalString (builder : Builder ctx) (value : @&String) (name : @&String := "") : BaseIO (Value ctx)', start=(135, 1), end=(136, 113), kind='commanddeclaration'), Premise(full_n
ame='LLVM.isDeclaration', code='@[extern "llvm_is_declaration"]\nopaque isDeclaration (global : Value ctx) : BaseIO Bool', start=(138, 1), end=(139, 56), kind='commanddeclaration'), Premise(full_name='LLVM.setInitiali
zer', code='@[extern "lean_llvm_set_initializer"]\nopaque setInitializer (glbl : Value ctx) (val : Value ctx) : BaseIO Unit', start=(141, 1), end=(142, 73), kind='commanddeclaration'), Premise(full_name='LLVM.function
Type', code='@[extern "lean_llvm_function_type"]\nopaque functionType (retty : LLVMType ctx) (args : @&Array (LLVMType ctx)) (isVarArg : Bool := false) : BaseIO (LLVMType ctx)', start=(144, 1), end=(145, 126), kind='c
ommanddeclaration'), Premise(full_name='LLVM.voidType', code='@[extern "lean_llvm_void_type_in_context"]\nopaque voidType (ctx : Context) : BaseIO (LLVMType ctx)', start=(147, 1), end=(148, 56), kind='commanddeclarati
on'), Premise(full_name='LLVM.intTypeInContext', code='@[extern "lean_llvm_int_type_in_context"]\nopaque intTypeInContext (ctx : Context) (width : UInt64) : BaseIO (LLVMType ctx)', start=(150, 1), end=(151, 81), kind=
'commanddeclaration'), Premise(full_name='LLVM.opaquePointerTypeInContext', code='@[extern "lean_llvm_opaque_pointer_type_in_context"]\nopaque opaquePointerTypeInContext (ctx : Context) (addrspace: UInt64 := 0) : Base
IO (LLVMType ctx)', start=(153, 1), end=(154, 99), kind='commanddeclaration'), Premise(full_name='LLVM.floatTypeInContext', code='@[extern "lean_llvm_float_type_in_context"]\nopaque floatTypeInContext (ctx : Context)
: BaseIO (LLVMType ctx)', start=(156, 1), end=(157, 66), kind='commanddeclaration'), Premise(full_name='LLVM.doubleTypeInContext', code='@[extern "lean_llvm_double_type_in_context"]\nopaque doubleTypeInContext (ctx :
Context) : BaseIO (LLVMType ctx)', start=(159, 1), end=(160, 67), kind='commanddeclaration'), Premise(full_name='LLVM.pointerType', code='@[extern "lean_llvm_pointer_type"]\nopaque pointerType (elemty : LLVMType ctx)
: BaseIO (LLVMType ctx)', start=(162, 1), end=(163, 67), kind='commanddeclaration'), Premise(full_name='LLVM.arrayType', code='@[extern "lean_llvm_array_type"]\nopaque arrayType (elemty : LLVMType ctx) (nelem : UInt64
) : BaseIO (LLVMType ctx)', start=(165, 1), end=(166, 82), kind='commanddeclaration'), Premise(full_name='LLVM.constArray', code='@[extern "lean_llvm_const_array"]\nopaque constArray (elemty : LLVMType ctx) (vals : @&
Array (Value ctx)) : BaseIO (LLVMType ctx)', start=(168, 1), end=(169, 95), kind='commanddeclaration'), Premise(full_name='LLVM.constString', code='@[extern "lean_llvm_const_string"]\nopaque constString (ctx : Context
) (str : @&String) : BaseIO (Value ctx)', start=(172, 1), end=(173, 73), kind='commanddeclaration'), Premise(full_name='LLVM.constPointerNull', code='@[extern "lean_llvm_const_pointer_null"]\nopaque constPointerNull (
elemty : LLVMType ctx) : BaseIO (Value ctx)', start=(175, 1), end=(176, 69), kind='commanddeclaration'), Premise(full_name='LLVM.getUndef', code='@[extern "lean_llvm_get_undef"]\nopaque getUndef (elemty : LLVMType ctx
) : BaseIO (Value ctx)', start=(178, 1), end=(179, 61), kind='commanddeclaration'), Premise(full_name='LLVM.createBuilderInContext', code='@[extern "lean_llvm_create_builder_in_context"]\nopaque createBuilderInContext
 (ctx : Context) : BaseIO (Builder ctx)', start=(181, 1), end=(182, 69), kind='commanddeclaration'), Premise(full_name='LLVM.appendBasicBlockInContext', code='@[extern "lean_llvm_append_basic_block_in_context"]\nopaqu
e appendBasicBlockInContext (ctx : Context) (fn :  Value ctx) (name :  @&String) : BaseIO (BasicBlock ctx)', start=(184, 1), end=(185, 112), kind='commanddeclaration'), Premise(full_name='LLVM.countBasicBlocks', code=
'@[extern "lean_llvm_count_basic_blocks"]\nopaque countBasicBlocks (fn : Value ctx) : BaseIO UInt64', start=(187, 1), end=(188, 57), kind='commanddeclaration'), Premise(full_name='LLVM.getEntryBasicBlock', code='@[ext
ern "lean_llvm_get_entry_basic_block"]\nopaque getEntryBasicBlock (fn : Value ctx) : BaseIO (BasicBlock ctx)', start=(190, 1), end=(191, 69), kind='commanddeclaration'), Premise(full_name='LLVM.getFirstInstruction', c
ode='@[extern "lean_llvm_get_first_instruction"]\nopaque getFirstInstruction (bb : BasicBlock ctx) : BaseIO (Option (Value ctx))', start=(193, 1), end=(194, 79), kind='commanddeclaration'), Premise(full_name='LLVM.pos
itionBuilderBefore', code='@[extern "lean_llvm_position_builder_before"]\nopaque positionBuilderBefore (builder : Builder ctx) (instr : Value ctx) : BaseIO Unit', start=(196, 1), end=(197, 87), kind='commanddeclaratio
n'), Premise(full_name='LLVM.positionBuilderAtEnd', code='@[extern "lean_llvm_position_builder_at_end"]\nopaque positionBuilderAtEnd (builder : Builder ctx) (bb :  BasicBlock ctx) : BaseIO Unit', start=(199, 1), end=(
200, 89), kind='commanddeclaration'), Premise(full_name='LLVM.buildCall2', code='@[extern "lean_llvm_build_call2"]\nopaque buildCall2 (builder : Builder ctx) (ty: LLVMType ctx) (fn : Value ctx) (args : @&Array (Value
ctx)) (name :  @&String := "") : BaseIO (Value ctx)', start=(202, 1), end=(203, 153), kind='commanddeclaration'), Premise(full_name='LLVM.setTailCall', code='@[extern "lean_llvm_set_tail_call"]\nopaque setTailCall (fn
 : Value ctx) (istail : Bool) : BaseIO Unit', start=(205, 1), end=(206, 66), kind='commanddeclaration'), Premise(full_name='LLVM.buildCondBr', code='@[extern "lean_llvm_build_cond_br"]\nopaque buildCondBr (builder : B
uilder ctx) (if_ : Value ctx) (thenbb : BasicBlock ctx) (elsebb : BasicBlock ctx) : BaseIO (Value ctx)', start=(208, 1), end=(209, 134), kind='commanddeclaration'), Premise(full_name='LLVM.buildBr', code='@[extern "le
an_llvm_build_br"]\nopaque buildBr (builder : Builder ctx) (bb : BasicBlock ctx) : BaseIO (Value ctx)', start=(211, 1), end=(212, 82), kind='commanddeclaration'), Premise(full_name='LLVM.buildAlloca', code='@[extern "
lean_llvm_build_alloca"]\nopaque buildAlloca (builder : Builder ctx) (ty : LLVMType ctx) (name : @&String := "") : BaseIO (Value ctx)', start=(214, 1), end=(215, 108), kind='commanddeclaration'), Premise(full_name='LL
VM.buildLoad2', code='@[extern "lean_llvm_build_load2"]\nopaque buildLoad2 (builder : Builder ctx) (ty: LLVMType ctx) (val : Value ctx) (name : @&String := "") : BaseIO (Value ctx)', start=(217, 1), end=(218, 124), ki
nd='commanddeclaration'), Premise(full_name='LLVM.buildStore', code='@[extern "lean_llvm_build_store"]\nopaque buildStore (builder : Builder ctx) (val : Value ctx) (store_loc_ptr : Value ctx) : BaseIO Unit', start=(22
0, 1), end=(221, 102), kind='commanddeclaration'), Premise(full_name='LLVM.buildRet', code='@[extern "lean_llvm_build_ret"]\nopaque buildRet (builder : Builder ctx) (val : Value ctx) : BaseIO (Value ctx)', start=(223,
 1), end=(224, 79), kind='commanddeclaration'), Premise(full_name='LLVM.buildUnreachable', code='@[extern "lean_llvm_build_unreachable"]\nopaque buildUnreachable (builder : Builder ctx) : BaseIO (Value ctx)', start=(2
26, 1), end=(227, 69), kind='commanddeclaration'), Premise(full_name='LLVM.buildGEP2', code='@[extern "lean_llvm_build_gep2"]\nopaque buildGEP2 (builder : Builder ctx) (ty: LLVMType ctx) (base : Value ctx) (ixs : @&Ar
ray (Value ctx)) (name : @&String := "") : BaseIO (Value ctx)', start=(229, 1), end=(230, 152), kind='commanddeclaration'), Premise(full_name='LLVM.buildInBoundsGEP2', code='@[extern "lean_llvm_build_inbounds_gep2"]\n
opaque buildInBoundsGEP2 (builder : Builder ctx) (ty: LLVMType ctx) (base : Value ctx) (ixs : @&Array (Value ctx)) (name : @&String := "") : BaseIO (Value ctx)', start=(232, 1), end=(233, 160), kind='commanddeclaratio
n'), Premise(full_name='LLVM.buildSext', code='@[extern "lean_llvm_build_sext"]\nopaque buildSext (builder : Builder ctx) (val : Value ctx) (destTy : LLVMType ctx) (name : @&String := "") : BaseIO (Value ctx)', start=
(235, 1), end=(236, 128), kind='commanddeclaration'), Premise(full_name='LLVM.buildZext', code='@[extern "lean_llvm_build_zext"]\nopaque buildZext (builder : Builder ctx) (val : Value ctx) (destTy : LLVMType ctx) (nam
e : @&String := "") : BaseIO (Value ctx)', start=(238, 1), end=(239, 128), kind='commanddeclaration'), Premise(full_name='LLVM.buildSextOrTrunc', code='@[extern "lean_llvm_build_sext_or_trunc"]\nopaque buildSextOrTrun
c (builder : Builder ctx) (val : Value ctx) (destTy : LLVMType ctx) (name : @&String := "") : BaseIO (Value ctx)', start=(241, 1), end=(242, 135), kind='commanddeclaration'), Premise(full_name='LLVM.buildSwitch', code
='@[extern "lean_llvm_build_switch"]\nopaque buildSwitch (builder : Builder ctx) (val : Value ctx) (elseBB : BasicBlock ctx) (numCasesHint : UInt64) : BaseIO (Value ctx)', start=(244, 1), end=(245, 132), kind='command
declaration'), Premise(full_name='LLVM.buildPtrToInt', code='@[extern "lean_llvm_build_ptr_to_int"]\nopaque buildPtrToInt (builder : Builder ctx) (ptr : Value ctx) (destTy : LLVMType ctx) (name : @&String := "") : Bas
eIO (Value ctx)', start=(247, 1), end=(248, 132), kind='commanddeclaration'), Premise(full_name='LLVM.buildMul', code='@[extern "lean_llvm_build_mul"]\nopaque buildMul (builder : Builder ctx) (x y : Value ctx) (name :
 @&String := "") : BaseIO (Value ctx)', start=(250, 1), end=(251, 103), kind='commanddeclaration'), Premise(full_name='LLVM.buildAdd', code='@[extern "lean_llvm_build_add"]\nopaque buildAdd (builder : Builder ctx) (x
y : Value ctx) (name : @&String := "") : BaseIO (Value ctx)', start=(253, 1), end=(254, 103), kind='commanddeclaration'), Premise(full_name='LLVM.buildSub', code='@[extern "lean_llvm_build_sub"]\nopaque buildSub (buil
der : Builder ctx) (x y : Value ctx) (name : @&String := "") : BaseIO (Value ctx)', start=(256, 1), end=(257, 103), kind='commanddeclaration'), Premise(full_name='LLVM.buildNot', code='@[extern "lean_llvm_build_not"]\
nopaque buildNot (builder : Builder ctx) (x : Value ctx) (name : @&String := "") : BaseIO (Value ctx)', start=(259, 1), end=(260, 101), kind='commanddeclaration'), Premise(full_name='LLVM.buildICmp', code='@[extern "l
ean_llvm_build_icmp"]\nopaque buildICmp (builder : Builder ctx) (predicate : IntPredicate) (x y : Value ctx) (name : @&String := "") : BaseIO (Value ctx)', start=(262, 1), end=(263, 131), kind='commanddeclaration'), P
remise(full_name='LLVM.addCase', code='@[extern "lean_llvm_add_case"]\nopaque addCase (switch onVal : Value ctx) (destBB : BasicBlock ctx) : BaseIO Unit', start=(265, 1), end=(266, 82), kind='commanddeclaration'), Pre
mise(full_name='LLVM.getInsertBlock', code='@[extern "lean_llvm_get_insert_block"]\nopaque getInsertBlock (builder : Builder ctx) : BaseIO (BasicBlock ctx)', start=(268, 1), end=(269, 72), kind='commanddeclaration'),
Premise(full_name='LLVM.clearInsertionPosition', code='@[extern "lean_llvm_clear_insertion_position"]\nopaque clearInsertionPosition (builder : Builder ctx) : BaseIO Unit', start=(271, 1), end=(272, 68), kind='command
declaration'), Premise(full_name='LLVM.getBasicBlockParent', code='@[extern "lean_llvm_get_basic_block_parent"]\nopaque getBasicBlockParent (bb : BasicBlock ctx) : BaseIO (Value ctx)', start=(274, 1), end=(275, 70), k
ind='commanddeclaration'), Premise(full_name='LLVM.typeOf', code='@[extern "lean_llvm_type_of"]\nopaque typeOf (val : Value ctx) : BaseIO (LLVMType ctx)', start=(277, 1), end=(278, 56), kind='commanddeclaration'), Pre
mise(full_name='LLVM.constInt', code='@[extern "lean_llvm_const_int"]\nopaque constInt (intty : LLVMType ctx) (value : UInt64) (signExtend : @Bool := false) : BaseIO (Value ctx)', start=(280, 1), end=(281, 107), kind=
'commanddeclaration'), Premise(full_name='LLVM.printModuletoString', code='@[extern "lean_llvm_print_module_to_string"]\nopaque printModuletoString (mod : Module ctx) : BaseIO (String)', start=(283, 1), end=(284, 64),
 kind='commanddeclaration'), Premise(full_name='LLVM.printModuletoFile', code='@[extern "lean_llvm_print_module_to_file"]\nopaque printModuletoFile (mod : Module ctx) (file : @&String) : BaseIO Unit', start=(286, 1),
end=(287, 76), kind='commanddeclaration'), Premise(full_name='LLVM.countParams', code='@[extern "llvm_count_params"]\nopaque countParams (fn : Value ctx) : BaseIO UInt64', start=(289, 1), end=(290, 52), kind='commandd
eclaration'), Premise(full_name='LLVM.getParam', code='@[extern "llvm_get_param"]\nopaque getParam (fn : Value ctx) (ix : UInt64) : BaseIO (Value ctx)', start=(292, 1), end=(293, 68), kind='commanddeclaration'), Premi
se(full_name='LLVM.createMemoryBufferWithContentsOfFile', code='@[extern "lean_llvm_create_memory_buffer_with_contents_of_file"]\nopaque createMemoryBufferWithContentsOfFile (path : @&String) : BaseIO (MemoryBuffer ct
x)', start=(295, 1), end=(296, 90), kind='commanddeclaration'), Premise(full_name='LLVM.parseBitcode', code='@[extern "lean_llvm_parse_bitcode"]\nopaque parseBitcode (ctx : Context) (membuf : MemoryBuffer ctx) : BaseI
O (Module ctx)', start=(298, 1), end=(299, 86), kind='commanddeclaration'), Premise(full_name='LLVM.linkModules', code='@[extern "lean_llvm_link_modules"]\nopaque linkModules (dest : Module ctx) (src : Module ctx) : B
aseIO Unit', start=(301, 1), end=(302, 72), kind='commanddeclaration'), Premise(full_name='LLVM.getDefaultTargetTriple', code='@[extern "lean_llvm_get_default_target_triple"]\nopaque getDefaultTargetTriple : BaseIO St
ring', start=(304, 1), end=(305, 46), kind='commanddeclaration'), Premise(full_name='LLVM.getTargetFromTriple', code='@[extern "lean_llvm_get_target_from_triple"]\nopaque getTargetFromTriple (triple : @&String) : Base
IO (Target ctx)', start=(307, 1), end=(308, 69), kind='commanddeclaration'), Premise(full_name='LLVM.createTargetMachine', code='@[extern "lean_llvm_create_target_machine"]\nopaque createTargetMachine (target : Target
 ctx) (tripleStr : @&String) (cpu : @&String) (features : @&String) : BaseIO (TargetMachine ctx)', start=(310, 1), end=(311, 140), kind='commanddeclaration'), Premise(full_name='LLVM.targetMachineEmitToFile', code='@[
extern "lean_llvm_target_machine_emit_to_file"]\nopaque targetMachineEmitToFile (targetMachine : TargetMachine ctx) (module : Module ctx) (filepath : @&String) (codegenType : LLVM.CodegenFileType) : BaseIO Unit', star
t=(313, 1), end=(314, 162), kind='commanddeclaration'), Premise(full_name='LLVM.createPassManager', code='@[extern "lean_llvm_create_pass_manager"]\nopaque createPassManager : BaseIO (PassManager ctx)', start=(316, 1)
, end=(317, 52), kind='commanddeclaration'), Premise(full_name='LLVM.disposePassManager', code='@[extern "lean_llvm_dispose_pass_manager"]\nopaque disposePassManager (pm : PassManager ctx) : BaseIO Unit', start=(319,
1), end=(320, 63), kind='commanddeclaration'), Premise(full_name='LLVM.runPassManager', code='@[extern "lean_llvm_run_pass_manager"]\nopaque runPassManager (pm : PassManager ctx) (mod : Module ctx): BaseIO Unit', star
t=(322, 1), end=(323, 77), kind='commanddeclaration'), Premise(full_name='LLVM.createPassManagerBuilder', code='@[extern "lean_llvm_create_pass_manager_builder"]\nopaque createPassManagerBuilder : BaseIO (PassManagerB
uilder ctx)', start=(325, 1), end=(326, 66), kind='commanddeclaration'), Premise(full_name='LLVM.disposePassManagerBuilder', code='@[extern "lean_llvm_dispose_pass_manager_builder"]\nopaque disposePassManagerBuilder (
pmb : PassManagerBuilder ctx) : BaseIO Unit', start=(328, 1), end=(329, 78), kind='commanddeclaration'), Premise(full_name='LLVM.PassManagerBuilder.setOptLevel', code='@[extern "lean_llvm_pass_manager_builder_set_opt_
level"]\nopaque PassManagerBuilder.setOptLevel (pmb : PassManagerBuilder ctx) (optLevel : unsigned) : BaseIO Unit', start=(331, 1), end=(332, 105), kind='commanddeclaration'), Premise(full_name='LLVM.PassManagerBuilde
r.populateModulePassManager', code='@[extern "lean_llvm_pass_manager_builder_populate_module_pass_manager"]\nopaque PassManagerBuilder.populateModulePassManager (pmb : PassManagerBuilder ctx) (pm : PassManager ctx): B
aseIO Unit', start=(334, 1), end=(335, 119), kind='commanddeclaration'), Premise(full_name='LLVM.disposeTargetMachine', code='@[extern "lean_llvm_dispose_target_machine"]\nopaque disposeTargetMachine (tm : TargetMachi
ne ctx) : BaseIO Unit', start=(337, 1), end=(338, 67), kind='commanddeclaration'), Premise(full_name='LLVM.disposeModule', code='@[extern "lean_llvm_dispose_module"]\nopaque disposeModule (m : Module ctx) : BaseIO Uni
t', start=(340, 1), end=(341, 52), kind='commanddeclaration'), Premise(full_name='LLVM.verifyModule', code='@[extern "lean_llvm_verify_module"]\nopaque verifyModule (m : Module ctx) : BaseIO (Option String)', start=(3
43, 1), end=(344, 62), kind='commanddeclaration'), Premise(full_name='LLVM.createStringAttribute', code='@[extern "lean_llvm_create_string_attribute"]\nopaque createStringAttribute (key : String) (value : String) : Ba
seIO (Attribute ctx)', start=(346, 1), end=(347, 86), kind='commanddeclaration'), Premise(full_name='LLVM.addAttributeAtIndex', code='@[extern "lean_llvm_add_attribute_at_index"]\nopaque addAttributeAtIndex (fn : Valu
e ctx) (idx: AttributeIndex) (attr: Attribute ctx) : BaseIO Unit', start=(349, 1), end=(350, 102), kind='commanddeclaration'), Premise(full_name='LLVM.Visibility', code='structure Visibility where\n  private mk :: val
 : UInt64', start=(354, 1), end=(355, 29), kind='commanddeclaration'), Premise(full_name='LLVM.Visibility.default', code='def Visibility.default   : Visibility := { val := 0 }', start=(357, 1), end=(357, 54), kind='co
mmanddeclaration'), Premise(full_name='LLVM.Visibility.hidden', code='def Visibility.hidden    : Visibility := { val := 1 }', start=(358, 1), end=(358, 54), kind='commanddeclaration'), Premise(full_name='LLVM.Visibili
ty.protected', code='def Visibility.protected : Visibility := { val := 2 }', start=(359, 1), end=(359, 54), kind='commanddeclaration'), Premise(full_name='LLVM.setVisibility', code='@[extern "lean_llvm_set_visibility"
]\nopaque setVisibility {ctx : Context} (value : Value ctx) (visibility : Visibility) : BaseIO Unit', start=(361, 1), end=(362, 97), kind='commanddeclaration'), Premise(full_name='LLVM.DLLStorageClass', code='structur
e DLLStorageClass where\n  private mk :: val : UInt64', start=(365, 1), end=(366, 29), kind='commanddeclaration'), Premise(full_name='LLVM.DLLStorageClass.default', code='def DLLStorageClass.default : DLLStorageClass
:= { val := 0 }', start=(368, 1), end=(368, 62), kind='commanddeclaration'), Premise(full_name='LLVM.DLLStorageClass.import', code='def DLLStorageClass.import  : DLLStorageClass := { val := 1 }', start=(369, 1), end=(
369, 62), kind='commanddeclaration'), Premise(full_name='LLVM.DLLStorageClass.export', code='def DLLStorageClass.export  : DLLStorageClass := { val := 2 }', start=(370, 1), end=(370, 62), kind='commanddeclaration'), P
remise(full_name='LLVM.setDLLStorageClass', code='@[extern "lean_llvm_set_dll_storage_class"]\nopaque setDLLStorageClass {ctx : Context} (value : Value ctx) (dllStorageClass : DLLStorageClass) : BaseIO Unit', start=(3
72, 1), end=(373, 112), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage', code='structure Linkage where\n  private mk :: val : UInt64', start=(376, 1), end=(377, 29), kind='commanddeclaration'), Premise(fu
ll_name='LLVM.Linkage.external', code='def Linkage.external : Linkage := { val := 0 }', start=(379, 1), end=(380, 47), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.availableExternally', code='def Linkag
e.availableExternally : Linkage := { val := 1 }', start=(381, 1), end=(381, 58), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.linkOnceAny', code='def Linkage.linkOnceAny : Linkage := { val := 2 }', star
t=(382, 1), end=(383, 50), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.linkOnceODR', code='def Linkage.linkOnceODR : Linkage := { val := 3 }', start=(384, 1), end=(385, 50), kind='commanddeclaration'),
 Premise(full_name='LLVM.Linkage.linkOnceODRAutoHide', code='def Linkage.linkOnceODRAutoHide : Linkage := { val := 4 }', start=(386, 1), end=(387, 58), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.weakA
ny', code='def Linkage.weakAny : Linkage := { val := 5 }', start=(388, 1), end=(389, 46), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.weakODR', code='def Linkage.weakODR : Linkage := { val := 6 }', sta
rt=(390, 1), end=(391, 46), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.appending', code='def Linkage.appending : Linkage := { val := 7 }', start=(392, 1), end=(393, 48), kind='commanddeclaration'), Pr
emise(full_name='LLVM.Linkage.internal', code='def Linkage.internal : Linkage := { val := 8 }', start=(394, 1), end=(395, 47), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.private', code='def Linkage.pr
ivate : Linkage := { val := 9 }', start=(396, 1), end=(397, 46), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.dllImport', code='def Linkage.dllImport : Linkage := { val := 10 }', start=(398, 1), end=(39
9, 49), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.dllExport', code='def Linkage.dllExport : Linkage := { val := 11 }', start=(400, 1), end=(401, 49), kind='commanddeclaration'), Premise(full_name='LL
VM.Linkage.externalWeak', code='def Linkage.externalWeak : Linkage := { val := 12 }', start=(402, 1), end=(403, 52), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.ghost', code='def Linkage.ghost : Linkag
e := { val := 13 }', start=(404, 1), end=(405, 45), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.common', code='def Linkage.common : Linkage := { val := 14 }', start=(406, 1), end=(407, 46), kind='comma
nddeclaration'), Premise(full_name='LLVM.Linkage.linkerPrivate', code='def Linkage.linkerPrivate : Linkage := { val := 15 }', start=(408, 1), end=(409, 53), kind='commanddeclaration'), Premise(full_name='LLVM.Linkage.
linkerPrivateWeak', code='def Linkage.linkerPrivateWeak : Linkage := { val := 16 }', start=(410, 1), end=(411, 57), kind='commanddeclaration'), Premise(full_name='LLVM.setLinkage', code='@[extern "lean_llvm_set_linkag
e"]\nopaque setLinkage {ctx : Context} (value : Value ctx) (linkage : Linkage) : BaseIO Unit', start=(413, 1), end=(414, 88), kind='commanddeclaration'), Premise(full_name='LLVM.i1Type', code='def i1Type (ctx : LLVM.C
ontext) : BaseIO (LLVM.LLVMType ctx) :=\n  LLVM.intTypeInContext ctx 1', start=(417, 1), end=(418, 30), kind='commanddeclaration'), Premise(full_name='LLVM.i8Type', code='def i8Type (ctx : LLVM.Context) : BaseIO (LLVM
.LLVMType ctx) :=\n  LLVM.intTypeInContext ctx 8', start=(420, 1), end=(421, 30), kind='commanddeclaration'), Premise(full_name='LLVM.i16Type', code='def i16Type (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n
 LLVM.intTypeInContext ctx 16', start=(423, 1), end=(424, 31), kind='commanddeclaration'), Premise(full_name='LLVM.i32Type', code='def i32Type (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  LLVM.intTypeInCont
ext ctx 32', start=(426, 1), end=(427, 31), kind='commanddeclaration'), Premise(full_name='LLVM.i64Type', code='def i64Type (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  LLVM.intTypeInContext ctx 64', start=
(429, 1), end=(430, 31), kind='commanddeclaration'), Premise(full_name='LLVM.voidPtrType', code='def voidPtrType (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  do LLVM.pointerType (← LLVM.intTypeInContext ctx
 8)', start=(432, 1), end=(433, 54), kind='commanddeclaration'), Premise(full_name='LLVM.i8PtrType', code='def i8PtrType (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  voidPtrType ctx', start=(435, 1), end=(4
36, 18), kind='commanddeclaration'), Premise(full_name='LLVM.constTrue', code='def constTrue (ctx : Context) : BaseIO (Value ctx) :=\n  do constInt (← i1Type ctx) 1 (signExtend := false)', start=(438, 1), end=(439, 53
), kind='commanddeclaration'), Premise(full_name='LLVM.constFalse', code='def constFalse (ctx : Context) : BaseIO (Value ctx) :=\n  do constInt (← i1Type ctx) 0 (signExtend := false)', start=(441, 1), end=(442, 53), k
ind='commanddeclaration'), Premise(full_name="LLVM.constInt'", code="def constInt' (ctx : Context) (width : UInt64) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n do constInt (← LLVM.intTypeIn
Context ctx width) value signExtend", start=(444, 1), end=(445, 66), kind='commanddeclaration'), Premise(full_name='LLVM.constInt1', code="def constInt1 (ctx : Context) (value : UInt64) (signExtend : Bool := false) :
BaseIO (Value ctx) :=\n  constInt' ctx 1 value signExtend", start=(447, 1), end=(448, 35), kind='commanddeclaration'), Premise(full_name='LLVM.constInt8', code="def constInt8 (ctx : Context) (value : UInt64) (signExte
nd : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 8 value signExtend", start=(450, 1), end=(451, 35), kind='commanddeclaration'), Premise(full_name='LLVM.constInt32', code="def constInt32 (ctx : Context) (v
alue : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 32 value signExtend", start=(453, 1), end=(454, 36), kind='commanddeclaration'), Premise(full_name='LLVM.constInt64', code="def cons
tInt64 (ctx : Context) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 64 value signExtend", start=(456, 1), end=(457, 36), kind='commanddeclaration'), Premise(full_name='LLVM.co
nstIntSizeT', code="def constIntSizeT (ctx : Context) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 64 value signExtend", start=(459, 1), end=(461, 36), kind='commanddeclaratio
n'), Premise(full_name='LLVM.constIntUnsigned', code="def constIntUnsigned (ctx : Context) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 32 value signExtend", start=(463, 1), e
nd=(465, 36), kind='commanddeclaration')]), PremiseFile(path=PosixPath('Debate/Correct.lean'), imports=['.lake/packages/lean4/src/lean/Init.lean', 'Debate/Cost.lean', 'Debate/Details.lean', 'Debate/Protocol.lean'], pr
emises=[Premise(full_name='completeness', code="theorem completeness (o : Oracle) (L : o.lipschitz t k) (eve : Bob)\n    {w d : ℝ} (p : Params w d k t) (m : w ≤ (o.final t).prob true) :\n    d ≤ ((debate (alice p.c p.
q) eve (vera p.c p.s p.v) t).prob' o).prob true", start=(16, 1), end=(20, 29), kind='commanddeclaration'), Premise(full_name='soundness', code="theorem soundness (o : Oracle) (L : o.lipschitz t k) (eve : Alice)\n    {
w d : ℝ} (p : Params w d k t) (m : w ≤ (o.final t).prob false) :\n    d ≤ ((debate eve (bob p.s p.b p.q) (vera p.c p.s p.v) t).prob' o).prob false", start=(22, 1), end=(26, 26), kind='commanddeclaration'), Premise(ful
l_name='correctness', code='theorem correctness (k : ℝ) (k0 : 0 < k) (t : ℕ) :\n    let p := Params.defaults k t k0\n    Correct (3/5) k t (alice p.c p.q) (bob p.s p.b p.q) (vera p.c p.s p.v) where', start=(28, 1), en
d=(34, 60), kind='commanddeclaration')]), PremiseFile(path=PosixPath('Prob/Pmf.lean'), imports=['.lake/packages/mathlib/Mathlib/Probability/ProbabilityMassFunction/Monad.lean', '.lake/packages/mathlib/Mathlib/Probabil
ity/ProbabilityMassFunction/Integrals.lean', '.lake/packages/mathlib/Mathlib/MeasureTheory/Integral/IntegrableOn.lean', '.lake/packages/lean4/src/lean/Init.lean', 'Misc/Finset.lean', 'Prob/Basics.lean', '.lake/package
s/mathlib/Mathlib/Probability/ProbabilityMassFunction/Basic.lean'], premises=[Premise(full_name='Prob.toPmf', code='def Prob.toPmf (f : Prob α) : PMF α where\n  val x := .ofReal (f.prob x)\n  property := by\n    have
e : f.supp.sum (fun x => ENNReal.ofReal (f.prob x)) = 1 := by\n      have t := f.total; simp only [Finsupp.sum] at t\n      simp only [Finset.sum_ofReal (fun _ ↦ prob_nonneg _), supp, t, ENNReal.ofReal_one]\n    rw [←
e]; apply Finset.hasSum_sum;\n    intro x m; simp only [mem_iff, not_not] at m; simp only [m, ENNReal.ofReal_zero]', start=(19, 1), end=(27, 85), kind='commanddeclaration'), Premise(full_name='PMF.toProb', code="def P
MF.toProb (f : PMF α) (finite : f.support.Finite) : Prob α where\n  prob := by\n    apply Finsupp.ofSupportFinite (fun x ↦ ENNReal.toReal (f x))\n    rcases finite.exists_finset with ⟨s,h⟩\n    apply Set.Finite.ofFins
et s\n    intro x\n    simp only [h, PMF.mem_support_iff, ne_eq, Function.mem_support, ENNReal.toReal_eq_zero_iff,\n      PMF.apply_ne_top, or_false]\n  prob_nonneg := by intro x; simp only [Finsupp.ofSupportFinite_co
e]; apply ENNReal.toReal_nonneg\n  total := by\n    rcases finite.exists_finset with ⟨s,h⟩\n    apply eq_of_forall_dist_le; intro e ep\n    set e' : ENNReal := .ofReal e\n    have e0' : e' ≠ 0 := (ENNReal.ofReal_pos.m
pr ep).ne'\n    have m : 1 ∈ Ioo (1-e' : ENNReal) (1+e') := by\n      simp only [ge_iff_le, gt_iff_lt, not_lt, mem_Ioo]; constructor\n      · apply ENNReal.sub_lt_self; norm_num; norm_num; exact e0'\n      · apply ENN
Real.lt_add_right; norm_num; exact e0'\n    rcases tendsto_atTop_nhds.mp f.property (Ioo (1-e') (1+e')) m isOpen_Ioo with ⟨t,total⟩\n    · specialize total (s ∪ t) (Finset.subset_union_right _ _)\n      rw [←Finset.su
m_subset (Finset.subset_union_left _ _)] at total\n      · simp only [Finsupp.sum, Finsupp.ofSupportFinite_coe]\n        rw [@Finset.sum_subset _ _ _ s]\n        · simp only [ge_iff_le, gt_iff_lt, not_lt, mem_Ioo] at
total\n          simp only [Finset.sum_toReal (λ _ ↦ PMF.apply_ne_top _ _), Real.dist_eq, abs_le,\n            le_sub_iff_add_le, sub_le_iff_le_add, add_comm _ (1:ℝ)]\n          constructor\n          · rw [←ENNReal.o
fReal_le_iff_le_toReal]\n            · rw [←sub_eq_add_neg, ENNReal.ofReal_sub, ENNReal.ofReal_one]; exact le_of_lt total.1\n              exact le_of_lt ep\n            · apply Finset.sum_ne_top; intro x; apply PMF.a
pply_ne_top\n          · apply ENNReal.toReal_le_of_le_ofReal\n            · exact add_nonneg (by norm_num) (le_of_lt ep)\n            · rw [ENNReal.ofReal_add, ENNReal.ofReal_one]; exact le_of_lt total.2\n
   · norm_num\n              · exact le_of_lt ep\n        · intro x\n          simp only [Finsupp.mem_support_iff, Finsupp.ofSupportFinite_coe, h,\n            ENNReal.toReal_ne_zero, PMF.mem_support_iff]\n          a
pply And.left\n        · intro x _ m\n          simpa only [Finsupp.mem_support_iff, Finsupp.ofSupportFinite_coe, ne_eq, not_not] using m\n      · intro x _ m; simpa only [h x, PMF.mem_support_iff, not_not] using m",
start=(29, 1), end=(72, 76), kind='commanddeclaration'), Premise(full_name='Prob.toPmf_coe', code='@[simp] lemma Prob.toPmf_coe (f : Prob α) (x : α) : f.toPmf x = ENNReal.ofReal (f.prob x) := rfl', start=(74, 1), end=
(75, 97), kind='lemma'), Premise(full_name='PMF.prob_toProb', code='@[simp] lemma PMF.prob_toProb (f : PMF α) (h : f.support.Finite) (x : α) :\n    (f.toProb h).prob x = ENNReal.toReal (f x) := rfl', start=(77, 1), en
d=(79, 54), kind='lemma'), Premise(full_name='Prob.toPmf_support_finite', code="lemma Prob.toPmf_support_finite (f : Prob α) : f.toPmf.support.Finite := by\n  apply Set.Finite.ofFinset f.supp; intro x\n  simp only [me
m_iff, ne_eq, PMF.mem_support_iff, toPmf_coe, ENNReal.ofReal_eq_zero, not_le]\n  constructor\n  · intro h; exact Ne.lt_of_le (Ne.symm h) (prob_nonneg _)\n  · intro h; exact h.ne'", start=(81, 1), end=(87, 25), kind='l
emma'), Premise(full_name='Prob.toProb_toPmf', code='theorem Prob.toProb_toPmf (f : Prob α) : f.toPmf.toProb f.toPmf_support_finite = f', start=(89, 1), end=(91, 95), kind='commanddeclaration'), Premise(full_name='PMF
.toPmf_toProb', code='theorem PMF.toPmf_toProb (f : PMF α) (hf : f.support.Finite) : (f.toProb hf).toPmf = f', start=(93, 1), end=(96, 59), kind='commanddeclaration'), Premise(full_name="PMF.pure_apply'", code="lemma
PMF.pure_apply' (x y : α) : (Pure.pure x : PMF α) y = if y = x then 1 else 0 := rfl", start=(103, 1), end=(104, 90), kind='lemma'), Premise(full_name="PMF.bind_apply'", code="lemma PMF.bind_apply' (p : PMF α) (f : α →
 PMF β) (y : β) :\n    (Bind.bind p f) y = ∑' x : α, p x * f x y := rfl", start=(106, 1), end=(108, 53), kind='lemma'), Premise(full_name='Prob.pure_toPmf', code="lemma Prob.pure_toPmf (x : α) : (pure x : Prob α).toPm
f = pure x := by\n  ext y; simp only [toPmf_coe, prob_pure, PMF.pure_apply']\n  split_ifs; simp only [ENNReal.ofReal_one]; simp only [ENNReal.ofReal_zero]", start=(110, 1), end=(113, 77), kind='lemma'), Premise(full_n
ame='Prob.bind_toPmf', code="lemma Prob.bind_toPmf (f : Prob α) (g : α → Prob β) :\n    (f >>= g).toPmf = f.toPmf >>= (fun x ↦ (g x).toPmf) := by\n  ext y\n  simp only [Prob.toPmf_coe, PMF.bind_apply', Prob.prob_bind,
 Prob.exp, Finsupp.sum,\n    ←Finset.sum_ofReal fun _ ↦ mul_nonneg (prob_nonneg _) (prob_nonneg _),\n    ←ENNReal.ofReal_mul (prob_nonneg _)]\n  refine (HasSum.tsum_eq ?_).symm\n  apply Finset.hasSum_sum\n  intro _ m\
n  simp only [Finsupp.mem_support_iff, not_not] at m\n  simp only [m, zero_mul, ENNReal.ofReal_zero]", start=(115, 1), end=(126, 47), kind='lemma'), Premise(full_name='Prob.tsum_toPmf_eq_exp', code="lemma Prob.tsum_to
Pmf_eq_exp (f : Prob α) (u : α → ℝ) :\n    ∑' x, (f.toPmf x).toReal * u x = f.exp u := by\n  apply HasSum.tsum_eq; simp only [Prob.toPmf_coe, ENNReal.toReal_ofReal (prob_nonneg _)]\n  apply Finset.hasSum_sum; intro _
m\n  simp only [Finsupp.mem_support_iff, ne_eq, not_not] at m; simp only [m, zero_mul]", start=(128, 1), end=(133, 84), kind='lemma'), Premise(full_name='PMF.integrable_of_support_finite', code="lemma PMF.integrable_o
f_support_finite (f : PMF α) (u : α → ℝ) (hf : f.support.Finite)\n    [MeasurableSpace α] [MeasurableSingletonClass α] :\n    MeasureTheory.Integrable u f.toMeasure := by\n  rw [←PMF.restrict_toMeasure_support, ←Measu
reTheory.IntegrableOn]\n  have e : f.support = ⋃ (x : α) (_ : x ∈ hf.toFinset), {x} := by\n    ext x\n    simp only [mem_support_iff, ne_eq, Finite.mem_toFinset, mem_iUnion, mem_singleton_iff,\n      exists_prop, exis
ts_eq_right']\n  rw [e, MeasureTheory.integrableOn_finset_iUnion]\n  intro _ _\n  rw [MeasureTheory.integrableOn_singleton_iff,  PMF.toMeasure_apply_singleton]\n  · right; apply f.apply_lt_top\n  · apply MeasurableSet
.singleton", start=(135, 1), end=(148, 34), kind='lemma'), Premise(full_name='Prob.integrable_toPmf', code='lemma Prob.integrable_toPmf (f : Prob α) (u : α → ℝ) [MeasurableSpace α]\n    [MeasurableSingletonClass α] :
MeasureTheory.Integrable u f.toPmf.toMeasure :=\n  PMF.integrable_of_support_finite _ _ f.toPmf_support_finite', start=(150, 1), end=(153, 62), kind='lemma'), Premise(full_name='Prob.integral_toPmf_eq_exp', code='lemm
a Prob.integral_toPmf_eq_exp (f : Prob α) (u : α → ℝ) [MeasurableSpace α]\n    [MeasurableSingletonClass α] : ∫ x, u x ∂(f.toPmf.toMeasure) = f.exp u := by\n  simp_rw [←Prob.tsum_toPmf_eq_exp, ←smul_eq_mul]\n  exact P
MF.integral_eq_tsum _ _ (f.integrable_toPmf _)', start=(155, 1), end=(159, 56), kind='lemma')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/InteractiveSvg.lean'), imports=['.lake/packag
es/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/InteractiveSvg.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean'], premises=[Premise(full_name='State', code
='abbrev State := Array (Float × Float)', start=(7, 1), end=(7, 38), kind='commanddeclaration'), Premise(full_name='isvg', code='def isvg : InteractiveSvg State where\n  init := #[(-0.5, -0.5), (0.5, -0.5), (0.5, 0.5)
, (-0.5, 0.5)]\n\n  frame :=\n    { xmin := -1\n      ymin := -1\n      xSize := 2\n      width := 400\n      height := 400 }\n\n  update _time _Δt _action _mouseStart mouseEnd _selected getData state :=\n    match ge
tData Nat, mouseEnd with\n    | some id, some p => state.set! id p.toAbsolute\n    | _, _ => state\n\n  render _time mouseStart mouseEnd state :=\n    {\n      elements :=\n        let mousePointer :=\n          match
 mouseStart, mouseEnd with\n          | some s, some e =>\n            #[\n              Svg.circle e (.px 5) |>.setFill (1.,1.,1.),\n              Svg.line s e |>.setStroke (1.,1.,1.) (.px 2)\n            ]\n
  | _, _ => #[]\n        let circles := (state.mapIdx fun idx (p : Float × Float) =>\n              Svg.circle p (.abs 0.2) |>.setFill (0.7,0.7,0.7) |>.setId s!"circle{idx}" |>.setData idx.1\n            )\n        mo
usePointer.append circles\n    }', start=(9, 1), end=(39, 6), kind='commanddeclaration'), Premise(full_name='updateSvg', code='@[server_rpc_method]\ndef updateSvg (params : UpdateParams State) : RequestM (RequestTask
(UpdateResult State)) := isvg.serverRpcMethod params', start=(43, 1), end=(44, 121), kind='commanddeclaration'), Premise(full_name='SvgWidget', code='@[widget_module]\ndef SvgWidget : Component (UpdateResult State) wh
ere\n  javascript := include_str ".." / ".." / ".lake" / "build" / "js" / "interactiveSvg.js"', start=(47, 1), end=(49, 89), kind='commanddeclaration'), Premise(full_name='init', code='def init : UpdateResult State :=
 {\n  html := <div>Init!!!</div>,\n  state := { state := isvg.init\n             time := 0\n             selected := none\n             mousePos := none\n             idToData := isvg.render 0 none none isvg.init |>.i
dToDataList}\n}', start=(51, 1), end=(58, 2), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/LazyComputation.lean'), imports=['.lake/packages/lean4/src/lean/In
it.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/Basic.lean'], premises=[Premise(full_name='MetaMStringCont', code='structure MetaMStringCont where\n  ci : Elab.ContextInfo\n  lctx : LocalContext\n  k : M
etaM String\n  deriving TypeName', start=(6, 1), end=(12, 20), kind='commanddeclaration'), Premise(full_name='RunnerWidgetProps', code='structure RunnerWidgetProps where\n  \n  k : WithRpcRef MetaMStringCont\n  derivi
ng RpcEncodable', start=(14, 1), end=(18, 24), kind='commanddeclaration'), Premise(full_name='runMetaMStringCont', code='@[server_rpc_method]\ndef runMetaMStringCont : RunnerWidgetProps → RequestM (RequestTask String)
\n  | {k := ⟨{ci, lctx, k}⟩} => RequestM.asTask do\n    ci.runMetaM lctx k', start=(20, 1), end=(23, 23), kind='commanddeclaration'), Premise(full_name='runnerWidget', code='@[widget_module]\ndef runnerWidget : Compon
ent RunnerWidgetProps where\n  javascript := "\n    import { RpcContext, mapRpcError } from \'@leanprover/infoview\'\n    import * as React from \'react\';\n    const e = React.createElement;\n\n    export default fun
ction(props) {\n      const [contents, setContents] = React.useState(\'Run!\')\n      const rs = React.useContext(RpcContext)\n      return e(\'button\', { onClick: () => {\n        setContents(\'Running..\')\n
 rs.call(\'runMetaMStringCont\', props)\n          .then(setContents)\n          .catch(e => { setContents(mapRpcError(e).message) })\n      }}, contents)\n    }\n  "', start=(25, 1), end=(42, 4), kind='commanddeclara
tion'), Premise(full_name='makeRunner', code='@[tactic makeRunnerTac] def makeRunner : Tactic\n  | `(tactic| make_runner%$tk) => do\n    let x : MetaM String := do\n      return "Hello, world!"\n    let props : Runner
WidgetProps := {\n      k := ⟨{\n        ci := { ← CommandContextInfo.save with }\n        lctx := (← getLCtx)\n        k := x\n      }⟩}\n    Widget.savePanelWidgetInfo runnerWidget.javascriptHash (rpcEncode props) t
k\n  | _ => throwUnsupportedSyntax', start=(46, 1), end=(59, 32), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/ExprPresentation.lean'), imports=['.lake/packa
ges/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/Panel/GoalTypePanel.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/Panel/SelectionPanel.lean'], premises=[Premise(full_nam
e='presenter', code='@[expr_presenter]\ndef presenter : ExprPresenter where\n  userName := "With octopodes"\n  layoutKind := .inline\n  present e :=\n    return <span>\n        {.text "🐙 "}<InteractiveCode fmt={← Lea
n.Widget.ppExprTagged e} />{.text " 🐙"}\n      </span>', start=(6, 1), end=(13, 14), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/RbTree.lean'), imports=['.
lake/packages/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/ProofWidgets/Presentation/Expr.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/Panel/SelectionPanel.lean'], premises=[Premise(full_name=
'RBColour', code='inductive RBColour where\n  | red | black', start=(7, 1), end=(8, 16), kind='commanddeclaration'), Premise(full_name='RBTree', code='inductive RBTree (α : Type u) where\n  | empty : RBTree α\n  | nod
e (color : RBColour) (l : RBTree α) (a : α) (r : RBTree α) : RBTree α', start=(10, 1), end=(12, 77), kind='commanddeclaration'), Premise(full_name='RBTree.contains', code='def contains [Ord α] (a : α) : RBTree α → Boo
l\n  | empty => false\n  | node _ l b r => match compare a b with\n    | .lt => l.contains a\n    | .eq => true\n    | .gt => r.contains a', start=(16, 1), end=(21, 26), kind='commanddeclaration'), Premise(full_name='
RBTree.balance', code='def balance : RBColour → RBTree α → α → RBTree α → RBTree α\n  | .black, (node .red (node .red a x b) y c), z, d\n  | .black, (node .red a x (node .red b y c)), z, d\n  | .black, a, x, (node .re
d (node .red b y c) z d)\n  | .black, a, x, (node .red b y (node .red c z d)) =>\n    node .red (node .black a x b) y (node .black c z d)\n  | color, a, x, b => node color a x b', start=(23, 1), end=(29, 39), kind='co
mmanddeclaration'), Premise(full_name='RBTree.insert', code='def insert [Ord α] (a : α) (s : RBTree α) : RBTree α :=\n  makeBlack (ins s)\nwhere\n  ins : RBTree α → RBTree α\n    | empty => node .red empty a empty\n
  | node c l b r => match compare a b with\n      | .lt => balance c (ins l) b r\n      | .eq => node c l b r\n      | .gt => balance c l b (ins r)\n  makeBlack : RBTree α → RBTree α\n    | empty => empty\n    | node
_ l b r => node .black l b r', start=(31, 1), end=(42, 40), kind='commanddeclaration'), Premise(full_name='empty?', code='def empty? (e : Expr) : Bool :=\n  e.app1? ``RBTree.empty matches some _', start=(50, 1), end=(
51, 40), kind='commanddeclaration'), Premise(full_name='Lean.Expr.app5?', code='@[inline] def Lean.Expr.app5? (e : Expr) (fName : Name) : Option (Expr × Expr × Expr × Expr × Expr) :=\n  if e.isAppOfArity fName 5 then\
n    some (\n      e.appFn!.appFn!.appFn!.appFn!.appArg!,\n      e.appFn!.appFn!.appFn!.appArg!,\n      e.appFn!.appFn!.appArg!,\n      e.appFn!.appArg!,\n      e.appArg!)\n  else\n    none', start=(53, 1), end=(62, 9
), kind='commanddeclaration'), Premise(full_name='node?', code='def node? (e : Expr) : Option (Expr × Expr × Expr × Expr) := do\n  let some (_, color, l, a, r) := e.app5? ``RBTree.node | none\n  return (color, l, a, r
)', start=(64, 1), end=(66, 26), kind='commanddeclaration'), Premise(full_name='evalColourUnsafe', code="unsafe def evalColourUnsafe (e : Expr) : MetaM RBColour :=\n  Lean.Meta.evalExpr' RBColour ``RBColour e", start=
(68, 1), end=(69, 44), kind='commanddeclaration'), Premise(full_name='evalColour', code='@[implemented_by evalColourUnsafe]\nopaque evalColour (e : Expr) : MetaM RBColour', start=(71, 1), end=(72, 46), kind='commandde
claration'), Premise(full_name='RBTreeVarsColour', code='inductive RBTreeVarsColour where\n  | red | black | blue\n  deriving FromJson, ToJson', start=(74, 1), end=(77, 28), kind='commanddeclaration'), Premise(full_na
me='RBTreeVars', code='inductive RBTreeVars where\n  | empty : RBTreeVars\n  | var : CodeWithInfos → RBTreeVars\n  | node (color : RBTreeVarsColour) (l : RBTreeVars) (a : CodeWithInfos) (r : RBTreeVars) : RBTreeVars\n
  deriving Server.RpcEncodable', start=(80, 1), end=(89, 31), kind='commanddeclaration'), Premise(full_name='RBDisplayProps', code='structure RBDisplayProps where\n  tree : RBTreeVars\n  deriving Server.RpcEncodable',
 start=(93, 1), end=(95, 31), kind='commanddeclaration'), Premise(full_name='RBDisplay', code='@[widget_module]\ndef RBDisplay : Component RBDisplayProps where\n  javascript := include_str ".." / ".." / ".lake" / "bui
ld" / "js" / "rbTree.js"', start=(99, 1), end=(101, 81), kind='commanddeclaration'), Premise(full_name='drawTree?', code='partial def drawTree? (e : Expr) : MetaM (Option Html) := do\n  if let some _ := node? e then\n
    return some <RBDisplay tree={← go e}/>\n  else if empty? e then\n    return some <RBDisplay tree={← go e}/>\n  else\n    return none\nwhere go (e : Expr) : MetaM RBTreeVars := do\n  if let some (color, l, a, r) :=
 node? e then\n    let color ← try\n        match ← evalColour color with\n        | .red => pure .red\n        | .black => pure .black\n      catch _ => pure .blue\n    return .node color (← go l) (← Widget.ppExprTag
ged a) (← go r)\n  else if empty? e then\n    return .empty\n  else\n    return .var (← Widget.ppExprTagged e)', start=(104, 1), end=(122, 42), kind='commanddeclaration'), Premise(full_name='RBTree.presenter', code='@
[expr_presenter]\ndef RBTree.presenter : ExprPresenter where\n  userName := "Red-black tree"\n  present e := do\n    let some t ← drawTree? e\n      | throwError "not a tree :("\n    return t', start=(124, 1), end=(13
0, 13), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Dynkin.lean'), imports=['.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/ProofWid
gets/Component/HtmlDisplay.lean'], premises=[Premise(full_name='List.product', code='def List.product : List α → List β → List (α × β)\n  | [], _     => []\n  | a::as, bs => bs.map ((a, ·)) ++ as.product bs', start=(6
, 1), end=(8, 50), kind='commanddeclaration'), Premise(full_name='Matrix', code='def Matrix (n m α : Type) := n → m → α', start=(10, 1), end=(10, 39), kind='commanddeclaration'), Premise(full_name='Matrix.nat_index',
code='def nat_index (i j : Nat) : Int :=\n  if h : i < n ∧ j < n then A ⟨i, h.1⟩ ⟨j, h.2⟩ else 999', start=(19, 1), end=(20, 57), kind='commanddeclaration'), Premise(full_name='Matrix.get_node_pos_E', code='def get_no
de_pos_E : Nat → Nat × Nat\n  | 0     => ⟨0, 0⟩\n  | 1     => ⟨2, 1⟩\n  | (i+1) => ⟨i, 0⟩', start=(22, 1), end=(26, 20), kind='commanddeclaration'), Premise(full_name='Matrix.get_node_pos', code='def get_node_pos (n :
 Nat) : Nat → Nat × Nat := if n < 6 then ((·, 0)) else get_node_pos_E', start=(28, 1), end=(29, 91), kind='commanddeclaration'), Premise(full_name='Matrix.get_node_cx', code='def get_node_cx (n i : Nat) : Int := 20 +
(get_node_pos n i).1 * 40', start=(31, 1), end=(31, 68), kind='commanddeclaration'), Premise(full_name='Matrix.get_node_cy', code='def get_node_cy (n i : Nat) : Int := 20 + (get_node_pos n i).2 * 40', start=(33, 1), e
nd=(33, 68), kind='commanddeclaration'), Premise(full_name='Matrix.get_node_html', code='def get_node_html (n i : Nat) : Html :=\n  <circle\n    cx={toString <| get_node_cx n i}\n    cy={toString <| get_node_cy n i}\n
    r="10"\n    fill="white"\n    stroke="black" />', start=(35, 1), end=(41, 22), kind='commanddeclaration'), Premise(full_name='Matrix.get_edge_html', code='def get_edge_html : Nat × Nat → List Html\n  | (i, j) => i
f A.nat_index i j = 0 then [] else\n  [<line\n     x1={toString <| get_node_cx n i}\n     y1={toString <| get_node_cy n i}\n     x2={toString <| get_node_cx n j}\n     y2={toString <| get_node_cy n j}\n     fill="blac
k"\n     stroke="black" />]', start=(43, 1), end=(56, 24), kind='commanddeclaration'), Premise(full_name='Matrix.get_nodes_html', code='def get_nodes_html (n : Nat) : List Html :=\n  (List.range n).map (get_node_html
n)', start=(58, 1), end=(59, 39), kind='commanddeclaration'), Premise(full_name='Matrix.get_edges_html', code='def get_edges_html : List Html := Id.run do\n  let mut out := []\n  for j in [:n] do\n    for i in [:j] do
\n      out := A.get_edge_html (i, j) ++ out\n  return out', start=(61, 1), end=(66, 13), kind='commanddeclaration'), Premise(full_name='Matrix.toHtml', code='def toHtml (M : Matrix (Fin n) (Fin n) Int) : Html :=\n  <
div style={json% { height: "100px", width: "300px", background: "grey" }}>\n    {Html.element "svg" #[] (M.get_edges_html ++ Matrix.get_nodes_html n).toArray}\n  </div>', start=(68, 1), end=(71, 9), kind='commanddecla
ration'), Premise(full_name='cartanMatrix.E₈', code='def cartanMatrix.E₈ : Matrix (Fin 8) (Fin 8) Int :=\n  fun i j =>\n    [[ 2,  0, -1,  0,  0,  0,  0,  0],\n     [ 0,  2,  0, -1,  0,  0,  0,  0],\n     [-1,  0,  2,
 -1,  0,  0,  0,  0],\n     [ 0, -1, -1,  2, -1,  0,  0,  0],\n     [ 0,  0,  0, -1,  2, -1,  0,  0],\n     [ 0,  0,  0,  0, -1,  2, -1,  0],\n     [ 0,  0,  0,  0,  0, -1,  2, -1],\n     [ 0,  0,  0,  0,  0,  0, -1,
 2]].get! i |>.get! j', start=(75, 1), end=(84, 56), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Euclidean.lean'), imports=['.lake/packages/lean4/src/lean/L
ean/Data/HashMap.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/PenroseDiagram.lean', '.lake/packages/proofwidgets/ProofWidgets/Compon
ent/MakeEditLink.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/Panel/Basic.lean', '.lake/packages/lean4/src/lean/Lean/Elab/Tactic.lean', '.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/proofwid
gets/ProofWidgets/Component/OfRpcMethod.lean'], premises=[Premise(full_name='IncidenceGeometry', code='class IncidenceGeometry where\n  Point : Type u₁\n  Line : Type u₂\n  between : Point → Point → Point → Prop onLin
e : Point → Line → Prop\n  ne_23_of_between : ∀ {a b c : Point}, between a b c → b ≠ c\n  line_unique_of_pts : ∀ {a b : Point}, ∀ {L M : Line},\n    a ≠ b → onLine a L → onLine b L → onLine a M → onLine b M → L = M\n
 onLine_2_of_between : ∀ {a b c : Point}, ∀ {L : Line},\n    between a b c → onLine a L → onLine c L → onLine b L\n  line_of_pts : ∀ a b, ∃ L, onLine a L ∧ onLine b L', start=(25, 1), end=(35, 52), kind='commanddeclar
ation'), Premise(full_name='isOnLinePred?', code='def isOnLinePred? (e : Expr) : Option (Expr × Expr) := do\n  let some (_, a, L) := e.app3? ``onLine | none\n  return (a, L)', start=(42, 1), end=(45, 16), kind='comman
ddeclaration'), Premise(full_name='isBetweenPred?', code='def isBetweenPred? (e : Expr) : Option (Expr × Expr × Expr) := do\n  let some (_, a, b, c) := e.app4? ``between | none\n  return (a, b, c)', start=(47, 1), end
=(50, 19), kind='commanddeclaration'), Premise(full_name='isPoint?', code='def isPoint? (e : Expr) : Bool :=\n  e.isAppOf ``Point', start=(52, 1), end=(53, 20), kind='commanddeclaration'), Premise(full_name='isLine?',
 code='def isLine? (e : Expr) : Bool :=\n  e.isAppOf ``Line', start=(55, 1), end=(56, 19), kind='commanddeclaration'), Premise(full_name='DiagramState', code='structure DiagramState where\n  \n  sub : String := ""\n
\n  embeds : HashMap String (String × Html) := .empty', start=(60, 1), end=(66, 52), kind='commanddeclaration'), Premise(full_name='DiagramBuilderM', code='abbrev DiagramBuilderM := StateT DiagramState MetaM', start=(
68, 1), end=(68, 52), kind='commanddeclaration'), Premise(full_name='buildDiagram', code='def buildDiagram : DiagramBuilderM (Option Html) := do\n  let st ← get\n  if st.sub == "" && st.embeds.isEmpty then\n    return
 none\n  let mut sub := "AutoLabel All\\n"\n  let mut embedHtmls := #[]\n  for (n, (tp, h)) in st.embeds.toArray do\n    sub := sub ++ s!"{tp} {n}\\n"\n    embedHtmls := embedHtmls.push (n, h)\n  sub := sub ++ st.sub\
n  return <PenroseDiagram\n    embeds={embedHtmls}\n    dsl={include_str ".."/".."/"widget"/"penrose"/"euclidean.dsl"}\n    sty={include_str ".."/".."/"widget"/"penrose"/"euclidean.sty"}\n    sub={sub} />', start=(71,
 1), end=(85, 17), kind='commanddeclaration'), Premise(full_name='addEmbed', code='def addEmbed (nm : String) (tp : String) (h : Html) : DiagramBuilderM Unit := do\n  modify fun st => { st with embeds := st.embeds.ins
ert nm (tp, h )}', start=(87, 1), end=(90, 69), kind='commanddeclaration'), Premise(full_name='addExpr', code='def addExpr (tp : String) (e : Expr) : DiagramBuilderM String := do\n  let nm ← toString <$> Lean.Meta.ppE
xpr e\n  let h := <InteractiveCode fmt={← Widget.ppExprTagged e} />\n  addEmbed nm tp h\n  return nm', start=(93, 1), end=(101, 12), kind='commanddeclaration'), Premise(full_name="addExpr'", code="def addExpr' (tp : S
tring) (e : Expr) : DiagramBuilderM Unit := do\n  let _ ← addExpr tp e", start=(103, 1), end=(104, 23), kind='commanddeclaration'), Premise(full_name='addInstruction', code='def addInstruction (i : String) : DiagramBu
ilderM Unit := do\n  modify fun st => { st with sub := st.sub ++ s!"{i}\\n" }', start=(106, 1), end=(108, 58), kind='commanddeclaration'), Premise(full_name='addHypotheses', code='def addHypotheses (hyps : Array Local
Decl) : DiagramBuilderM Unit := do\n  for h in hyps do\n    let tp ← instantiateMVars h.type\n    if isPoint? tp then\n      addExpr\' "Point" h.toExpr\n    if isLine? tp then\n      addExpr\' "Line" h.toExpr\n    if
let some (a, L) := isOnLinePred? tp then\n      let sa ← addExpr "Point" a\n      let sL ← addExpr "Line" L\n      addInstruction s!"On({sa}, {sL})"\n    if let some (a, b, c) := isBetweenPred? tp then\n      let sa ←
 addExpr "Point" a\n      let sb ← addExpr "Point" b\n      let sc ← addExpr "Point" c\n      addInstruction s!"Between({sa}, {sb}, {sc})"', start=(110, 1), end=(125, 51), kind='commanddeclaration'), Premise(full_name
='DiagramBuilderM.run', code="def DiagramBuilderM.run (x : DiagramBuilderM α) : MetaM α :=\n  x.run' {}", start=(127, 1), end=(128, 12), kind='commanddeclaration'), Premise(full_name='EuclideanDisplay.rpc', code='@[se
rver_rpc_method]\ndef EuclideanDisplay.rpc (props : PanelWidgetProps) : RequestM (RequestTask Html) :=\n  RequestM.asTask do\n    let inner : Html ← (do\n      if props.goals.isEmpty then\n        return <span>No goal
s.</span>\n      let some g := props.goals[0]? | unreachable!\n\n      g.ctx.val.runMetaM {} do\n        let md ← g.mvarId.getDecl\n        let lctx := md.lctx |>.sanitizeNames.run\' {options := (← getOptions)}\n
   Meta.withLCtx lctx md.localInstances do\n          let mut hiddenLocs : HashSet FVarId := mkHashSet props.selectedLocations.size\n          for l in props.selectedLocations do\n            match l with\n
 | ⟨mv, .hyp fv⟩ | ⟨mv, .hypType fv _⟩ =>\n              if mv == g.mvarId then\n                hiddenLocs := hiddenLocs.insert fv\n            | _ => continue\n          let locs := (← getLCtx).decls.toArray.filterM
ap (fun d? =>\n            if let some d := d? then\n              if !hiddenLocs.contains d.fvarId then some d else none\n            else\n              none)\n          DiagramBuilderM.run do\n            addHypoth
eses locs\n            match ← buildDiagram with\n            | some html => return html\n            | none => return <span>No Euclidean goal.</span>)\n\n    return <details «open»={true}>\n        <summary className
="mv2 pointer">Euclidean diagram</summary>\n        <div className="ml1">{inner}</div>\n      </details>', start=(133, 1), end=(172, 17), kind='commanddeclaration'), Premise(full_name='EuclideanDisplay', code='@[widge
t_module]\ndef EuclideanDisplay : Component PanelWidgetProps :=\n  mk_rpc_widget% EuclideanDisplay.rpc', start=(174, 1), end=(176, 38), kind='commanddeclaration'), Premise(full_name='constructLines', code='def constru
ctLines (hyps : Array LocalDecl) (meta : Server.DocumentMeta) (cursorPos : Lsp.Position)\n    : DiagramBuilderM Unit := do\n  let mut points : Array LocalDecl := {}\n  for h in hyps do\n    let tp ← instantiateMVars h
.type\n    if isPoint? tp then\n      points := points.push h\n\n  for hi : i in [0:points.size] do\n    for hj : j in [i+1:points.size] do\n      let p := points[i]\'hi.upper\n      let q := points[j]\'hj.upper\n
  let sp ← addExpr "Point" p.toExpr\n      let sq ← addExpr "Point" q.toExpr\n      let nm := s!"{sp}{sq}"\n      let ctr := s!"let ⟨{nm}, _, _⟩ := line_of_pts {sp} {sq}"\n      addEmbed nm "Line" (\n        <span>\n
         <b>{.text nm}</b> ({\n            .ofComponent MakeEditLink\n              (MakeEditLinkProps.ofReplaceRange meta ⟨cursorPos, cursorPos⟩ ctr)\n              #[.text "insert"]\n          })\n        </span>)\n
      addInstruction s!"On({sp}, {nm})"\n      addInstruction s!"On({sq}, {nm})"\n      addInstruction s!"Emphasize({nm})"', start=(191, 1), end=(223, 41), kind='commanddeclaration'), Premise(full_name='EuclideanConst
ructions.rpc', code='@[server_rpc_method]\ndef EuclideanConstructions.rpc (props : PanelWidgetProps) : RequestM (RequestTask Html) :=\n  RequestM.asTask do\n    let doc ← RequestM.readDoc\n    let inner : Html ← (do\n
      if props.goals.isEmpty then\n        return <span>No goals.</span>\n      let some g := props.goals[0]? | unreachable!\n\n      g.ctx.val.runMetaM {} do\n        let md ← g.mvarId.getDecl\n        let lctx := md
.lctx |>.sanitizeNames.run\' {options := (← getOptions)}\n        Meta.withLCtx lctx md.localInstances do\n\n          let allHyps := (← getLCtx).decls.toArray.filterMap id\n\n          let selectedHyps ← props.select
edLocations.filterMapM fun\n            | ⟨mv, .hyp fv⟩ | ⟨mv, .hypType fv _⟩ =>\n              if mv == g.mvarId then return some (← fv.getDecl) else return none\n            | _ =>\n              return none\n\n
      DiagramBuilderM.run do\n            addHypotheses allHyps\n            constructLines selectedHyps doc.meta props.pos\n            match ← buildDiagram with\n            | some html => return html\n            |
 none => return <span>No Euclidean goal.</span>)\n\n    return <details «open»={true}>\n        <summary className="mv2 pointer">Euclidean constructions</summary>\n        <div className="ml1">{inner}</div>\n      </d
etails>', start=(226, 1), end=(264, 17), kind='commanddeclaration'), Premise(full_name='EuclideanConstructions', code='@[widget_module]\ndef EuclideanConstructions : Component PanelWidgetProps :=\n  mk_rpc_widget% Euc
lideanConstructions.rpc', start=(266, 1), end=(268, 44), kind='commanddeclaration'), Premise(full_name='test_sorry', code='axiom test_sorry {α} : α', start=(270, 1), end=(270, 25), kind='commanddeclaration')]), Premis
eFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Macro.lean'), imports=['.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean'], premises=[
Premise(full_name='Lean.SourceInfo.mkCanonical', code='def Lean.SourceInfo.mkCanonical : SourceInfo → SourceInfo\n  | .synthetic s e _ => .synthetic s e true\n  | si => si', start=(13, 1), end=(15, 13), kind='commandd
eclaration'), Premise(full_name='Lean.Syntax.mkInfoCanonical', code='def Lean.Syntax.mkInfoCanonical : Syntax → Syntax\n  | .missing => .missing\n  | .node i k a => .node i.mkCanonical k a\n  | .atom i v => .atom i.mk
Canonical v\n  | .ident i r v p => .ident i.mkCanonical r v p', start=(17, 1), end=(21, 49), kind='commanddeclaration'), Premise(full_name='Lean.TSyntax.mkInfoCanonical', code='def Lean.TSyntax.mkInfoCanonical : TSynt
ax k → TSyntax k :=\n  (.mk ·.raw.mkInfoCanonical)', start=(23, 1), end=(24, 30), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Plot.lean'), imports=['.lake/p
ackages/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/Recharts.lean'], premises=[Premise(full_name='fn', code='de
f fn (t : Float) (x : Float): Float :=\n   50 * (x - 0.25) * (x - 0.5) * (x - 0.7) + 0.1 * (x * 40 - t * 2 * 3.141).sin', start=(6, 1), end=(7, 80), kind='commanddeclaration'), Premise(full_name='Plot', code='def Plot
 (fn : Float → Float) (steps := 100) : Html :=\n  let jsonData : Array Json :=\n    Nat.fold (flip Array.push) (steps + 1) #[]\n    |> Array.map (fun (x : Nat) => let x : Float := x.toFloat / steps.toFloat;  (x, fn x)
)\n    |> Array.map (fun (x,y) => json% {x: $(toJson x) , y: $(toJson y)});\n  <LineChart width={400} height={400} data={jsonData}>\n    <XAxis domain?={#[toJson 0, toJson 1]} dataKey?="x" />\n    <YAxis domain?={#[to
Json (-1), toJson 1]} allowDataOverflow={Bool.false} />\n    <Line type={.monotone} dataKey="y" stroke="#8884d8" dot?={Bool.false} />\n  </LineChart>', start=(10, 1), end=(19, 15), kind='commanddeclaration'), Premise(
full_name='mkFrames', code='def mkFrames (fn : Float → Float → Float) (steps := 100) : Array Html:=\n  List.range (steps + 1) |>.toArray |>.map (fun t => Plot (fn (t.toFloat / steps.toFloat)))', start=(30, 1), end=(31
, 92), kind='commanddeclaration'), Premise(full_name='AnimatedHtmlProps', code='structure AnimatedHtmlProps where\n  frames : Array Html\n  framesPerSecond? : Option Nat := none\n  deriving Server.RpcEncodable', start
=(33, 1), end=(36, 31), kind='commanddeclaration'), Premise(full_name='AnimatedHtml', code='@[widget_module]\ndef AnimatedHtml : Component AnimatedHtmlProps where\n  javascript := include_str ".." / ".." / ".lake" / "
build" / "js" / "animatedHtml.js"', start=(38, 1), end=(40, 87), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Venn.lean'), imports=['.lake/packages/lean4/src
/lean/Lean/Data/HashMap.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/PenroseDiagram.lean', '.lake/packages/proofwidgets/ProofWidgets
/Component/Panel/Basic.lean', '.lake/packages/lean4/src/lean/Lean/Elab/Tactic.lean', '.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/OfRpcMethod.lean'], premises=[Premise
(full_name='Set', code='def Set (α : Type u) := α → Prop', start=(12, 1), end=(12, 33), kind='commanddeclaration'), Premise(full_name='Set.Mem', code='protected def Mem (a : α) (s : Set α) : Prop :=\n  s a', start=(16
, 1), end=(18, 6), kind='commanddeclaration'), Premise(full_name='Set.ext', code='theorem ext {a b : Set α} (h : ∀ (x : α), x ∈ a ↔ x ∈ b) : a = b', start=(23, 1), end=(24, 33), kind='commanddeclaration'), Premise(ful
l_name='Set.Subset', code='protected def Subset (s₁ s₂ : Set α) :=\n  ∀ ⦃a⦄, a ∈ s₁ → a ∈ s₂', start=(26, 1), end=(27, 25), kind='commanddeclaration'), Premise(full_name='isSubsetPred?', code='def isSubsetPred? (e : E
xpr) : Option (Expr × Expr) := do\n  let some (_, _, S, T) := e.app4? ``HasSubset.Subset | none\n  return (S, T)', start=(41, 1), end=(44, 16), kind='commanddeclaration'), Premise(full_name='ExprEmbeds', code='abbrev
ExprEmbeds := Array (String × Expr)', start=(46, 1), end=(47, 43), kind='commanddeclaration'), Premise(full_name='mkSetDiag', code='def mkSetDiag (sub : String) (embeds : ExprEmbeds) : MetaM Html := do\n  let embeds ←
 embeds.mapM fun (s, h) =>\n      return (s, <InteractiveCode fmt={← Widget.ppExprTagged h} />)\n  return <PenroseDiagram\n      embeds={embeds}\n      dsl={include_str ".."/".."/"widget"/"penrose"/"setTheory.dsl"}\n
     sty={include_str ".."/".."/"widget"/"penrose"/"venn.sty"}\n      sub={sub} />', start=(50, 1), end=(57, 19), kind='commanddeclaration'), Premise(full_name='isSetGoal?', code='def isSetGoal? (hyps : Array LocalDec
l) : MetaM (Option Html) := do\n  let mut sub := "AutoLabel All\\n"\n  let mut sets : HashMap String Expr := .empty\n  for assm in hyps do\n    let tp ← instantiateMVars assm.type\n    if let some (S, T) := isSubsetPr
ed? tp then\n      let sS ← toString <$> Lean.Meta.ppExpr S\n      let sT ← toString <$> Lean.Meta.ppExpr T\n      let (sets\', cS) := sets.insert\' sS S\n      let (sets\', cT) := sets\'.insert\' sT T\n      sets :=
sets\'\n      if !cS then\n        sub := sub ++ s!"Set {sS}\\n"\n      if !cT then\n        sub := sub ++ s!"Set {sT}\\n"\n      sub := sub ++ s!"IsSubset({sS}, {sT})\\n"\n  if sets.isEmpty then return none\n  some <
$> mkSetDiag sub sets.toArray', start=(59, 1), end=(76, 38), kind='commanddeclaration'), Premise(full_name='findGoalForLocation', code='def findGoalForLocation (goals : Array Widget.InteractiveGoal) (loc : SubExpr.Goa
lsLocation) :\n    Option Widget.InteractiveGoal :=\n  goals.find? (·.mvarId == loc.mvarId)', start=(80, 1), end=(82, 39), kind='commanddeclaration'), Premise(full_name='VennDisplay.rpc', code='@[server_rpc_method]\nd
ef VennDisplay.rpc (props : PanelWidgetProps) : RequestM (RequestTask Html) :=\n  RequestM.asTask do\n    let inner : Html ← (do\n      if props.selectedLocations.isEmpty then\n        return <span>Use shift-click to
select hypotheses to include in the diagram.</span>\n      let some selectedLoc := props.selectedLocations[0]? | unreachable!\n\n      let some g := findGoalForLocation props.goals selectedLoc\n        | throw $ .inva
lidParams\n            s!"could not find goal for location {toJson selectedLoc}"\n      g.ctx.val.runMetaM {} do\n        let md ← g.mvarId.getDecl\n        let lctx := md.lctx |>.sanitizeNames.run\' {options := (← ge
tOptions)}\n        Meta.withLCtx lctx md.localInstances do\n          let locs : Array LocalDecl ← props.selectedLocations.filterMapM fun\n            | ⟨mv, .hyp fv⟩ | ⟨mv, .hypType fv _⟩ =>\n              if mv ==
g.mvarId then return some (← fv.getDecl) else return none\n            | _ => return none\n          match ← isSetGoal? locs with\n          | some html => return html\n          | none => return <span>No set goal.</s
pan>)\n    return <details «open»={true}>\n        <summary className="mv2 pointer">Venn diagram</summary>\n        <div className="ml1">{inner}</div>\n      </details>', start=(85, 1), end=(110, 17), kind='commanddec
laration'), Premise(full_name='VennDisplay', code='@[widget_module]\ndef VennDisplay : Component PanelWidgetProps :=\n  mk_rpc_widget% VennDisplay.rpc', start=(112, 1), end=(114, 33), kind='commanddeclaration')]), Pre
miseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/SelectInsertConv.lean'), imports=['.lake/packages/proofwidgets/ProofWidgets/Data/Html.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/
MakeEditLink.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/Panel/Basic.lean', '.lake/packages/lean4/src/lean/Lean/Meta/ExprLens.lean', '.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/proofwidge
ts/ProofWidgets/Component/OfRpcMethod.lean', '.lake/packages/batteries/Batteries/Lean/Position.lean'], premises=[Premise(full_name='SolveReturn', code='private structure SolveReturn where\n  expr : Expr\n  val? : Opti
on String\n  listRest : List Nat', start=(23, 1), end=(26, 22), kind='commanddeclaration'), Premise(full_name='solveLevel', code='private def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match exp
r with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    while descExp.isApp do\n      if (←Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit
 then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    let mut mutablePath := path\n    let mut l
ength := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := e
xplicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n
 let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count , listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n
  | Name.str _ s => s\n      | _ => panic! "no name found"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n
    | _ => panic! "no name found"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { expr := b, val? := none, listRest :=
path }\n      | _ => return { expr := b.appFn!.appArg!, val? := none, listRest := path.tail!.tail! }\n\n  | _ => do\n    return {\n      expr := ←(Lean.Core.viewSubexpr path.head! expr)\n      val? := toString (path.h
ead! + 1)\n      listRest := path.tail!\n    }', start=(28, 1), end=(86, 6), kind='commanddeclaration'), Premise(full_name='insertEnter', code='def insertEnter (locations : Array Lean.SubExpr.GoalsLocation) (goalType
: Expr) : MetaM String := do\n  let some pos := locations[0]? | throwError "You must select something."\n  let ⟨_, .target subexprPos⟩ := pos | throwError "You must select something in the goal."\n  let mut list := (S
ubExpr.Pos.toArray subexprPos).toList\n    let mut expr := goalType\n  let mut retList := []\n  while !list.isEmpty do\n    let res ← solveLevel expr list\n    expr := res.expr\n    retList := match res.val? with\n
   | none => retList\n      | some val => val::retList\n    list := res.listRest\n\n  retList := List.reverse retList\n  let mut enterval := "conv => enter " ++ toString retList\n  if enterval.contains \'0\' then ente
rval := "Error: Not a valid conv target"\n  if retList.isEmpty then enterval := ""\n  return enterval', start=(89, 1), end=(109, 18), kind='commanddeclaration'), Premise(full_name='findGoalForLocation', code='def find
GoalForLocation (goals : Array Widget.InteractiveGoal) (loc : SubExpr.GoalsLocation) :\n    Option Widget.InteractiveGoal :=\n  goals.find? (·.mvarId == loc.mvarId)', start=(111, 1), end=(113, 39), kind='commanddeclar
ation'), Premise(full_name='ConvSelectionPanelProps', code='structure ConvSelectionPanelProps extends PanelWidgetProps where\n  \n  replaceRange : Lsp.Range\n  deriving RpcEncodable', start=(115, 1), end=(118, 24), ki
nd='commanddeclaration'), Premise(full_name='ConvSelectionPanel.rpc', code='@[server_rpc_method]\ndef ConvSelectionPanel.rpc (props : ConvSelectionPanelProps) : RequestM (RequestTask Html) :=\n  RequestM.asTask do\n
  let doc ← RequestM.readDoc\n    let inner : Html ← (do\n      if props.selectedLocations.isEmpty then\n        return <span>Use shift-click to select one sub-expression in the goal that you want to zoom on.</span>\n
      let some selectedLoc := props.selectedLocations[0]? | unreachable!\n\n      let some g := findGoalForLocation props.goals selectedLoc\n        | throw $ .invalidParams\n            s!"could not find goal for loc
ation {toJson selectedLoc}"\n      g.ctx.val.runMetaM {} do\n        let md ← g.mvarId.getDecl\n        let lctx := md.lctx |>.sanitizeNames.run\' {options := (← getOptions)}\n        Meta.withLCtx lctx md.localInstan
ces do\n          let newCode ← insertEnter props.selectedLocations md.type\n          return .ofComponent\n            MakeEditLink\n            (.ofReplaceRange doc.meta props.replaceRange newCode)\n            #[ .
text newCode ])\n    return <details «open»={true}>\n        <summary className="mv2 pointer">Conv 🔍</summary>\n        <div className="ml1">{inner}</div>\n      </details>', start=(121, 1), end=(145, 17), kind='comm
anddeclaration'), Premise(full_name='ConvSelectionPanel', code='@[widget_module]\ndef ConvSelectionPanel : Component ConvSelectionPanelProps :=\n  mk_rpc_widget% ConvSelectionPanel.rpc', start=(147, 1), end=(149, 40),
 kind='commanddeclaration'), Premise(full_name='test_sorry', code='axiom test_sorry {α} : α', start=(158, 1), end=(158, 25), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofW
idgets/Demos/Svg.lean'), imports=['.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean', '.lake/packages/proofwidgets/ProofWidgets/Data/Svg.lean'], premises=[
Premise(full_name='frame', code='private def frame : Frame where\n  xmin   := -2\n  ymin   := -2\n  xSize  := 4\n  width  := 400\n  height := 400', start=(6, 1), end=(11, 16), kind='commanddeclaration'), Premise(full_
name='svg', code='private def svg : Svg frame :=\n  { elements :=\n      #[line (0.,0.) (1.,0.) |>.setStroke (1.,0.,0.) (.px 2),\n        line (1.,0.) (0.,1.) |>.setStroke (0.,1.,0.) (.px 2),\n        line (0.,1.) (0.
,0.) |>.setStroke (0.,0.,1.) (.px 2),\n        circle (0.,0.) (.abs 0.1) |>.setStroke (0.,0.,0.) (.px 2) |>.setFill (0.,1.,1.) |>.setId "point1",\n        circle (1.,0.) (.abs 0.1) |>.setStroke (0.,0.,0.) (.px 2) |>.s
etFill (1.,0.,1.) |>.setId "point2",\n        circle (0.,1.) (.abs 0.1) |>.setStroke (0.,0.,0.) (.px 2) |>.setFill (1.,1.,0.) |>.setId "point3"] }', start=(13, 1), end=(20, 109), kind='commanddeclaration')]), PremiseF
ile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Jsx.lean'), imports=['.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean'], premises=[Prem
ise(full_name='htmlLetters', code='def htmlLetters : Array ProofWidgets.Html :=\n  #[\n    <span style={json% {color: "red"}}>H</span>,\n    <span style={json% {color: "yellow"}}>T</span>,\n    <span style={json% {col
or: "green"}}>M</span>,\n    <span style={json% {color: "blue"}}>L</span>\n  ]', start=(5, 1), end=(11, 4), kind='commanddeclaration'), Premise(full_name='x', code='def x := <b>You can use {...htmlLetters} {.text " "}
 in lean! {.text <| toString <| 4 + 5} <hr/> </b>', start=(13, 1), end=(13, 102), kind='commanddeclaration'), Premise(full_name='ghjk', code='theorem ghjk : True', start=(18, 1), end=(24, 10), kind='commanddeclaration
')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Conv.lean'), imports=['.lake/packages/proofwidgets/ProofWidgets/Data/Html.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/Mak
eEditLink.lean', '.lake/packages/proofwidgets/ProofWidgets/Component/Panel/Basic.lean', '.lake/packages/lean4/src/lean/Lean/Meta/ExprLens.lean', '.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/proofwidgets/
ProofWidgets/Component/OfRpcMethod.lean'], premises=[Premise(full_name='NewCursorPos', code='structure NewCursorPos where\n  newCursorPos? : Option Lsp.Position\n  uri? : Option String\n  deriving ToJson, FromJson', s
tart=(17, 1), end=(20, 28), kind='commanddeclaration'), Premise(full_name='SolveReturn', code='private structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat', start=(22, 1), end=(25
, 22), kind='commanddeclaration'), Premise(full_name='solveLevel', code='private def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := ex
pr\n    let mut count := 0\n    let mut explicitList := []\n\n    while descExp.isApp do\n      if (←Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n
  count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicit
List\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!
\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else muta
blePath.tail!\n\n    return { expr := nextExp, val? := toString count , listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! "no name found
"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! "no name found"\n    return { expr := b
, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { expr := b, val? := none, listRest := path }\n      | _ => return { expr := b.appFn!.appArg!, v
al? := none, listRest := path.tail!.tail! }\n\n  | _ => do\n    return { expr := ←(Lean.Core.viewSubexpr path.head! expr), val? := toString (path.head! + 1), listRest := path.tail! }', start=(27, 1), end=(81, 123), ki
nd='commanddeclaration'), Premise(full_name='reprint!', code='def reprint! (stx : Syntax) : String :=\n  match stx.reprint with\n    | some x => x\n    | none =>  panic! "Could not reprint syntax"', start=(84, 1), end
=(87, 49), kind='commanddeclaration'), Premise(full_name='LocateReturn', code='structure LocateReturn where\n  pathBeforeConv : List Nat\n  pathAfterConv : List Nat\n  deriving Inhabited', start=(89, 1), end=(92, 21),
 kind='commanddeclaration'), Premise(full_name='locate', code="private def locate (stx : Syntax) (pos : String.Pos) : LocateReturn := Id.run do\n  let mut t := Syntax.Traverser.fromSyntax stx\n  let mut path := []\n
let mut rangeList := []\n\n  while !t.cur.getArgs.isEmpty do\n    let mut args := t.cur.getArgs\n    let mut i := 0\n    let mut newT := t\n    let mut found := false\n    rangeList := []\n    for arg in args do\n
  let mut range := match arg.getRange? with\n        | some x => x\n        | none => { start := 0, stop := 0 }\n      rangeList := range::rangeList\n      if range.start < pos && pos <= range.stop then do\n        ne
wT := t.down i\n        path := i::path\n        found := true\n      i := i + 1\n    if !found then break\n    t := newT\n\n  let mut pathAfterConv := []\n  while !(t.cur.getKind == `Lean.Parser.Tactic.Conv.conv\n
   || t.cur.getKind == `Lean.Parser.Tactic.Conv.convConvSeq\n      || t.cur.getKind == `Lean.Widget.conv!)\n    && path.length > 0 do\n    t := t.up\n    pathAfterConv := path.head!::pathAfterConv\n    path := path.ta
il!\n\n  if pathAfterConv == [] || pathAfterConv.length == 1 then\n    pathAfterConv := [t.cur.getArgs.size - 2]\n\n  else if pathAfterConv.length == 3 then\n    let mut rangeList' := rangeList.reverse\n    let mut ct
r := 0\n    while rangeList'.head!.stop < pos do\n      ctr := ctr + 1\n      rangeList' := rangeList'.tail!\n    pathAfterConv := List.append pathAfterConv ((ctr-2)::[0])\n\n  return {pathBeforeConv := path.reverse,
pathAfterConv := pathAfterConv }", start=(94, 1), end=(142, 75), kind='commanddeclaration'), Premise(full_name='extractIndentation', code='private partial def extractIndentation (input : String) : String := match "  "
.isPrefixOf input with\n  | true => "  " ++ extractIndentation (input.drop 2)\n  | false => ""', start=(144, 1), end=(146, 16), kind='commanddeclaration'), Premise(full_name='InsertReturn', code='private structure Ins
ertReturn where\n  stx : Syntax\n  newPath : List Nat\n  newCursorPos : Lsp.Position', start=(148, 1), end=(151, 30), kind='commanddeclaration'), Premise(full_name='insertAfterArrow', code='private def insertAfterArro
w (stx : Syntax) (pathBeforeConvParam : List Nat) (pathAfterConvParam : List Nat) (value : String) (text : FileMap) : InsertReturn := Id.run do\n  let mut t := Syntax.Traverser.fromSyntax stx\n  let mut pathBeforeConv
 := pathBeforeConvParam\n  while pathBeforeConv.length > 0 do\n    t := t.down pathBeforeConv.head!\n    pathBeforeConv := pathBeforeConv.tail!\n  let mut pathAfterConv := pathAfterConvParam\n\nlet mut pathBeforeConv\
' := pathBeforeConvParam.reverse\n  let mut returnPath := []\n  for _ in [:4] do\n    t := t.up\n    returnPath := pathBeforeConv\'.head!::returnPath\n    pathBeforeConv\' := pathBeforeConv\'.tail!\n  t := t.up\n\n  l
et argNr := pathBeforeConv\'.head! - 1\n  let prevArg := reprint! t.cur.getArgs[argNr]!\n  let mut previousIndentation :=  extractIndentation (prevArg.splitOn "\\n").reverse.head!\n\n  t := t.down pathBeforeConv\'.hea
d!\n  while returnPath.length > 0 do\n    t := t.down returnPath.head!\n    returnPath := returnPath.tail!\n\n  let arrow := reprint! t.cur.getArgs[pathAfterConv.head!]!\n  let mut arrowIndentation := extractIndentati
on (arrow.splitOn "\\n").reverse.head!\n  let mut newCursorPos := match t.cur.getArgs[pathAfterConv.head!]!.getRange? with\n    | some range => text.utf8PosToLspPos range.stop\n    | none => text.utf8PosToLspPos 0\n\n
  let mut newNode := Syntax.missing\n  if reprint! t.cur.getArgs[pathAfterConv.head! + 1]! == "" || previousIndentation == arrowIndentation then\n    let newArrow := Syntax.atom (SourceInfo.original "".toSubstring 0 "
".toSubstring 0) "=>\\n"\n    t := t.setCur (t.cur.setArgs (List.append (t.cur.getArgs.toList.take pathAfterConv.head!) (newArrow::t.cur.getArgs.toList.drop (pathAfterConv.head! + 1))).toArray)\n    newNode := Syntax.
atom (SourceInfo.original "".toSubstring 0 "".toSubstring 0) ("  " ++ previousIndentation ++ value ++ "\\n" ++ arrowIndentation)\n    newCursorPos := { line := newCursorPos.line + 1, character := 2 + previousIndentati
on.length + value.length }\n  else\n    newNode := Syntax.atom (SourceInfo.original "".toSubstring 0 "".toSubstring 0) (value ++ "\\n" ++ arrowIndentation)\n    newCursorPos := { line := newCursorPos.line + 1, charact
er := arrowIndentation.length + value.length }\n\n  t := t.down (pathAfterConv.head! + 1)\n  t := t.down 0\n  t := t.down 0\n\n  let newArgList := newNode::t.cur.getArgs.toList\n  t := t.setCur (t.cur.setArgs newArgLi
st.toArray)\n  while t.parents.size > 0 do\n    t := t.up\n\n  let newPath := pathBeforeConvParam ++ (pathAfterConv.head! + 1)::0::0::[0]\n\n  return { stx := t.cur, newPath := newPath, newCursorPos }', start=(153, 1)
, end=(212, 60), kind='commanddeclaration'), Premise(full_name='insertAnywhereElse', code='private def insertAnywhereElse (stx : Syntax) (pathBeforeConvParam : List Nat) (pathAfterConvParam : List Nat) (value : String
) (text : FileMap): InsertReturn := Id.run do\n  let mut t := Syntax.Traverser.fromSyntax stx\n  let mut pathBeforeConv := pathBeforeConvParam\n  while pathBeforeConv.length > 0 do\n    t := t.down pathBeforeConv.head
!\n    pathBeforeConv := pathBeforeConv.tail!\n  let mut pathAfterConv := pathAfterConvParam\n\nlet nothingAfterConv := t.up.cur.getArgs.size - 1 == pathBeforeConvParam.reverse.head!\n\n  for _ in [:3] do\n    t := t.
down pathAfterConv.head!\n    pathAfterConv := pathAfterConv.tail!\n\n  let argAsString := reprint! t.cur.getArgs[pathAfterConv.head!]!\n  let mut newval := value\n  let mut entersMerged := false\n  if toString t.cur.
getArgs[pathAfterConv.head!]!.getKind == "Lean.Parser.Tactic.Conv.«convEnter[__]»" then\n    let mut additionalArgs := (argAsString.splitOn "\\n").head!\n    additionalArgs := (additionalArgs.drop "enter [".length).dr
opRight 1\n\n    let left := value.take "enter [".length\n    let right := value.drop "enter [".length\n    newval := left ++ additionalArgs ++ ", " ++ right\n    entersMerged := true\n\n  let mut newCursorPos := matc
h t.cur.getArgs[pathAfterConv.head!]!.getRange? with\n    | some range => text.utf8PosToLspPos range.stop\n    | none => text.utf8PosToLspPos 0\n\n  let mut argNr := pathAfterConv.head!\n  let mut indentation := ""\n
 if argNr == 0 then\n    indentation := extractIndentation ((reprint! t.up.up.up.cur).splitOn "\\n").tail!.head!\n  else\n    argNr := argNr - 2\n    let mut prevArg := reprint! t.cur.getArgs[argNr]!\n    let mut spli
t := prevArg.splitOn "\\n"\n    while split.length == 1 do\n      argNr := argNr + 2\n      prevArg := reprint! t.cur.getArgs[argNr]!\n      split := prevArg.splitOn "\\n"\n\n    let mut indentationLine := split.rever
se.head!\n    indentation := extractIndentation indentationLine\n\n  newCursorPos := match entersMerged with\n    | true => { line := newCursorPos.line, character := indentation.length + newval.length }\n    | false =
> { line := newCursorPos.line + 1, character := indentation.length + newval.length }\n\n  let mut frontIndentation := ""\n  if pathAfterConv.head! == t.cur.getArgs.size - 1 then\n    let lastArg := reprint! t.cur.getA
rgs[ t.cur.getArgs.size - 1]!\n    let mut lastArgIndentation := extractIndentation (lastArg.splitOn "\\n").reverse.head!\n    let numOfWhitespace := indentation.length - lastArgIndentation.length\n    for _ in [:numO
fWhitespace] do\n      frontIndentation := frontIndentation ++ " "\n    indentation := indentation.drop numOfWhitespace\n\n    let mut argList := []\n  if nothingAfterConv then\n    let mut adjustedLastLine := reprint
! t.cur.getArgs[t.cur.getArgs.size - 1]!\n    while adjustedLastLine.takeRight 1 == "\\n" do\n      adjustedLastLine := adjustedLastLine.dropRight 1\n    adjustedLastLine := adjustedLastLine ++ "\\n"\n    let adjusted
LastNode := Syntax.atom (SourceInfo.original "".toSubstring 0 "".toSubstring 0) adjustedLastLine\n    argList := (adjustedLastNode::t.cur.getArgs.toList.reverse.tail!).reverse\n  else\n    argList := t.cur.getArgs.toL
ist\n\n  let newNode := match entersMerged with\n    | true => Syntax.atom (SourceInfo.original "".toSubstring 0 "".toSubstring 0) (newval ++ "\\n" ++ indentation)\n    | false => Syntax.atom (SourceInfo.original "".t
oSubstring 0 "".toSubstring 0) (frontIndentation ++ newval ++ "\\n" ++ indentation)\n  let newArgList := match entersMerged with\n    | true => List.append (argList.take (pathAfterConv.head!) ) (newNode::(argList.drop
 (pathAfterConv.head! + 1)))\n    | false => List.append (argList.take (pathAfterConv.head! + 1) ) (newNode::(argList.drop (pathAfterConv.head! + 1)))\n  let newPath := match entersMerged with\n    | true => pathBefor
eConvParam ++ (pathAfterConvParam.take 4)\n    | false => pathBeforeConvParam ++ (pathAfterConvParam.take 3) ++ [(pathAfterConvParam.get! 3) + 2]\n\n  t := t.setCur (t.cur.setArgs newArgList.toArray)\n  while t.parent
s.size > 0 do\n    t := t.up\n\n  return { stx := t.cur, newPath := newPath, newCursorPos := newCursorPos }', start=(214, 1), end=(309, 76), kind='commanddeclaration'), Premise(full_name='syntaxInsert', code='private
def syntaxInsert (stx : Syntax) (pathBeforeConvParam : List Nat) (pathAfterConvParam : List Nat) (value : String) (text : FileMap): InsertReturn := Id.run do\n  if value == "" then return { stx := stx, newPath := path
BeforeConvParam ++ pathAfterConvParam, newCursorPos := {line := 0, character := 0} }\n  if pathAfterConvParam.length == 1 then\n    return insertAfterArrow stx pathBeforeConvParam pathAfterConvParam value text\n  else
\n    return insertAnywhereElse stx pathBeforeConvParam pathAfterConvParam value text', start=(311, 1), end=(316, 84), kind='commanddeclaration'), Premise(full_name='InsertEnterResponse', code='structure InsertEnterRe
sponse where\n  \n  label : String\n  edit : Lsp.TextDocumentEdit\n  \n  newCursorPos : Lsp.Position\n  deriving FromJson, ToJson', start=(318, 1), end=(324, 28), kind='commanddeclaration'), Premise(full_name='insertE
nter', code='def insertEnter (subexprPos : SubExpr.Pos) (goalType : Expr) (cmdStx : Syntax)\n    (cursorPos : String.Pos) (doc : Lean.Server.FileWorker.EditableDocument) : MetaM InsertEnterResponse := do\n  let mut li
st := (SubExpr.Pos.toArray subexprPos).toList\n  let mut expr := goalType\n  let mut retList := []\n  while !list.isEmpty do\n    let res ← solveLevel expr list\n    expr := res.expr\n    retList := match res.val? wit
h\n      | none => retList\n      | some val => val::retList\n    list := res.listRest\n\n  retList := List.reverse retList\n  let mut enterval := "enter " ++ toString retList\n  if enterval.contains \'0\' then enterv
al := "Error: Not a valid conv target"\n  if retList.isEmpty then enterval := ""\n\n  let range := match cmdStx.getRange? with\n    | some x => x\n    | none => panic! "could not get range"\n\n  let text := doc.meta.t
ext\n\n  let located := locate cmdStx { byteIdx := (min cursorPos.byteIdx range.stop.byteIdx) }\n  let inserted := syntaxInsert cmdStx located.pathBeforeConv located.pathAfterConv enterval text\n  let mut newSyntax :=
 reprint! inserted.stx\n\n  let mut syntaxAsList := newSyntax.data.reverse\n  while syntaxAsList.head! == \'\\n\' || syntaxAsList.head! == \' \' do\n    newSyntax := newSyntax.dropRight 1\n    syntaxAsList := syntaxAs
List.tail!\n\n  let textEdit : Lsp.TextEdit := { range := { start := text.utf8PosToLspPos range.start, «end» := text.utf8PosToLspPos { byteIdx := range.stop.byteIdx } }, newText := newSyntax }\n  let edit : Lsp.TextDo
cumentEdit := { textDocument := { uri := doc.meta.uri, version? := doc.meta.version }, edits := [textEdit].toArray }\n\n  return { label := enterval, edit, newCursorPos := inserted.newCursorPos }', start=(326, 1), end
=(367, 76), kind='commanddeclaration'), Premise(full_name='ConvButtonProps', code='structure ConvButtonProps where\n  pos : Lsp.Position\n  goal : Widget.InteractiveGoal\n  loc : SubExpr.GoalLocation\n  deriving RpcEn
codable', start=(373, 1), end=(377, 24), kind='commanddeclaration'), Premise(full_name='ConvButton.rpc', code='@[server_rpc_method]\ndef ConvButton.rpc (props : ConvButtonProps) : RequestM (RequestTask Html) :=\n  Req
uestM.withWaitFindSnapAtPos props.pos fun snap => do\n    if props.goal.goalPrefix != "| " then\n      throw $ .invalidParams s!"The current goal is not a conv goal."\n    let .target subexprPos := props.loc\n      |
throw $ .invalidParams s!"Select something in the target type."\n    let doc ← RequestM.readDoc\n    let cursorPos := doc.meta.text.lspPosToUtf8Pos props.pos\n    props.goal.ctx.val.runMetaM {} do\n      let md ← prop
s.goal.mvarId.getDecl\n      let lctx := md.lctx |>.sanitizeNames.run\' {options := (← getOptions)}\n      Meta.withLCtx lctx md.localInstances do\n        let resp ← insertEnter subexprPos md.type snap.stx cursorPos
doc\n        return <div><MakeEditLink\n            edit={resp.edit}\n            newSelection?={some ⟨resp.newCursorPos, resp.newCursorPos⟩}\n            title?={resp.label}\n          >\n            {.text resp.labe
l}\n          </MakeEditLink></div>', start=(380, 1), end=(400, 32), kind='commanddeclaration'), Premise(full_name='ConvButton', code='@[widget_module]\ndef ConvButton : Component ConvButtonProps :=\n  mk_rpc_widget%
ConvButton.rpc', start=(402, 1), end=(404, 32), kind='commanddeclaration'), Premise(full_name='findGoalForLocation', code='def findGoalForLocation (goals : Array Widget.InteractiveGoal) (loc : SubExpr.GoalsLocation) :
\n    Option Widget.InteractiveGoal :=\n  goals.find? (·.mvarId == loc.mvarId)', start=(406, 1), end=(408, 39), kind='commanddeclaration'), Premise(full_name='ConvPanel.rpc', code='@[server_rpc_method]\ndef ConvPanel.
rpc (props : PanelWidgetProps) : RequestM (RequestTask Html) :=\n  RequestM.asTask do\n    let inner : Html ← (do\n      if props.selectedLocations.isEmpty then\n        return <span>No actions available. You can use
shift-click to select an expression in the goal state.</span>\n      let buttons : Array Html ← props.selectedLocations.mapM fun loc => do\n        let some g := findGoalForLocation props.goals loc\n          | throw
$ .invalidParams s!"could not find goal for location {toJson loc}"\n        return <ConvButton pos={props.pos} goal={g} loc={loc.loc} />\n      return Html.element "div" #[] buttons)\n    return <details «open»={true}
>\n        <summary className="mv2 pointer">Conv 🔍</summary>\n        <div className="ml1">{inner}</div>\n      </details>', start=(411, 1), end=(425, 17), kind='commanddeclaration'), Premise(full_name='ConvPanel', c
ode='@[widget_module]\ndef ConvPanel : Component PanelWidgetProps :=\n  mk_rpc_widget% ConvPanel.rpc', start=(427, 1), end=(429, 31), kind='commanddeclaration'), Premise(full_name='test_sorry', code='axiom test_sorry
{α} : α', start=(434, 1), end=(434, 25), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Rubiks.lean'), imports=['.lake/packages/lean4/src/lean/Init.lean', '.la
ke/packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean'], premises=[Premise(full_name='RubiksProps', code='structure RubiksProps where\n  seq : Array String := #[]\n  deriving ToJson, FromJson, Inhabited', s
tart=(6, 1), end=(8, 39), kind='commanddeclaration'), Premise(full_name='Rubiks', code='@[widget_module]\ndef Rubiks : Component RubiksProps where\n  javascript := include_str ".." / ".." / ".lake" / "build" / "js" /
"rubiks.js"', start=(10, 1), end=(12, 81), kind='commanddeclaration'), Premise(full_name='eg', code='def eg := #["L", "L", "D⁻¹", "U⁻¹", "L", "D", "D", "L", "U⁻¹", "R", "D", "F", "F", "D"]', start=(14, 1), end=(14, 88
), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Main.lean'), imports=['.lake/packages/lean4/src/lean/Init.lean', '.lake/packages/lean4/src/lean/lake/Lake.lean', '.l
ake/packages/lean4/src/lean/lake/Lake/CLI.lean'], premises=[Premise(full_name='main', code='def main (args : List String) : IO UInt32 := do\n  Lake.cli args', start=(9, 1), end=(10, 16), kind='commanddeclaration')]),
PremiseFile(path=PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/MVarRenaming.lean'), imports=['.lake/packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean'], premises=[Premise(full_name='Lean.Meta.MVarRenaming'
, code='structure MVarRenaming where\n  map : MVarIdMap MVarId := {}', start=(11, 1), end=(13, 31), kind='commanddeclaration'), Premise(full_name='Lean.Meta.MVarRenaming.isEmpty', code='def MVarRenaming.isEmpty (s : M
VarRenaming) : Bool :=\n  s.map.isEmpty', start=(15, 1), end=(16, 16), kind='commanddeclaration'), Premise(full_name='Lean.Meta.MVarRenaming.find?', code='def MVarRenaming.find? (s : MVarRenaming) (mvarId : MVarId) :
Option MVarId :=\n  s.map.find? mvarId', start=(18, 1), end=(19, 21), kind='commanddeclaration'), Premise(full_name='Lean.Meta.MVarRenaming.find!', code='def MVarRenaming.find! (s : MVarRenaming) (mvarId : MVarId) : M
VarId :=\n  (s.find? mvarId).get!', start=(21, 1), end=(22, 24), kind='commanddeclaration'), Premise(full_name='Lean.Meta.MVarRenaming.insert', code="def MVarRenaming.insert (s : MVarRenaming) (mvarId mvarId' : MVarId
) : MVarRenaming :=\n  { s with map := s.map.insert mvarId mvarId' }", start=(24, 1), end=(25, 48), kind='commanddeclaration'), Premise(full_name='Lean.Meta.MVarRenaming.apply', code='def MVarRenaming.apply (s : MVarR
enaming) (e : Expr) : Expr :=\n  if !e.hasMVar then e\n  else if s.map.isEmpty then e\n  else e.replace fun e => match e with\n    | Expr.mvar mvarId => match s.map.find? mvarId with\n      | none           => e\n
  | some newMVarId => mkMVar newMVarId\n    | _ => none', start=(27, 1), end=(34, 16), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/MatcherApp.lean'), imports
=['.lake/packages/lean4/src/lean/Lean/Meta/Match/MatcherApp/Basic.lean', '.lake/packages/lean4/src/lean/Lean/Meta/Match/MatcherApp/Transform.lean'], premises=[]), PremiseFile(path=PosixPath('.lake/packages/lean4/src/l
ean/Lean/Compiler/IR/EmitLLVM.lean'), imports=['.lake/packages/lean4/src/lean/Lean/Compiler/NameMangling.lean', '.lake/packages/lean4/src/lean/Lean/Data/HashMap.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/IR/E
mitUtil.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/InitAttr.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/IR/NormIds.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/IR/SimpCase.lean', '.lake/package
s/lean4/src/lean/Lean/Compiler/IR/ResetReuse.lean', '.lake/packages/lean4/src/lean/Lean/Runtime.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/ExportAttr.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/IR/Com
pilerM.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/IR/LLVMBindings.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/IR/Boxing.lean'], premises=[Premise(full_name='Lean.IR.leanMainFn', code='def leanMainFn :
= "_lean_main"', start=(24, 1), end=(24, 31), kind='commanddeclaration'), Premise(full_name='Lean.IR.LLVM.size_tType', code='def size_tType (llvmctx : LLVM.Context) : BaseIO (LLVM.LLVMType llvmctx) :=\n  LLVM.i64Type
llvmctx', start=(28, 1), end=(29, 23), kind='commanddeclaration'), Premise(full_name='Lean.IR.LLVM.unsignedType', code='def unsignedType (llvmctx : LLVM.Context) : BaseIO (LLVM.LLVMType llvmctx) :=\n  LLVM.i32Type llv
mctx', start=(32, 1), end=(33, 23), kind='commanddeclaration'), Premise(full_name='Lean.IR.LLVM.getOrAddFunction', code='def getOrAddFunction (m : LLVM.Module ctx) (name : String) (type : LLVM.LLVMType ctx) : BaseIO (
LLVM.Value ctx) :=  do\n  match (← LLVM.getNamedFunction m name) with\n  | some fn => return fn\n  | none =>\n    \n    let fn ← LLVM.addFunction m name type\n    let attr ← LLVM.createStringAttribute "probe-stack" "i
nline-asm"\n    LLVM.addAttributeAtIndex fn LLVM.AttributeIndex.AttributeFunctionIndex attr\n    return fn', start=(36, 1), end=(48, 14), kind='commanddeclaration'), Premise(full_name='Lean.IR.LLVM.getOrAddGlobal', co
de='def getOrAddGlobal (m : LLVM.Module ctx) (name : String) (type : LLVM.LLVMType ctx) : BaseIO (LLVM.Value ctx) :=  do\n  match (← LLVM.getNamedGlobal m name) with\n  | .some fn => return fn\n  | .none => LLVM.addGl
obal m name type', start=(50, 1), end=(53, 40), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.Context', code='structure Context (llvmctx : LLVM.Context) where\n  env        : Environment\n  modName
  : Name\n  jpMap      : JPParamsMap := {}\n  mainFn     : FunId := default\n  mainParams : Array Param := #[]\n  llvmmodule : LLVM.Module llvmctx', start=(59, 1), end=(65, 35), kind='commanddeclaration'), Premise(ful
l_name='Lean.IR.EmitLLVM.State', code='structure State (llvmctx : LLVM.Context) where\n  var2val : HashMap VarId (LLVM.LLVMType llvmctx × LLVM.Value llvmctx)\n  jp2bb   : HashMap JoinPointId (LLVM.BasicBlock llvmctx)'
, start=(67, 1), end=(69, 58), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.Error', code='abbrev Error := String', start=(71, 1), end=(71, 23), kind='commanddeclaration'), Premise(full_name='Lean.IR
.EmitLLVM.M', code='abbrev M (llvmctx : LLVM.Context) :=\n  StateRefT (State llvmctx) (ReaderT (Context llvmctx) (ExceptT Error IO))', start=(73, 1), end=(74, 75), kind='commanddeclaration'), Premise(full_name='Lean.I
R.EmitLLVM.addVartoState', code='def addVartoState (x : VarId) (v : LLVM.Value llvmctx) (ty : LLVM.LLVMType llvmctx) : M llvmctx Unit := do\n  modify (fun s => { s with var2val := s.var2val.insert x (ty, v) })', start
=(79, 1), end=(80, 69), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.addJpTostate', code='def addJpTostate (jp : JoinPointId) (bb : LLVM.BasicBlock llvmctx) : M llvmctx Unit :=\n  modify (fun s => {
 s with jp2bb := s.jp2bb.insert jp bb })', start=(82, 1), end=(83, 61), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitJp', code='def emitJp (jp : JoinPointId) : M llvmctx (LLVM.BasicBlock llvmctx
) := do\n  let state ← get\n  match state.jp2bb.find? jp with\n  | .some bb => return bb\n  | .none => throw s!"unable to find join point {jp}"', start=(85, 1), end=(89, 54), kind='commanddeclaration'), Premise(full_n
ame='Lean.IR.EmitLLVM.getLLVMModule', code='def getLLVMModule : M llvmctx (LLVM.Module llvmctx) := Context.llvmmodule <$> read', start=(91, 1), end=(91, 83), kind='commanddeclaration'), Premise(full_name='Lean.IR.Emit
LLVM.getEnv', code='def getEnv : M llvmctx Environment := Context.env <$> read', start=(93, 1), end=(93, 59), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.getModName', code='def getModName : M llvmc
tx  Name := Context.modName <$> read', start=(95, 1), end=(95, 61), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.getDecl', code='def getDecl (n : Name) : M llvmctx Decl := do\n  let env ← getEnv\n
match findEnvDecl env n with\n  | some d => pure d\n  | none   => throw s!"unknown declaration {n}"', start=(97, 1), end=(101, 48), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.constInt8', code='def
 constInt8 (n : Nat) : M llvmctx (LLVM.Value llvmctx) :=  do\n    LLVM.constInt8 llvmctx (UInt64.ofNat n)', start=(103, 1), end=(104, 44), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.constInt64', c
ode='def constInt64 (n : Nat) : M llvmctx (LLVM.Value llvmctx) :=  do\n    LLVM.constInt64 llvmctx (UInt64.ofNat n)', start=(106, 1), end=(107, 45), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.cons
tIntSizeT', code='def constIntSizeT (n : Nat) : M llvmctx (LLVM.Value llvmctx) :=  do\n    LLVM.constIntSizeT llvmctx (UInt64.ofNat n)', start=(109, 1), end=(110, 48), kind='commanddeclaration'), Premise(full_name='Le
an.IR.EmitLLVM.constIntUnsigned', code='def constIntUnsigned (n : Nat) : M llvmctx (LLVM.Value llvmctx) :=  do\n    LLVM.constIntUnsigned llvmctx (UInt64.ofNat n)', start=(112, 1), end=(113, 51), kind='commanddeclarat
ion'), Premise(full_name='Lean.IR.EmitLLVM.getOrCreateFunctionPrototype', code='def getOrCreateFunctionPrototype (mod : LLVM.Module llvmctx)\n    (retty : LLVM.LLVMType llvmctx) (name : String) (args : Array (LLVM.LLV
MType llvmctx)) : M llvmctx  (LLVM.Value llvmctx) := do\n  LLVM.getOrAddFunction mod name $ ← LLVM.functionType retty args (isVarArg := false)', start=(115, 1), end=(117, 86), kind='commanddeclaration'), Premise(full_
name='Lean.IR.EmitLLVM.callLeanBox', code='def callLeanBox (builder : LLVM.Builder llvmctx)\n    (arg : LLVM.Value llvmctx) (name : String := "") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  "lean_box"\n
let retty ← LLVM.voidPtrType llvmctx\n  let argtys := #[ ← LLVM.size_tType llvmctx ]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.
buildCall2 builder fnty fn  #[arg] name', start=(119, 1), end=(126, 47), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanMarkPersistentFn', code='def callLeanMarkPersistentFn (builder : LLVM.Bu
ilder llvmctx) (arg : LLVM.Value llvmctx) : M llvmctx  Unit := do\n  let fnName :=  "lean_mark_persistent"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx ]\n  let fn ← getOrCreateF
unctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ←   LLVM.buildCall2 builder fnty fn  #[arg]', start=(128, 1), end=(134, 52), kind='commanddeclaration'), Pre
mise(full_name='Lean.IR.EmitLLVM.RefcountKind', code='inductive RefcountKind where\n  | inc | dec', start=(137, 1), end=(138, 14), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanRefcountFn', c
ode='def callLeanRefcountFn (builder : LLVM.Builder llvmctx)\n    (kind : RefcountKind) (checkRef? : Bool) (arg : LLVM.Value llvmctx)\n    (delta : Option (LLVM.Value llvmctx) := Option.none) : M llvmctx Unit := do\n
 let fnName :=  s!"lean_{kind}{if checkRef? then "" else "_ref"}{if delta.isNone then "" else "_n"}"\n  let retty ← LLVM.voidType llvmctx\n  let argtys ← if delta.isNone then pure #[← LLVM.voidPtrType llvmctx] else pu
re #[← LLVM.voidPtrType llvmctx, ← LLVM.size_tType llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  match delta with\n  | .none =>
 do\n    let _ ← LLVM.buildCall2 builder fnty fn #[arg]\n  | .some n => do\n    let _ ← LLVM.buildCall2 builder fnty fn #[arg, n]', start=(145, 1), end=(158, 54), kind='commanddeclaration'), Premise(full_name='Lean.IR
.EmitLLVM.callLeanDecRef', code='def callLeanDecRef (builder : LLVM.Builder llvmctx) (res : LLVM.Value llvmctx) : M llvmctx Unit := do\n  let fnName :=  "lean_dec_ref"\n  let retty ← LLVM.voidType llvmctx\n  let argty
s := #[ ← LLVM.i8PtrType llvmctx ]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn  #[res]', start
=(163, 1), end=(169, 50), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanUnsignedToNatFn', code='def callLeanUnsignedToNatFn (builder : LLVM.Builder llvmctx)\n    (n : Nat) (name : String := "
") : M llvmctx (LLVM.Value llvmctx) := do\n  let mod ← getLLVMModule\n  let argtys := #[← LLVM.i32Type llvmctx]\n  let retty ← LLVM.voidPtrType llvmctx\n  let f ←   getOrCreateFunctionPrototype mod retty "lean_unsigne
d_to_nat"  argtys\n  let fnty ← LLVM.functionType retty argtys\n  let nv ← constIntUnsigned n\n  LLVM.buildCall2 builder fnty f #[nv] name', start=(171, 1), end=(179, 44), kind='commanddeclaration'), Premise(full_name
='Lean.IR.EmitLLVM.callLeanMkStringFromBytesFn', code='def callLeanMkStringFromBytesFn (builder : LLVM.Builder llvmctx)\n    (strPtr nBytes : LLVM.Value llvmctx) (name : String) : M llvmctx (LLVM.Value llvmctx) := do\
n  let fnName :=  "lean_mk_string_from_bytes"\n  let retty ← LLVM.voidPtrType llvmctx\n  let argtys :=  #[← LLVM.voidPtrType llvmctx, ← LLVM.size_tType llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModul
e) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[strPtr, nBytes] name', start=(181, 1), end=(188, 57), kind='commanddeclaration'), Premise(full_name='Lean.IR.Emi
tLLVM.callLeanMkString', code='def callLeanMkString (builder : LLVM.Builder llvmctx)\n    (strPtr : LLVM.Value llvmctx) (name : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let retty ← LLVM.voidPtrType llvmctx\n
 let argtys :=  #[← LLVM.voidPtrType llvmctx]\n  let fn ←  getOrCreateFunctionPrototype (← getLLVMModule) retty "lean_mk_string" argtys\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #
[strPtr] name', start=(190, 1), end=(196, 49), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanCStrToNatFn', code='def callLeanCStrToNatFn (builder : LLVM.Builder llvmctx)\n    (n : Nat) (name
: String := "") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  "lean_cstr_to_nat"\n  let retty ← LLVM.voidPtrType llvmctx\n  let argtys :=  #[← LLVM.voidPtrType llvmctx]\n  let fn ← getOrCreateFunctionProtot
ype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let s ← LLVM.buildGlobalString builder (value := toString n)\n  LLVM.buildCall2 builder fnty fn #[s] name', start=(198, 1), end
=(206, 44), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanIOMkWorld', code='def callLeanIOMkWorld (builder : LLVM.Builder llvmctx) : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  "le
an_io_mk_world"\n  let retty ← LLVM.voidPtrType llvmctx\n  let argtys :=  #[]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCa
ll2 builder fnty fn #[] "mk_io_out"', start=(208, 1), end=(214, 50), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanIOResultIsError', code='def callLeanIOResultIsError (builder : LLVM.Builder
llvmctx)\n    (arg : LLVM.Value llvmctx) (name : String := "") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  "lean_io_result_is_error"\n  let retty ← LLVM.i1Type llvmctx\n  let argtys :=  #[← LLVM.voidPtrTy
pe llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[arg] name', start=(216, 1), end=(223, 46), k
ind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanAllocCtor', code='def callLeanAllocCtor (builder : LLVM.Builder llvmctx)\n    (tag num_objs scalar_sz : Nat) (name : String := "") : M llvmctx (LL
VM.Value llvmctx) := do\n  let fnName :=  "lean_alloc_ctor"\n  let retty ← LLVM.voidPtrType llvmctx\n  let i32 ← LLVM.i32Type llvmctx\n  let argtys :=  #[i32, i32, i32]\n  let fn ← getOrCreateFunctionPrototype (← getL
LVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n\n  let tag ← constIntUnsigned tag\n  let num_objs ← constIntUnsigned num_objs\n  let scalar_sz ← constIntUnsigned scalar_sz\n  LLVM.buildCa
ll2 builder fnty fn #[tag, num_objs, scalar_sz] name', start=(225, 1), end=(237, 67), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanCtorSet', code='def callLeanCtorSet (builder : LLVM.Builder
 llvmctx)\n    (o i v : LLVM.Value llvmctx) : M llvmctx Unit := do\n  let fnName := "lean_ctor_set"\n  let retty ← LLVM.voidType llvmctx\n  let voidptr ← LLVM.voidPtrType llvmctx\n  let unsigned ← LLVM.unsignedType ll
vmctx\n  let argtys :=  #[voidptr, unsigned, voidptr]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  _ <- LLVM.buildCall2 builder fnty fn
  #[o, i, v]', start=(239, 1), end=(248, 51), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanIOResultMKOk', code='def callLeanIOResultMKOk (builder : LLVM.Builder llvmctx)\n    (v : LLVM.Value
 llvmctx) (name : String := "") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  "lean_io_result_mk_ok"\n  let voidptr ← LLVM.voidPtrType llvmctx\n  let retty := voidptr\n  let argtys :=  #[voidptr]\n  let fn
← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[v] name', start=(250, 1), end=(258, 44), kind='commanddeclaration'
), Premise(full_name='Lean.IR.EmitLLVM.callLeanAllocClosureFn', code='def callLeanAllocClosureFn (builder : LLVM.Builder llvmctx)\n    (f arity nys : LLVM.Value llvmctx) (retName : String := "") : M llvmctx (LLVM.Valu
e llvmctx) := do\n  let fnName :=  "lean_alloc_closure"\n  let retty ← LLVM.voidPtrType llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx, ← LLVM.unsignedType llvmctx, ← LLVM.unsignedType llvmctx]\n  let fn ← get
OrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn  #[f, arity, nys] retName', start=(260, 1), end=(267, 60), kind='commandd
eclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanClosureSetFn', code='def callLeanClosureSetFn (builder : LLVM.Builder llvmctx)\n    (closure ix arg : LLVM.Value llvmctx) (retName : String := "") : M llvmctx
Unit := do\n  let fnName :=  "lean_closure_set"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx, ← LLVM.unsignedType llvmctx, ← LLVM.voidPtrType llvmctx]\n  let fn ← getOrCreateFunc
tionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn  #[closure, ix, arg] retName', start=(269, 1), end=(276, 71), kind='commandde
claration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanObjTag', code='def callLeanObjTag (builder : LLVM.Builder llvmctx)\n    (closure : LLVM.Value llvmctx) (retName : String := "") : M llvmctx (LLVM.Value llvmctx)
 := do\n  let fnName :=  "lean_obj_tag"\n  let retty ← LLVM.i32Type llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ←
LLVM.functionType retty argtys\n  let out ← LLVM.buildCall2 builder fnty fn  #[closure] retName\n  LLVM.buildSextOrTrunc builder out (← LLVM.i64Type llvmctx)', start=(278, 1), end=(286, 61), kind='commanddeclaration')
, Premise(full_name='Lean.IR.EmitLLVM.callLeanIOResultGetValue', code='def callLeanIOResultGetValue (builder : LLVM.Builder llvmctx)\n    (v : LLVM.Value llvmctx) (name : String := "") : M llvmctx (LLVM.Value llvmctx)
 := do\n  let fnName :=  "lean_io_result_get_value"\n  let retty ← LLVM.voidPtrType llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argty
s\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[v] name', start=(288, 1), end=(295, 44), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanCtorRelease', code='
def callLeanCtorRelease (builder : LLVM.Builder llvmctx)\n    (closure i : LLVM.Value llvmctx) (retName : String := "") : M llvmctx Unit := do\n  let fnName :=  "lean_ctor_release"\n  let retty ← LLVM.voidType llvmctx
\n  let argtys := #[ ← LLVM.voidPtrType llvmctx, ← LLVM.unsignedType llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM
.buildCall2 builder fnty fn  #[closure, i] retName', start=(297, 1), end=(304, 65), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanCtorSetTag', code='def callLeanCtorSetTag (builder : LLVM.Bui
lder llvmctx)\n    (closure i : LLVM.Value llvmctx) (retName : String := "") : M llvmctx Unit := do\n  let fnName :=  "lean_ctor_set_tag"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llv
mctx, ← LLVM.i8Type llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn  #[closure, i] retNam
e', start=(306, 1), end=(313, 65), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.toLLVMType', code='def toLLVMType (t : IRType) : M llvmctx (LLVM.LLVMType llvmctx) := do\n  match t with\n  | IRType.f
loat      => LLVM.doubleTypeInContext llvmctx\n  | IRType.uint8      => LLVM.intTypeInContext llvmctx 8\n  | IRType.uint16     => LLVM.intTypeInContext llvmctx 16\n  | IRType.uint32     => LLVM.intTypeInContext llvmct
x 32\n  | IRType.uint64     => LLVM.intTypeInContext llvmctx 64\n  | IRType.usize      => LLVM.size_tType llvmctx\n  | IRType.object     => do LLVM.pointerType (← LLVM.i8Type llvmctx)\n  | IRType.tobject    => do LLVM
.pointerType (← LLVM.i8Type llvmctx)\n  | IRType.irrelevant => do LLVM.pointerType (← LLVM.i8Type llvmctx)\n  | IRType.struct _ _ => panic! "not implemented yet"\n  | IRType.union _ _  => panic! "not implemented yet"'
, start=(315, 1), end=(328, 54), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.throwInvalidExportName', code='def throwInvalidExportName {α : Type} (n : Name) : M llvmctx α := do\n  throw s!"invalid
export name {n.toString}"', start=(330, 1), end=(331, 45), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.toCName', code='def toCName (n : Name) : M llvmctx String := do\n  match getExportNameFor? (←
getEnv) n with\n  | some (.str .anonymous s) => pure s\n  | some _                   => throwInvalidExportName n\n  | none                     => if n == `main then pure leanMainFn else pure n.mangle', start=(333, 1),
 end=(337, 86), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.toCInitName', code='def toCInitName (n : Name) : M llvmctx String := do\n  match getExportNameFor? (← getEnv) n with\n  | some (.str .ano
nymous s) => return "_init_" ++ s\n  | some _                   => throwInvalidExportName n\n  | none                     => pure ("_init_" ++ n.mangle)', start=(339, 1), end=(343, 60), kind='commanddeclaration'), Pre
mise(full_name='Lean.IR.EmitLLVM.ShouldForwardControlFlow', code='inductive ShouldForwardControlFlow where\n| yes | no', start=(345, 1), end=(352, 11), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.b
uilderGetInsertionFn', code='def builderGetInsertionFn (builder : LLVM.Builder llvmctx) : M llvmctx (LLVM.Value llvmctx) := do\n  let builderBB ← LLVM.getInsertBlock builder\n  LLVM.getBasicBlockParent builderBB', sta
rt=(355, 1), end=(357, 37), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.builderAppendBasicBlock', code='def builderAppendBasicBlock (builder : LLVM.Builder llvmctx) (name : String) : M llvmctx (LLV
M.BasicBlock llvmctx) := do\n  let fn ← builderGetInsertionFn builder\n  LLVM.appendBasicBlockInContext llvmctx fn name', start=(359, 1), end=(361, 49), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.
buildPrologueAlloca', code='def buildPrologueAlloca (builder : LLVM.Builder llvmctx) (ty : LLVM.LLVMType llvmctx) (name : @&String := "") : M llvmctx (LLVM.Value llvmctx) := do\n  let origBB ← LLVM.getInsertBlock buil
der\n\n  let fn ← builderGetInsertionFn builder\n  if (← LLVM.countBasicBlocks fn) == 0 then\n    throw "Attempt to obtain first BB of function without BBs"\n\n  let entryBB ← LLVM.getEntryBasicBlock fn\n  match ← LLV
M.getFirstInstruction entryBB with\n  | some instr => LLVM.positionBuilderBefore builder instr\n  | none => LLVM.positionBuilderAtEnd builder entryBB\n\n  let alloca ← LLVM.buildAlloca builder ty name\n  LLVM.position
BuilderAtEnd builder origBB\n  return alloca', start=(363, 1), end=(385, 16), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.buildWhile_', code='def buildWhile_ (builder : LLVM.Builder llvmctx) (name
: String)\n    (condcodegen : LLVM.Builder llvmctx → M llvmctx (LLVM.Value llvmctx))\n    (bodycodegen : LLVM.Builder llvmctx → M llvmctx Unit) : M llvmctx Unit := do\n  let fn ← builderGetInsertionFn builder\n\n  let
 nameHeader := name ++ "header"\n  let nameBody := name ++ "body"\n  let nameMerge := name ++ "merge"\n\n  let headerbb ← LLVM.appendBasicBlockInContext llvmctx fn nameHeader\n  let _ ← LLVM.buildBr builder headerbb\n
\n  let bodybb ← LLVM.appendBasicBlockInContext llvmctx fn nameBody\n  let mergebb ← LLVM.appendBasicBlockInContext llvmctx fn nameMerge\n\n  LLVM.positionBuilderAtEnd builder headerbb\n  let cond ← condcodegen builde
r\n  let _ ← LLVM.buildCondBr builder cond bodybb mergebb\n\n  LLVM.positionBuilderAtEnd builder bodybb\n  bodycodegen builder\n  let _ ← LLVM.buildBr builder headerbb\n\n  LLVM.positionBuilderAtEnd builder mergebb',
start=(388, 1), end=(415, 44), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.buildIfThen_', code='def buildIfThen_ (builder : LLVM.Builder llvmctx) (name : String) (brval : LLVM.Value llvmctx)\n    (
thencodegen : LLVM.Builder llvmctx → M llvmctx ShouldForwardControlFlow) : M llvmctx Unit := do\n  let fn ← builderGetInsertionFn builder\n\n  let nameThen := name ++ "Then"\n  let nameElse := name ++ "Else"\n  let na
meMerge := name ++ "Merge"\n\n  let thenbb ← LLVM.appendBasicBlockInContext llvmctx fn nameThen\n  let elsebb ← LLVM.appendBasicBlockInContext llvmctx fn nameElse\n  let mergebb ← LLVM.appendBasicBlockInContext llvmct
x fn nameMerge\n  let _ ← LLVM.buildCondBr builder brval thenbb elsebb\n  LLVM.positionBuilderAtEnd builder thenbb\n  let fwd? ← thencodegen builder\n  match fwd? with\n  | .yes => let _ ← LLVM.buildBr builder mergebb
\n  | .no => pure ()\n  LLVM.positionBuilderAtEnd builder elsebb\n  let _ ← LLVM.buildBr builder mergebb\n  LLVM.positionBuilderAtEnd builder mergebb', start=(419, 1), end=(441, 44), kind='commanddeclaration'), Premis
e(full_name='Lean.IR.EmitLLVM.buildIfThenElse_', code='def buildIfThenElse_ (builder : LLVM.Builder llvmctx)  (name : String) (brval : LLVM.Value llvmctx)\n    (thencodegen : LLVM.Builder llvmctx → M llvmctx ShouldFor
wardControlFlow)\n    (elsecodegen : LLVM.Builder llvmctx → M llvmctx ShouldForwardControlFlow) : M llvmctx Unit := do\n  let fn ← LLVM.getBasicBlockParent (← LLVM.getInsertBlock builder)\n  let thenbb ← LLVM.appendBa
sicBlockInContext llvmctx fn (name ++ "Then")\n  let elsebb ← LLVM.appendBasicBlockInContext llvmctx fn (name ++ "Else")\n  let mergebb ← LLVM.appendBasicBlockInContext llvmctx fn (name ++ "Merge")\n  let _ ← LLVM.bui
ldCondBr builder brval thenbb elsebb\n  LLVM.positionBuilderAtEnd builder thenbb\n  let fwd? ← thencodegen builder\n  match fwd? with\n  | .yes => let _ ← LLVM.buildBr builder mergebb\n  | .no => pure ()\n  LLVM.posit
ionBuilderAtEnd builder elsebb\n  let fwd? ← elsecodegen builder\n  match fwd? with\n  | .yes => let _ ← LLVM.buildBr builder mergebb\n  | .no => pure ()\n  LLVM.positionBuilderAtEnd builder mergebb', start=(443, 1),
end=(464, 44), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.buildLeanBoolTrue?', code='def buildLeanBoolTrue? (builder : LLVM.Builder llvmctx)\n    (b : LLVM.Value llvmctx) (name : String := "") : M
 llvmctx (LLVM.Value llvmctx) := do\n  LLVM.buildICmp builder LLVM.IntPredicate.NE b (← constInt8 0) name', start=(467, 1), end=(469, 69), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitFnDeclAux'
, code='def emitFnDeclAux (mod : LLVM.Module llvmctx)\n    (decl : Decl) (cppBaseName : String) (isExternal : Bool) : M llvmctx (LLVM.Value llvmctx) := do\n  let ps := decl.params\n  let env ← getEnv\n  let global ←\n
    if ps.isEmpty then\n        let retty ← (toLLVMType decl.resultType)\n        let global ← LLVM.getOrAddGlobal mod cppBaseName retty\n        if !isExternal then\n          LLVM.setInitializer global (← LLVM.getUn
def retty)\n        pure global\n    else\n        let retty ← (toLLVMType decl.resultType)\n        let mut argtys := #[]\n        for p in ps do\n          if !(isExternC env decl.name) || !p.ty.isIrrelevant then\n
           argtys := argtys.push (← toLLVMType p.ty)\n        if argtys.size > closureMaxArgs && isBoxedName decl.name then\n          argtys := #[← LLVM.pointerType (← LLVM.voidPtrType llvmctx)]\n        let fnty ← L
LVM.functionType retty argtys (isVarArg := false)\n        LLVM.getOrAddFunction mod cppBaseName fnty\n  if ps.isEmpty then\n    if isClosedTermName env decl.name then LLVM.setVisibility global LLVM.Visibility.hidden
else if isExternal then pure () else LLVM.setDLLStorageClass global LLVM.DLLStorageClass.export  else if !isExternal\n    then LLVM.setDLLStorageClass global LLVM.DLLStorageClass.export\n  return global', start=(471,
1), end=(507, 16), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitFnDecl', code='def emitFnDecl (decl : Decl) (isExternal : Bool) : M llvmctx Unit := do\n  let cppBaseName ← toCName decl.name\n  l
et _ ← emitFnDeclAux (← getLLVMModule) decl cppBaseName isExternal', start=(510, 1), end=(512, 70), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitExternDeclAux', code='def emitExternDeclAux (decl
 : Decl) (cNameStr : String) : M llvmctx Unit := do\n  let env ← getEnv\n  let extC := isExternC env decl.name\n  let _ ← emitFnDeclAux (← getLLVMModule) decl cNameStr extC', start=(514, 1), end=(517, 61), kind='comma
nddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitFnDecls', code='def emitFnDecls : M llvmctx Unit := do\n  let env ← getEnv\n  let decls := getDecls env\n  let modDecls  : NameSet := decls.foldl (fun s d => s.
insert d.name) {}\n  let usedDecls : NameSet := decls.foldl (fun s d => collectUsedDecls env d (s.insert d.name)) {}\n  let usedDecls := usedDecls.toList\n  for n in usedDecls do\n    let decl ← getDecl n\n    match g
etExternNameFor env `c decl.name with\n    | some cName => emitExternDeclAux decl cName\n    | none       => emitFnDecl decl (!modDecls.contains n)\n  return ()', start=(519, 1), end=(530, 12), kind='commanddeclaratio
n'), Premise(full_name='Lean.IR.EmitLLVM.emitLhsSlot_', code='def emitLhsSlot_ (x : VarId) : M llvmctx (LLVM.LLVMType llvmctx × LLVM.Value llvmctx) := do\n  let state ← get\n  match state.var2val.find? x with\n  | .so
me v => return v\n  | .none => throw s!"unable to find variable {x}"', start=(532, 1), end=(536, 51), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitLhsVal', code='def emitLhsVal (builder : LLVM.B
uilder llvmctx)\n    (x : VarId) (name : String := "") : M llvmctx (LLVM.Value llvmctx) := do\n  let (xty, xslot) ← emitLhsSlot_ x\n  LLVM.buildLoad2 builder xty xslot name', start=(538, 1), end=(541, 41), kind='comma
nddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitLhsSlotStore', code='def emitLhsSlotStore (builder : LLVM.Builder llvmctx)\n    (x : VarId) (v : LLVM.Value llvmctx) : M llvmctx Unit := do\n  let (_, slot) ← e
mitLhsSlot_ x\n  LLVM.buildStore builder v slot', start=(543, 1), end=(546, 33), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitArgSlot_', code='def emitArgSlot_ (builder : LLVM.Builder llvmctx)\n
    (x : Arg) : M llvmctx (LLVM.LLVMType llvmctx × LLVM.Value llvmctx) := do\n  match x with\n  | Arg.var x => emitLhsSlot_ x\n  | _ => do\n    let slotty ← LLVM.voidPtrType llvmctx\n    let slot ← buildPrologueAlloca
 builder slotty "irrelevant_slot"\n    let v ← callLeanBox builder (← constIntSizeT 0) "irrelevant_val"\n    let _ ← LLVM.buildStore builder v slot\n    return (slotty, slot)', start=(548, 1), end=(557, 26), kind='com
manddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitArgVal', code='def emitArgVal (builder : LLVM.Builder llvmctx)\n    (x : Arg) (name : String := "") : M llvmctx (LLVM.LLVMType llvmctx × LLVM.Value llvmctx) :
= do\n  let (xty, xslot) ← emitArgSlot_ builder x\n  let xval ← LLVM.buildLoad2 builder xty xslot name\n  return (xty, xval)', start=(559, 1), end=(563, 21), kind='commanddeclaration'), Premise(full_name='Lean.IR.Emit
LLVM.emitAllocCtor', code='def emitAllocCtor (builder : LLVM.Builder llvmctx)\n    (c : CtorInfo) : M llvmctx (LLVM.Value llvmctx) := do\n  let hackSizeofVoidPtr := 8\n  let scalarSize := hackSizeofVoidPtr * c.usize +
 c.ssize\n  callLeanAllocCtor builder c.cidx c.size scalarSize "lean_alloc_ctor_out"', start=(565, 1), end=(570, 75), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitCtorSetArgs', code='def emitCto
rSetArgs (builder : LLVM.Builder llvmctx)\n    (z : VarId) (ys : Array Arg) : M llvmctx Unit := do\n  ys.size.forM fun i => do\n    let zv ← emitLhsVal builder z\n    let (_yty, yv) ← emitArgVal builder ys[i]!\n    le
t iv ← constIntUnsigned i\n    callLeanCtorSet builder zv iv yv\n    emitLhsSlotStore builder z zv\n    pure ()', start=(572, 1), end=(580, 12), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitCtor
', code='def emitCtor (builder : LLVM.Builder llvmctx)\n    (z : VarId) (c : CtorInfo) (ys : Array Arg) : M llvmctx Unit := do\n  let (_llvmty, slot) ← emitLhsSlot_ z\n  if c.size == 0 && c.usize == 0 && c.ssize == 0
then do\n    let v ← callLeanBox builder (← constIntSizeT c.cidx) "lean_box_outv"\n    let _ ← LLVM.buildStore builder v slot\n  else do\n    let v ← emitAllocCtor builder c\n    let _ ← LLVM.buildStore builder v slot
\n    emitCtorSetArgs builder z ys', start=(582, 1), end=(591, 33), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitInc', code='def emitInc (builder : LLVM.Builder llvmctx)\n    (x : VarId) (n : Na
t) (checkRef? : Bool) : M llvmctx Unit := do\n  let xv ← emitLhsVal builder x\n  if n != 1\n  then do\n     let nv ← constIntSizeT n\n     callLeanRefcountFn builder (kind := RefcountKind.inc) (checkRef? := checkRef?)
 (delta := nv) xv\n  else callLeanRefcountFn builder (kind := RefcountKind.inc) (checkRef? := checkRef?) xv', start=(593, 1), end=(600, 89), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitDec', co
de='def emitDec (builder : LLVM.Builder llvmctx)\n    (x : VarId) (n : Nat) (checkRef? : Bool) : M llvmctx Unit := do\n  let xv ← emitLhsVal builder x\n  if n != 1\n  then throw "expected n = 1 for emitDec"\n  else ca
llLeanRefcountFn builder (kind := RefcountKind.dec) (checkRef? := checkRef?) xv', start=(602, 1), end=(607, 89), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitNumLit', code='def emitNumLit (build
er : LLVM.Builder llvmctx)\n    (t : IRType) (v : Nat) : M llvmctx (LLVM.Value llvmctx) := do\n  if t.isObj then\n    if v < UInt32.size then\n      callLeanUnsignedToNatFn builder v\n    else\n      callLeanCStrToNat
Fn builder v\n  else\n    LLVM.constInt (← toLLVMType t) (UInt64.ofNat v)', start=(609, 1), end=(617, 52), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.toHexDigit', code='def toHexDigit (c : Nat) :
String :=\n  String.singleton c.digitChar', start=(619, 1), end=(620, 31), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.quoteString', code='def quoteString (s : String) : String :=\n  let q := "\\""
;\n  let q := s.foldl\n    (fun q c => q ++\n      if c == \'\\n\' then "\\\\n"\n      else if c == \'\\r\' then "\\\\r"\n      else if c == \'\\t\' then "\\\\t"\n      else if c == \'\\\\\' then "\\\\\\\\"\n      els
e if c == \'\\"\' then "\\\\\\""\n      else if c.toNat <= 31 then\n        "\\\\x" ++ toHexDigit (c.toNat / 16) ++ toHexDigit (c.toNat % 16)\n      else String.singleton c)\n    q;\n  q ++ "\\""', start=(623, 1), end
=(637, 12), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitSimpleExternalCall', code='def emitSimpleExternalCall (builder : LLVM.Builder llvmctx)\n    (f : String)\n    (ps : Array Param)\n    (ys
 : Array Arg)\n    (retty : IRType)\n    (name : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let mut args := #[]\n  let mut argTys := #[]\n  for (p, y) in ps.zip ys do\n    if !p.ty.isIrrelevant then\n      let
(_yty, yv) ← emitArgVal builder y ""\n      argTys := argTys.push (← toLLVMType p.ty)\n      args := args.push yv\n  let fnty ← LLVM.functionType (← toLLVMType retty) argTys\n  let fn ← LLVM.getOrAddFunction (← getLLV
MModule) f fnty\n  LLVM.buildCall2 builder fnty fn args name', start=(639, 1), end=(654, 44), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitExternCall', code='def emitExternCall (builder : LLVM.B
uilder llvmctx)\n    (f : FunId)\n    (ps : Array Param)\n    (extData : ExternAttrData)\n    (ys : Array Arg) (retty : IRType)\n    (name : String := "") : M llvmctx (LLVM.Value llvmctx) :=\n  match getExternEntryFor
 extData `c with\n  | some (ExternEntry.standard _ extFn) => emitSimpleExternalCall builder extFn ps ys retty name\n  | some (ExternEntry.inline `llvm _pat) => throw "Unimplemented codegen of inline LLVM"\n  | some (E
xternEntry.inline _ pat) => throw s!"Cannot codegen non-LLVM inline code \'{pat}\'."\n  | some (ExternEntry.foreign _ extFn)  => emitSimpleExternalCall builder extFn ps ys retty name\n  | _ => throw s!"Failed to emit
extern application \'{f}\'."', start=(658, 1), end=(669, 60), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.getFunIdTy', code='def getFunIdTy (f : FunId) : M llvmctx (LLVM.LLVMType llvmctx) := do\n
let decl ← getDecl f\n  let retty ← toLLVMType decl.resultType\n  let argtys ← decl.params.mapM (fun p => do toLLVMType p.ty)\n  LLVM.functionType retty argtys', start=(671, 1), end=(675, 33), kind='commanddeclaration
'), Premise(full_name='Lean.IR.EmitLLVM.getOrAddFunIdValue', code='def getOrAddFunIdValue (builder : LLVM.Builder llvmctx) (f : FunId) : M llvmctx (LLVM.Value llvmctx) := do\n  let decl ← getDecl f\n  let fcname ← toC
Name f\n  let retty ← toLLVMType decl.resultType\n  if decl.params.isEmpty then\n     let gslot ← LLVM.getOrAddGlobal (← getLLVMModule) fcname retty\n     LLVM.buildLoad2 builder retty gslot\n  else\n    let argtys ←
decl.params.mapM (fun p => do toLLVMType p.ty)\n    let fnty ← LLVM.functionType retty argtys\n    LLVM.getOrAddFunction (← getLLVMModule) fcname fnty', start=(677, 1), end=(694, 56), kind='commanddeclaration'), Premi
se(full_name='Lean.IR.EmitLLVM.emitPartialApp', code='def emitPartialApp (builder : LLVM.Builder llvmctx) (z : VarId) (f : FunId) (ys : Array Arg) : M llvmctx Unit := do\n  let decl ← getDecl f\n  let fv ← getOrAddFun
IdValue builder f\n  let arity := decl.params.size\n  let (_zty, zslot) ← emitLhsSlot_ z\n  let zval ← callLeanAllocClosureFn builder fv\n                                    (← constIntUnsigned arity)\n
                     (← constIntUnsigned ys.size)\n  LLVM.buildStore builder zval zslot\n  ys.size.forM fun i => do\n    let (yty, yslot) ← emitArgSlot_ builder ys[i]!\n    let yval ← LLVM.buildLoad2 builder yty yslot
\n    callLeanClosureSetFn builder zval (← constIntUnsigned i) yval', start=(696, 1), end=(708, 66), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitApp', code='def emitApp (builder : LLVM.Builder
llvmctx) (z : VarId) (f : VarId) (ys : Array Arg) : M llvmctx Unit := do\n  if ys.size > closureMaxArgs then do\n    let aargs ← buildPrologueAlloca builder (← LLVM.arrayType (← LLVM.voidPtrType llvmctx) (UInt64.ofNat
 ys.size)) "aargs"\n    for i in List.range ys.size do\n      let (yty, yv) ← emitArgVal builder ys[i]!\n      let aslot ← LLVM.buildInBoundsGEP2 builder yty aargs #[← constIntUnsigned 0, ← constIntUnsigned i] s!"para
m_{i}_slot"\n      LLVM.buildStore builder yv aslot\n    let fnName :=  s!"lean_apply_m"\n    let retty ← LLVM.voidPtrType llvmctx\n    let args := #[← emitLhsVal builder f, ← constIntUnsigned ys.size, aargs]\n    let
 argtys := #[← LLVM.voidPtrType llvmctx, ← LLVM.unsignedType llvmctx, ← LLVM.voidPtrType llvmctx]\n    let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n    let fnty ← LLVM.functionType rett
y argtys\n    let zv ← LLVM.buildCall2 builder fnty fn args\n    emitLhsSlotStore builder z zv\n  else do\n\n    let fnName :=  s!"lean_apply_{ys.size}"\n    let retty ← LLVM.voidPtrType llvmctx\n    let args : Array
(LLVM.Value llvmctx) := #[← emitLhsVal builder f] ++ (← ys.mapM (fun y => Prod.snd <$> (emitArgVal builder y)))\n    let argtys := (List.replicate (1 + ys.size) (← LLVM.voidPtrType llvmctx)).toArray\n    let fn ← getO
rCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n    let fnty ← LLVM.functionType retty argtys\n    let zv ← LLVM.buildCall2 builder fnty fn args\n    emitLhsSlotStore builder z zv', start=(710, 1), end
=(736, 34), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitFullApp', code='def emitFullApp (builder : LLVM.Builder llvmctx)\n    (z : VarId) (f : FunId) (ys : Array Arg) : M llvmctx Unit := do\n
let (__zty, zslot) ← emitLhsSlot_ z\n  let decl ← getDecl f\n  match decl with\n  | Decl.extern _ ps retty extData =>\n     let zv ← emitExternCall builder f ps extData ys retty\n     LLVM.buildStore builder zv zslot\
n  | Decl.fdecl .. =>\n    if ys.size > 0 then\n        let fv ← getOrAddFunIdValue builder f\n        let ys ←  ys.mapM (fun y => do\n            let (yty, yslot) ← emitArgSlot_ builder y\n            let yv ← LLVM.b
uildLoad2 builder yty yslot\n            return yv)\n        let zv ← LLVM.buildCall2 builder (← getFunIdTy f) fv ys\n        LLVM.buildStore builder zv zslot\n    else\n       let zv ← getOrAddFunIdValue builder f\n
      LLVM.buildStore builder zv zslot', start=(738, 1), end=(757, 40), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitLit', code='def emitLit (builder : LLVM.Builder llvmctx)\n    (z : VarId) (t
: IRType) (v : LitVal) : M llvmctx (LLVM.Value llvmctx) := do\n  let llvmty ← toLLVMType t\n  let zslot ← buildPrologueAlloca builder llvmty\n  addVartoState z zslot llvmty\n  let zv ← match v with\n            | LitV
al.num v => emitNumLit builder t v\n            | LitVal.str v =>\n                 let zero ← constIntUnsigned 0\n                 let str_global ← LLVM.buildGlobalString builder v\n                 let strPtr ← LLVM
.buildInBoundsGEP2 builder\n                                (← LLVM.opaquePointerTypeInContext llvmctx)\n                                str_global #[zero] ""\n                 let nbytes ← constIntSizeT v.utf8ByteSiz
e\n                 callLeanMkStringFromBytesFn builder strPtr nbytes ""\n  LLVM.buildStore builder zv zslot\n  return zslot', start=(760, 1), end=(777, 15), kind='commanddeclaration'), Premise(full_name='Lean.IR.Emit
LLVM.callLeanCtorGet', code='def callLeanCtorGet (builder : LLVM.Builder llvmctx)\n    (x i : LLVM.Value llvmctx) (retName : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  "lean_ctor_get"\n  let rett
y ← LLVM.voidPtrType llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx, ← LLVM.i32Type llvmctx]\n  let fnty ← LLVM.functionType retty argtys\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName
 argtys\n  let i ← LLVM.buildSextOrTrunc builder i (← LLVM.i32Type llvmctx)\n  LLVM.buildCall2 builder fnty fn  #[x, i] retName', start=(779, 1), end=(787, 51), kind='commanddeclaration'), Premise(full_name='Lean.IR.E
mitLLVM.emitProj', code='def emitProj (builder : LLVM.Builder llvmctx) (z : VarId) (i : Nat) (x : VarId) : M llvmctx Unit := do\n  let xval ← emitLhsVal builder x\n  let zval ← callLeanCtorGet builder xval (← constInt
Unsigned i) ""\n  emitLhsSlotStore builder z zval', start=(789, 1), end=(792, 34), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanCtorGetUsize', code='def callLeanCtorGetUsize (builder : LLVM.
Builder llvmctx)\n    (x i : LLVM.Value llvmctx) (retName : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  "lean_ctor_get_usize"\n  let retty ← LLVM.size_tType llvmctx\n  let argtys := #[ ← LLVM.void
PtrType llvmctx, ← LLVM.unsignedType llvmctx]\n  let fnty ← LLVM.functionType retty argtys\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  LLVM.buildCall2 builder fnty fn  #[x, i] ret
Name', start=(794, 1), end=(801, 51), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitUProj', code='def emitUProj (builder : LLVM.Builder llvmctx) (z : VarId) (i : Nat) (x : VarId) : M llvmctx Unit
 := do\n  let xval ← emitLhsVal builder x\n  let zval ← callLeanCtorGetUsize builder xval (← constIntUnsigned i) ""\n  emitLhsSlotStore builder z zval', start=(803, 1), end=(806, 34), kind='commanddeclaration'), Premi
se(full_name='Lean.IR.EmitLLVM.emitOffset', code='def emitOffset (builder : LLVM.Builder llvmctx)\n    (n : Nat) (offset : Nat) : M llvmctx (LLVM.Value llvmctx) := do\n   let out ← constIntUnsigned 8\n   let out ← LLV
M.buildMul builder out (← constIntUnsigned n) "" LLVM.buildAdd builder out (← constIntUnsigned offset) ""', start=(808, 1), end=(813, 60), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitSProj', co
de='def emitSProj (builder : LLVM.Builder llvmctx)\n    (z : VarId) (t : IRType) (n offset : Nat) (x : VarId) : M llvmctx Unit := do\n  let (fnName, retty) ←\n    match t with\n    | IRType.float  => pure ("lean_ctor_
get_float", ← LLVM.doubleTypeInContext llvmctx)\n    | IRType.uint8  => pure ("lean_ctor_get_uint8", ← LLVM.i8Type llvmctx)\n    | IRType.uint16 => pure ("lean_ctor_get_uint16", ←  LLVM.i16Type llvmctx)\n    | IRType.
uint32 => pure ("lean_ctor_get_uint32", ← LLVM.i32Type llvmctx)\n    | IRType.uint64 => pure ("lean_ctor_get_uint64", ← LLVM.i64Type llvmctx)\n    | _             => throw s!"Invalid type for lean_ctor_get: \'{t}\'"\n
  let argtys := #[ ← LLVM.voidPtrType llvmctx, ← LLVM.unsignedType llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let xval ← emitLhsVal builder x\n  let offset ← emitOffset
builder n offset\n  let fnty ← LLVM.functionType retty argtys\n  let zval ← LLVM.buildCall2 builder fnty fn  #[xval, offset]\n  emitLhsSlotStore builder z zval', start=(815, 1), end=(831, 34), kind='commanddeclaration
'), Premise(full_name='Lean.IR.EmitLLVM.callLeanIsExclusive', code='def callLeanIsExclusive (builder : LLVM.Builder llvmctx)\n    (closure : LLVM.Value llvmctx) (retName : String := "") : M llvmctx (LLVM.Value llvmctx
) := do\n  let fnName :=  "lean_is_exclusive"\n  let retty ← LLVM.i1Type llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fn
ty ← LLVM.functionType retty argtys\n  let out ← LLVM.buildCall2 builder fnty fn  #[closure] retName\n  LLVM.buildSextOrTrunc builder out (← LLVM.i8Type llvmctx)', start=(833, 1), end=(841, 60), kind='commanddeclarati
on'), Premise(full_name='Lean.IR.EmitLLVM.callLeanIsScalar', code='def callLeanIsScalar (builder : LLVM.Builder llvmctx)\n    (closure : LLVM.Value llvmctx) (retName : String := "") : M llvmctx (LLVM.Value llvmctx) :=
 do\n  let fnName :=  "lean_is_scalar"\n  let retty ← LLVM.i8Type llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LL
VM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn  #[closure] retName', start=(843, 1), end=(850, 54), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitIsShared', code='def emitIsShare
d (builder : LLVM.Builder llvmctx) (z : VarId) (x : VarId) : M llvmctx Unit := do\n    let xv ← emitLhsVal builder x\n    let exclusive? ← callLeanIsExclusive builder xv\n    let exclusive? ← LLVM.buildSextOrTrunc bui
lder exclusive? (← LLVM.i1Type llvmctx)\n    let shared? ← LLVM.buildNot builder exclusive?\n    let shared? ← LLVM.buildSext builder shared? (← LLVM.i8Type llvmctx)\n    emitLhsSlotStore builder z shared?', start=(85
2, 1), end=(858, 39), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitBox', code='def emitBox (builder : LLVM.Builder llvmctx) (z : VarId) (x : VarId) (xType : IRType) : M llvmctx Unit := do\n  let
 xv ← emitLhsVal builder x\n  let (fnName, argTy, xv) ←\n    match xType with\n    | IRType.usize  => pure ("lean_box_usize", ← LLVM.size_tType llvmctx, xv)\n    | IRType.uint32 => pure ("lean_box_uint32", ← LLVM.i32T
ype llvmctx, xv)\n    | IRType.uint64 => pure ("lean_box_uint64", ← LLVM.size_tType llvmctx, xv)\n    | IRType.float  => pure ("lean_box_float", ← LLVM.doubleTypeInContext llvmctx, xv)\n    | _             => do\n
     let xv ← LLVM.buildSext builder xv (← LLVM.size_tType llvmctx)\n         pure ("lean_box", ← LLVM.size_tType llvmctx, xv)\n  let retty ← LLVM.voidPtrType llvmctx\n  let argtys := #[argTy]\n  let fn ← getOrCreateF
unctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let zv ← LLVM.buildCall2 builder fnty fn  #[xv]\n  emitLhsSlotStore builder z zv', start=(860, 1), end=(877, 32),
kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.IRType.isIntegerType', code='def IRType.isIntegerType (t : IRType) : Bool :=\n  match t with\n  | .uint8 => true\n  | .uint16 => true\n  | .uint32 => tru
e\n  | .uint64 => true\n  | .usize => true\n  | _ => false', start=(879, 1), end=(886, 15), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callUnboxForType', code='def callUnboxForType (builder : LLVM
.Builder llvmctx)\n    (t : IRType)\n    (v : LLVM.Value llvmctx)\n    (retName : String := "") : M llvmctx (LLVM.Value llvmctx) := do\n  let (fnName, retty) ←\n     match t with\n     | IRType.usize  => pure ("lean_u
nbox_usize", ← toLLVMType t)\n     | IRType.uint32 => pure ("lean_unbox_uint32", ← toLLVMType t)\n     | IRType.uint64 => pure ("lean_unbox_uint64", ← toLLVMType t)\n     | IRType.float  => pure ("lean_unbox_float", ←
 toLLVMType t)\n     | _             => pure ("lean_unbox", ← LLVM.size_tType llvmctx)\n  let argtys := #[← LLVM.voidPtrType llvmctx ]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n
let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[v] retName', start=(888, 1), end=(902, 47), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitUnbox', code='def emitUnbo
x (builder : LLVM.Builder llvmctx)\n    (z : VarId) (t : IRType) (x : VarId) (retName : String := "") : M llvmctx Unit := do\n  let zval ← callUnboxForType builder t (← emitLhsVal builder x) retName\n  let zval ←\n
 if IRType.isIntegerType t\n    then LLVM.buildSextOrTrunc builder zval (← toLLVMType t)\n    else pure zval\n  emitLhsSlotStore builder z zval', start=(906, 1), end=(915, 34), kind='commanddeclaration'), Premise(full
_name='Lean.IR.EmitLLVM.emitReset', code='def emitReset (builder : LLVM.Builder llvmctx) (z : VarId) (n : Nat) (x : VarId) : M llvmctx Unit := do\n  let xv ← emitLhsVal builder x\n  let isExclusive ← callLeanIsExclusi
ve builder xv\n  let isExclusive ← buildLeanBoolTrue? builder isExclusive\n  buildIfThenElse_ builder "isExclusive" isExclusive\n   (fun builder => do\n     let xv ← emitLhsVal builder x\n     n.forM fun i => do\n
     callLeanCtorRelease builder xv (← constIntUnsigned i)\n     emitLhsSlotStore builder z xv\n     return ShouldForwardControlFlow.yes\n   )\n   (fun builder => do\n      let xv ← emitLhsVal builder x\n      callLea
nDecRef builder xv\n      let box0 ← callLeanBox builder (← constIntSizeT 0) "box0"\n      emitLhsSlotStore builder z box0\n      return ShouldForwardControlFlow.yes\n   )', start=(917, 1), end=(935, 5), kind='command
declaration'), Premise(full_name='Lean.IR.EmitLLVM.emitReuse', code='def emitReuse (builder : LLVM.Builder llvmctx)\n    (z : VarId) (x : VarId) (c : CtorInfo) (updtHeader : Bool) (ys : Array Arg) : M llvmctx Unit :=
do\n  let xv ← emitLhsVal builder x\n  let isScalar ← callLeanIsScalar builder xv\n  let isScalar ← buildLeanBoolTrue? builder isScalar\n  buildIfThenElse_ builder  "isScalar" isScalar\n    (fun builder => do\n      l
et cv ← emitAllocCtor builder c\n      emitLhsSlotStore builder z cv\n      return ShouldForwardControlFlow.yes\n   )\n   (fun builder => do\n       let xv ← emitLhsVal builder x\n       emitLhsSlotStore builder z xv\
n       if updtHeader then\n          let zv ← emitLhsVal builder z\n          callLeanCtorSetTag builder zv (← constInt8 c.cidx)\n       return ShouldForwardControlFlow.yes\n   )\n  emitCtorSetArgs builder z ys', sta
rt=(937, 1), end=(956, 31), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitVDecl', code='def emitVDecl (builder : LLVM.Builder llvmctx) (z : VarId) (t : IRType) (v : Expr) : M llvmctx Unit := do\n
  match v with\n  | Expr.ctor c ys      => emitCtor builder z c ys\n  | Expr.reset n x      => emitReset builder z n x\n  | Expr.reuse x c u ys => emitReuse builder z x c u ys\n  | Expr.proj i x       => emitProj buil
der z i x\n  | Expr.uproj i x      => emitUProj builder z i x\n  | Expr.sproj n o x    => emitSProj builder z t n o x\n  | Expr.fap c ys       => emitFullApp builder z c ys\n  | Expr.pap c ys       => emitPartialApp b
uilder z c ys\n  | Expr.ap x ys        => emitApp builder z x ys\n  | Expr.box t x        => emitBox builder z x t\n  | Expr.unbox x        => emitUnbox builder z t x\n  | Expr.isShared x     => emitIsShared builder z
 x\n  | Expr.lit v          => let _ ← emitLit builder z t v', start=(958, 1), end=(972, 57), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.declareVar', code='def declareVar (builder : LLVM.Builder l
lvmctx) (x : VarId) (t : IRType) : M llvmctx Unit := do\n  let llvmty ← toLLVMType t\n  let alloca ← buildPrologueAlloca builder llvmty "varx"\n  addVartoState x alloca llvmty', start=(974, 1), end=(977, 32), kind='co
mmanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.declareVars', code='partial def declareVars (builder : LLVM.Builder llvmctx) (f : FnBody) : M llvmctx Unit := do\n  match f with\n  | FnBody.vdecl x t _ b => do\
n      declareVar builder x t\n      declareVars builder b\n  | FnBody.jdecl _ xs _ b => do\n      for param in xs do declareVar builder param.x param.ty\n      declareVars builder b\n  | e => do\n      if e.isTermina
l then pure () else declareVars builder e.body', start=(979, 1), end=(988, 67), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitTag', code='def emitTag (builder : LLVM.Builder llvmctx) (x : VarId)
(xType : IRType) : M llvmctx (LLVM.Value llvmctx) := do\n  if xType.isObj then do\n    let xval ← emitLhsVal builder x\n    callLeanObjTag builder xval\n  else if xType.isScalar then do\n    emitLhsVal builder x\n  el
se\n    throw "Do not know how to `emitTag` in general."', start=(990, 1), end=(997, 53), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitSet', code='def emitSet (builder : LLVM.Builder llvmctx) (x
 : VarId) (i : Nat) (y : Arg) : M llvmctx Unit := do\n  let fnName :=  "lean_ctor_set"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx, ← LLVM.unsignedType llvmctx , ← LLVM.voidPtrT
ype llvmctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn  #[← emitLhsVal builder x, ← constInt
Unsigned i, (← emitArgVal builder y).2]', start=(999, 1), end=(1005, 119), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitUSet', code='def emitUSet (builder : LLVM.Builder llvmctx) (x : VarId) (i
: Nat) (y : VarId) : M llvmctx Unit := do\n  let fnName :=  "lean_ctor_set_usize"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx, ← LLVM.unsignedType llvmctx, ← LLVM.size_tType llv
mctx]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn  #[← emitLhsVal builder x, ← constIntUnsigne
d i, (← emitLhsVal builder y)]', start=(1007, 1), end=(1013, 117), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitTailCall', code='def emitTailCall (builder : LLVM.Builder llvmctx) (f : FunId) (v
: Expr) : M llvmctx Unit := do\n   match v with\n  | Expr.fap _ ys => do\n    let llvmctx ← read\n    let ps := llvmctx.mainParams\n    unless ps.size == ys.size do throw s!"Invalid tail call. f:\'{f}\' v:\'{v}\'"\n
  let args ← ys.mapM (fun y => Prod.snd <$> emitArgVal builder y)\n    let fn ← builderGetInsertionFn builder\n    let call ← LLVM.buildCall2 builder (← getFunIdTy f) fn args\n    LLVM.setTailCall call true let _ ← LL
VM.buildRet builder call\n  | _ => throw s!"EmitTailCall expects function application, found \'{v}\'"', start=(1015, 1), end=(1027, 74), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitJmp', code='
def emitJmp (builder : LLVM.Builder llvmctx) (jp : JoinPointId) (xs : Array Arg) : M llvmctx Unit := do\n let llvmctx ← read\n  let ps ← match llvmctx.jpMap.find? jp with\n  | some ps => pure ps\n  | none    => throw
s!"Unknown join point {jp}"\n  unless xs.size == ps.size do throw s!"Invalid goto, mismatched sizes between arguments, formal parameters."\n  for (p, x)  in ps.zip xs do\n    let (_xty, xv) ← emitArgVal builder x\n
 emitLhsSlotStore builder p.x xv\n  let _ ← LLVM.buildBr builder (← emitJp jp)', start=(1029, 1), end=(1038, 45), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitSSet', code='def emitSSet (builder
: LLVM.Builder llvmctx) (x : VarId) (n : Nat) (offset : Nat) (y : VarId) (t : IRType) : M llvmctx Unit := do\n  let (fnName, setty) ←\n  match t with\n  | IRType.float  => pure ("lean_ctor_set_float", ← LLVM.doubleTyp
eInContext llvmctx)\n  | IRType.uint8  => pure ("lean_ctor_set_uint8", ← LLVM.i8Type llvmctx)\n  | IRType.uint16 => pure ("lean_ctor_set_uint16", ← LLVM.i16Type llvmctx)\n  | IRType.uint32 => pure ("lean_ctor_set_uint
32", ← LLVM.i32Type llvmctx)\n  | IRType.uint64 => pure ("lean_ctor_set_uint64", ← LLVM.i64Type llvmctx)\n  | _             => throw s!"invalid type for \'lean_ctor_set\': \'{t}\'"\n  let argtys := #[ ← LLVM.voidPtrTy
pe llvmctx, ← LLVM.unsignedType llvmctx, setty]\n  let retty  ← LLVM.voidType llvmctx\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let xv ← emitLhsVal builder x\n  let offset ← emi
tOffset builder n offset\n  let yv ← emitLhsVal builder y\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn  #[xv, offset, yv]', start=(1040, 1), end=(1056, 61), kind='commanddecl
aration'), Premise(full_name='Lean.IR.EmitLLVM.emitDel', code='def emitDel (builder : LLVM.Builder llvmctx) (x : VarId) : M llvmctx Unit := do\n  let argtys := #[ ← LLVM.voidPtrType llvmctx]\n  let retty  ← LLVM.voidT
ype llvmctx\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty "lean_free_object" argtys\n  let xv ← emitLhsVal builder x\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder f
nty fn  #[xv]', start=(1058, 1), end=(1064, 49), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitSetTag', code='def emitSetTag (builder : LLVM.Builder llvmctx) (x : VarId) (i : Nat) : M llvmctx Uni
t := do\n  let argtys := #[← LLVM.voidPtrType llvmctx, ← LLVM.i8Type llvmctx]\n  let retty  ← LLVM.voidType llvmctx\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty "lean_ctor_set_tag" argtys\n  let xv
 ← emitLhsVal builder x\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn  #[xv, ← constInt8 i]', start=(1066, 1), end=(1072, 64), kind='commanddeclaration'), Premise(full_name="L
ean.IR.EmitLLVM.ensureHasDefault'", code="def ensureHasDefault' (alts : Array Alt) : Array Alt :=\n  if alts.any Alt.isDefault then alts\n  else\n    let last := alts.back\n    let alts := alts.pop\n    alts.push (Alt
.default last.body)", start=(1074, 1), end=(1079, 38), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitCase', code='partial def emitCase (builder : LLVM.Builder llvmctx)\n    (x : VarId) (xType : I
RType) (alts : Array Alt) : M llvmctx Unit := do\n  let oldBB ← LLVM.getInsertBlock builder\n  let tag ← emitTag builder x xType\n  let tag ← LLVM.buildZext builder tag (← LLVM.i64Type llvmctx)\n  let alts := ensureHa
sDefault\' alts\n  let defaultBB ← builderAppendBasicBlock builder s!"case_{xType}_default"\n  let numCasesHint := alts.size\n  let switch ← LLVM.buildSwitch builder tag defaultBB (UInt64.ofNat numCasesHint)\n  alts.f
orM fun alt => do\n    match alt with\n    | Alt.ctor c b  =>\n       let destbb ← builderAppendBasicBlock builder s!"case_{xType}_{c.name}_{c.cidx}"\n       LLVM.addCase switch (← constIntSizeT c.cidx) destbb\n
 LLVM.positionBuilderAtEnd builder destbb\n       emitFnBody builder b\n    | Alt.default b =>\n       LLVM.positionBuilderAtEnd builder defaultBB\n       emitFnBody builder b\n  LLVM.clearInsertionPosition builder\n
 LLVM.positionBuilderAtEnd builder oldBB', start=(1082, 1), end=(1105, 42), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitJDecl', code='partial def emitJDecl (builder : LLVM.Builder llvmctx)\n
 (jp : JoinPointId) (_ps : Array Param) (b : FnBody) : M llvmctx Unit := do\n  let oldBB ← LLVM.getInsertBlock builder\n  let jpbb ← builderAppendBasicBlock builder s!"jp_{jp.idx}"\n  addJpTostate jp jpbb\n  LLVM.posi
tionBuilderAtEnd builder jpbb\n  declareVars builder b\n  emitBlock builder b\n  LLVM.positionBuilderAtEnd builder oldBB', start=(1108, 1), end=(1121, 42), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLL
VM.emitUnreachable', code='partial def emitUnreachable (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[]\n  let fn ← getOrCreateFunctionPrototype  (← get
LLVMModule) retty "lean_internal_panic_unreachable" argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn #[]\n  let _ ← LLVM.buildUnreachable builder', start=(1123, 1), end=(1
129, 40), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitBlock', code='partial def emitBlock (builder : LLVM.Builder llvmctx) (b : FnBody) : M llvmctx Unit := do\n  match b with\n  | FnBody.jdecl
j xs  v b      =>\n       emitJDecl builder j xs v\n       emitBlock builder b\n  | d@(FnBody.vdecl x t v b)   => do\n    let llvmctx ← read\n    if isTailCallTo llvmctx.mainFn d then\n      emitTailCall builder llvmc
tx.mainFn v\n    else\n      emitVDecl builder x t v\n      emitBlock builder b\n  | FnBody.inc x n c p b       =>\n    unless p do emitInc builder x n c\n    emitBlock builder b\n  | FnBody.dec x n c p b       =>\n
  unless p do emitDec builder x n c\n    emitBlock builder b\n  | FnBody.del x b             =>  emitDel builder x; emitBlock builder b\n  | FnBody.setTag x i b        =>  emitSetTag builder x i; emitBlock builder b\n
  | FnBody.set x i y b         => emitSet builder x i y; emitBlock builder b\n  | FnBody.uset x i y b        => emitUSet builder x i y; emitBlock builder b\n  | FnBody.sset x i o y t b    => emitSSet builder x i o y t
; emitBlock builder b\n  | FnBody.mdata _ b           => emitBlock builder b\n  | FnBody.ret x               => do\n      let (_xty, xv) ← emitArgVal builder x "ret_val"\n      let _ ← LLVM.buildRet builder xv\n  | Fn
Body.case _ x xType alts =>\n     emitCase builder x xType alts\n  | FnBody.jmp j xs            =>\n     emitJmp builder j xs\n  | FnBody.unreachable         => emitUnreachable builder', start=(1131, 1), end=(1162, 58
), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitFnBody', code='partial def emitFnBody  (builder : LLVM.Builder llvmctx)  (b : FnBody) : M llvmctx Unit := do\n  declareVars builder b\n  emitBlock
 builder b', start=(1164, 1), end=(1166, 22), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitFnArgs', code='def emitFnArgs (builder : LLVM.Builder llvmctx)\n    (needsPackedArgs? : Bool)  (llvmfn
: LLVM.Value llvmctx) (params : Array Param) : M llvmctx Unit := do\n  if needsPackedArgs? then do\n      let argsp ← LLVM.getParam llvmfn 0 for i in List.range params.size do\n          let param := params[i]!\n
     let argsi ← LLVM.buildGEP2 builder (← LLVM.voidPtrType llvmctx) argsp #[← constIntUnsigned i] s!"packed_arg_{i}_slot"\n          let llvmty ← toLLVMType param.ty\n          let pv ← LLVM.buildLoad2 builder llvmty
 argsi\n          let alloca ← buildPrologueAlloca builder llvmty s!"arg_{i}"\n          LLVM.buildStore builder pv alloca\n          addVartoState params[i]!.x alloca llvmty\n  else\n      let n ← LLVM.countParams ll
vmfn\n      for i in (List.range n.toNat) do\n        let llvmty ← toLLVMType params[i]!.ty\n        let alloca ← buildPrologueAlloca builder  llvmty s!"arg_{i}"\n        let arg ← LLVM.getParam llvmfn (UInt64.ofNat i
)\n        let _ ← LLVM.buildStore builder arg alloca\n        addVartoState params[i]!.x alloca llvmty', start=(1170, 1), end=(1192, 49), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitDeclAux',
code='def emitDeclAux (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) (d : Decl) : M llvmctx Unit := do\n  let env ← getEnv\n  let (_, jpMap) := mkVarJPMaps d\n  withReader (fun llvmctx => { llvmctx with
jpMap := jpMap }) do\n  unless hasInitAttr env d.name do\n    match d with\n    | .fdecl (f := f) (xs := xs) (type := t) (body := b) .. =>\n      let baseName ← toCName f\n      let name := if xs.size > 0 then baseNam
e else "_init_" ++ baseName\n      let retty ← toLLVMType t\n      let mut argtys := #[]\n      let needsPackedArgs? := xs.size > closureMaxArgs && isBoxedName d.name\n      if needsPackedArgs? then\n          argtys
:= #[← LLVM.pointerType (← LLVM.voidPtrType llvmctx)]\n      else\n        for x in xs do\n          argtys := argtys.push (← toLLVMType x.ty)\n      let fnty ← LLVM.functionType retty argtys (isVarArg := false)\n
  let llvmfn ← LLVM.getOrAddFunction mod name fnty\n      if xs.size == 0 then\n        LLVM.setVisibility llvmfn LLVM.Visibility.hidden else\n        LLVM.setDLLStorageClass llvmfn LLVM.DLLStorageClass.export  withRe
ader (fun llvmctx => { llvmctx with mainFn := f, mainParams := xs }) do\n        set { var2val := default, jp2bb := default : EmitLLVM.State llvmctx } let bb ← LLVM.appendBasicBlockInContext llvmctx llvmfn "entry"\n
      LLVM.positionBuilderAtEnd builder bb\n        emitFnArgs builder needsPackedArgs? llvmfn xs\n        emitFnBody builder b\n      pure ()\n    | _ => pure ()', start=(1194, 1), end=(1228, 19), kind='commanddeclar
ation'), Premise(full_name='Lean.IR.EmitLLVM.emitDecl', code='def emitDecl (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) (d : Decl) : M llvmctx Unit := do\n  let d := d.normalizeIds try\n    emitDeclAux
 mod builder d\n    return ()\n  catch err =>\n    throw (s!"emitDecl:\\ncompiling:\\n{d}\\nerr:\\n{err}\\n")', start=(1230, 1), end=(1236, 58), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitFns'
, code='def emitFns (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let env ← getEnv\n  let decls := getDecls env\n  decls.reverse.forM (emitDecl mod builder)', start=(1238, 1),
end=(1241, 44), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callIODeclInitFn', code='def callIODeclInitFn (builder : LLVM.Builder llvmctx)\n    (initFnName : String)\n    (world : LLVM.Value llvmct
x): M llvmctx (LLVM.Value llvmctx) := do\n  let retty ← LLVM.voidPtrType llvmctx\n  let argtys := #[← LLVM.voidPtrType llvmctx]\n  let fn ← getOrCreateFunctionPrototype  (← getLLVMModule) retty initFnName argtys\n  le
t fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[world]', start=(1243, 1), end=(1250, 43), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callPureDeclInitFn', code='def cal
lPureDeclInitFn (builder : LLVM.Builder llvmctx)\n    (initFnName : String)\n    (retty : LLVM.LLVMType llvmctx): M llvmctx (LLVM.Value llvmctx) := do\n  let argtys := #[]\n  let fn ← getOrCreateFunctionPrototype  (←
getLLVMModule) retty initFnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[]', start=(1252, 1), end=(1258, 38), kind='commanddeclaration'), Premise(full_name='Lean.IR.Emit
LLVM.emitDeclInit', code='def emitDeclInit (builder : LLVM.Builder llvmctx)\n    (parentFn : LLVM.Value llvmctx) (d : Decl) : M llvmctx Unit := do\n  let env ← getEnv\n  if isIOUnitInitFn env d.name then do\n    let w
orld ← callLeanIOMkWorld builder\n    let resv ← callIODeclInitFn builder (← toCName d.name) world\n    let err? ← callLeanIOResultIsError builder resv "is_error"\n    buildIfThen_ builder s!"init_{d.name}_isError" er
r?\n      (fun builder => do\n        let _ ← LLVM.buildRet builder resv\n        pure ShouldForwardControlFlow.no)\n    else if d.params.size == 0 then\n    match getInitFnNameFor? env d.name with\n    | some initFn
=>\n      let llvmty ← toLLVMType d.resultType\n      let dslot ←  LLVM.getOrAddGlobal (← getLLVMModule) (← toCName d.name) llvmty\n      LLVM.setInitializer dslot (← LLVM.getUndef llvmty)\n      let initBB ← builderA
ppendBasicBlock builder s!"do_{d.name}_init"\n      let restBB ← builderAppendBasicBlock builder s!"post_{d.name}_init"\n      let checkBuiltin? := getBuiltinInitFnNameFor? env d.name |>.isSome\n      if checkBuiltin?
 then\n        let builtinParam ← LLVM.getParam parentFn 0\n        let cond ← buildLeanBoolTrue? builder builtinParam "is_builtin_true"\n        let _ ← LLVM.buildCondBr builder cond initBB restBB\n       else\n
   let _ ← LLVM.buildBr builder initBB\n      LLVM.positionBuilderAtEnd builder initBB\n      let world ← callLeanIOMkWorld builder\n      let resv ← callIODeclInitFn builder (← toCName initFn) world\n      let err? ←
 callLeanIOResultIsError builder resv s!"{d.name}_is_error"\n      buildIfThen_ builder s!"init_{d.name}_isError" err?\n        (fun builder => do\n          let _ ← LLVM.buildRet builder resv\n          pure ShouldFo
rwardControlFlow.no)\n      if d.resultType.isScalar then\n        let dval ← callLeanIOResultGetValue builder resv s!"{d.name}_res"\n        let dval ← callUnboxForType builder d.resultType dval\n        LLVM.buildSt
ore builder dval dslot\n      else\n         let dval ← callLeanIOResultGetValue builder resv s!"{d.name}_res"\n         LLVM.buildStore builder dval dslot\n         callLeanMarkPersistentFn builder dval\n      let _
← LLVM.buildBr builder restBB\n      LLVM.positionBuilderAtEnd builder restBB\n    | none => do\n      let llvmty ← toLLVMType d.resultType\n      let dslot ←  LLVM.getOrAddGlobal (← getLLVMModule) (← toCName d.name)
llvmty\n      LLVM.setInitializer dslot (← LLVM.getUndef llvmty)\n      let dval ← callPureDeclInitFn builder (← toCInitName d.name) (← toLLVMType d.resultType)\n      LLVM.buildStore builder dval dslot\n      if d.re
sultType.isObj then\n         callLeanMarkPersistentFn builder dval', start=(1260, 1), end=(1314, 47), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callModInitFn', code='def callModInitFn (builder :
 LLVM.Builder llvmctx)\n    (modName : Name) (input world : LLVM.Value llvmctx) (retName : String): M llvmctx (LLVM.Value llvmctx) := do\n  let fnName := mkModuleInitializationFunctionName modName\n  let retty ← LLVM.
voidPtrType llvmctx\n  let argtys := #[ (← LLVM.i8Type llvmctx), (← LLVM.voidPtrType llvmctx)]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argty
s\n  LLVM.buildCall2 builder fnty fn #[input, world] retName', start=(1316, 1), end=(1323, 58), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitInitFn', code='def emitInitFn (mod : LLVM.Module llvm
ctx) (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let env ← getEnv\n  let modName ← getModName\n\n  let initFnTy ← LLVM.functionType (← LLVM.voidPtrType llvmctx) #[ (← LLVM.i8Type llvmctx), (← LLVM.voidP
trType llvmctx)] (isVarArg := false)\n  let initFn ← LLVM.getOrAddFunction mod (mkModuleInitializationFunctionName modName) initFnTy\n  LLVM.setDLLStorageClass initFn LLVM.DLLStorageClass.export  let entryBB ← LLVM.ap
pendBasicBlockInContext llvmctx initFn "entry"\n  LLVM.positionBuilderAtEnd builder entryBB\n  let ginit?ty := ← LLVM.i1Type llvmctx\n  let ginit?slot ← LLVM.getOrAddGlobal mod (modName.mangle ++ "_G_initialized") gin
it?ty\n  LLVM.setVisibility ginit?slot LLVM.Visibility.hidden LLVM.setInitializer ginit?slot (← LLVM.constFalse llvmctx)\n  let ginit?v ← LLVM.buildLoad2 builder ginit?ty ginit?slot "init_v"\n  buildIfThen_ builder "i
sGInitialized" ginit?v\n    (fun builder => do\n      let box0 ← callLeanBox builder (← constIntSizeT 0) "box0"\n      let out ← callLeanIOResultMKOk builder box0 "retval"\n      let _ ← LLVM.buildRet builder out\n
   pure ShouldForwardControlFlow.no)\n  LLVM.buildStore builder (← LLVM.constTrue llvmctx) ginit?slot\n\n  env.imports.forM fun import_ => do\n    let builtin ← LLVM.getParam initFn 0\n    let world ← callLeanIOMkWorl
d builder\n    let res ← callModInitFn builder import_.module builtin world ("res_" ++ import_.module.mangle)\n    let err? ← callLeanIOResultIsError builder res ("res_is_error_"  ++ import_.module.mangle)\n    buildI
fThen_ builder ("IsError" ++ import_.module.mangle) err?\n      (fun builder => do\n        let _ ← LLVM.buildRet builder res\n        pure ShouldForwardControlFlow.no)\n    callLeanDecRef builder res\n  let decls :=
getDecls env\n  decls.reverse.forM (emitDeclInit builder initFn)\n  let box0 ← callLeanBox builder (← constIntSizeT 0) "box0"\n  let out ← callLeanIOResultMKOk builder box0 "retval"\n  let _ ← LLVM.buildRet builder ou
t', start=(1325, 1), end=(1361, 36), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanInitialize', code='def callLeanInitialize (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let fnN
ame :=  "lean_initialize"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[]\n  let fnty ← LLVM.functionType retty argtys\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let _
← LLVM.buildCall2 builder fnty fn #[]', start=(1363, 1), end=(1369, 46), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanInitializeRuntimeModule', code='def callLeanInitializeRuntimeModule (bui
lder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let fnName :=  "lean_initialize_runtime_module"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[]\n  let fnty ← LLVM.functionType retty argtys\n  let fn ←
 getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let _ ← LLVM.buildCall2 builder fnty fn #[]', start=(1371, 1), end=(1377, 46), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.cal
lLeanSetPanicMessages', code='def callLeanSetPanicMessages (builder : LLVM.Builder llvmctx)\n    (enable? : LLVM.Value llvmctx) : M llvmctx Unit := do\n  let fnName :=  "lean_set_panic_messages"\n  let retty ← LLVM.vo
idType llvmctx\n  let argtys := #[ ← LLVM.i1Type llvmctx ]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder
 fnty fn #[enable?]', start=(1379, 1), end=(1386, 53), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanIOMarkEndInitialization', code='def callLeanIOMarkEndInitialization (builder : LLVM.Builde
r llvmctx) : M llvmctx Unit := do\n  let fnName :=  "lean_io_mark_end_initialization"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName a
rgtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn #[]', start=(1388, 1), end=(1394, 46), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanIOResultIsOk
', code='def callLeanIOResultIsOk (builder : LLVM.Builder llvmctx)\n    (arg : LLVM.Value llvmctx) (name : String := "") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  "lean_io_result_is_ok"\n  let retty ← L
LVM.i1Type llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx ]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  LLVM.buildCall2 builde
r fnty fn #[arg] name', start=(1396, 1), end=(1403, 46), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanInitTaskManager', code='def callLeanInitTaskManager (builder : LLVM.Builder llvmctx) : M
 llvmctx Unit := do\n  let fnName :=  "lean_init_task_manager"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #[]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLV
M.functionType retty argtys\n   let _ ← LLVM.buildCall2 builder fnty fn #[]', start=(1405, 1), end=(1411, 47), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanFinalizeTaskManager', code='def ca
llLeanFinalizeTaskManager (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let fnName :=  "lean_finalize_task_manager"\n  let retty ← LLVM.voidPtrType llvmctx\n  let argtys := #[]\n  let fn ← getOrCreateFunc
tionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n   let _ ← LLVM.buildCall2 builder fnty fn #[]', start=(1413, 1), end=(1419, 47), kind='commanddeclaration'), Premise(f
ull_name='Lean.IR.EmitLLVM.callLeanUnboxUint32', code='def callLeanUnboxUint32 (builder : LLVM.Builder llvmctx)\n    (v : LLVM.Value llvmctx) (name : String := "") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName
:=  "lean_unbox_uint32"\n  let retty ← LLVM.i32Type llvmctx\n  let argtys := #[ ← LLVM.voidPtrType llvmctx ]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionTy
pe retty argtys\n  LLVM.buildCall2 builder fnty fn  #[v] name', start=(1421, 1), end=(1428, 45), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanIOResultShowError', code='def callLeanIOResultSh
owError (builder : LLVM.Builder llvmctx)\n    (v : LLVM.Value llvmctx) (name : String := "") : M llvmctx Unit := do\n  let fnName :=  "lean_io_result_show_error"\n  let retty ← LLVM.voidType llvmctx\n  let argtys := #
[ ← LLVM.voidPtrType llvmctx ]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty fnName argtys\n  let fnty ← LLVM.functionType retty argtys\n  let _ ← LLVM.buildCall2 builder fnty fn #[v] name', start=(
1430, 1), end=(1437, 52), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.callLeanMainFn', code='def callLeanMainFn (builder : LLVM.Builder llvmctx)\n    (argv? : Option (LLVM.Value llvmctx))\n    (wor
ld : LLVM.Value llvmctx)\n    (name : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let retty ← LLVM.voidPtrType llvmctx\n  let voidptr ← LLVM.voidPtrType llvmctx\n  let argtys := if argv?.isSome then #[ voidptr,
voidptr ] else #[ voidptr ]\n  let fn ← getOrCreateFunctionPrototype (← getLLVMModule) retty leanMainFn argtys\n  let fnty ← LLVM.functionType retty argtys\n  let args := match argv? with\n              | .some argv =
> #[argv, world]\n              | .none => #[world]\n  LLVM.buildCall2 builder fnty fn args name', start=(1439, 1), end=(1451, 44), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitMainFn', code='de
f emitMainFn (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let d ← getDecl `main\n  let xs ← match d with\n   | .fdecl (xs := xs) .. => pure xs\n   | _ =>  throw "Function decl
aration expected for \'main\'"\n\n  unless xs.size == 2 || xs.size == 1 do throw s!"Invalid main function, main expected to have \'2\' or \'1\' arguments, found \'{xs.size}\' arguments"\n  let env ← getEnv\n  let uses
LeanAPI := usesModuleFrom env `Lean\n  let mainTy ← LLVM.functionType (← LLVM.i64Type llvmctx)\n      #[(← LLVM.i64Type llvmctx), (← LLVM.pointerType (← LLVM.voidPtrType llvmctx))]\n  let main ← LLVM.getOrAddFunction
mod "main" mainTy\n  let entry ← LLVM.appendBasicBlockInContext llvmctx main "entry"\n  LLVM.positionBuilderAtEnd builder entry\n  \n  let inty ← LLVM.voidPtrType llvmctx\n  let inslot ← buildPrologueAlloca builder (←
 LLVM.pointerType inty) "in"\n  let resty ← LLVM.voidPtrType llvmctx\n  let res ← buildPrologueAlloca builder (← LLVM.pointerType resty) "res"\n  if usesLeanAPI then callLeanInitialize builder else callLeanInitializeR
untimeModule builder\n    \n  callLeanSetPanicMessages builder (← LLVM.constFalse llvmctx)\n  let world ← callLeanIOMkWorld builder\n  let resv ← callModInitFn builder (← getModName) (← constInt8 1) world ((← getModNa
me).toString ++ "_init_out")\n  let _ ← LLVM.buildStore builder resv res\n\n  callLeanSetPanicMessages builder (← LLVM.constTrue llvmctx)\n  callLeanIOMarkEndInitialization builder\n\n  let resv ← LLVM.buildLoad2 buil
der resty res "resv"\n  let res_is_ok ← callLeanIOResultIsOk builder resv "res_is_ok"\n  buildIfThen_ builder "resIsOkBranches"  res_is_ok\n    (fun builder => do callLeanDecRef builder resv\n      callLeanInitTaskMan
ager builder\n      if xs.size == 2 then\n        let inv ← callLeanBox builder (← constIntSizeT 0) "inv"\n        let _ ← LLVM.buildStore builder inv inslot\n        let ity ← LLVM.size_tType llvmctx\n        let isl
ot ← buildPrologueAlloca builder ity "islot"\n        let argcval ← LLVM.getParam main 0\n        let argvval ← LLVM.getParam main 1\n        LLVM.buildStore builder argcval islot\n        buildWhile_ builder "argv"\n
          (condcodegen := fun builder => do\n            let iv ← LLVM.buildLoad2 builder ity islot "iv"\n            let i_gt_1 ← LLVM.buildICmp builder LLVM.IntPredicate.UGT iv (← constIntSizeT 1) "i_gt_1"\n
    return i_gt_1)\n          (bodycodegen := fun builder => do\n            let iv ← LLVM.buildLoad2 builder ity islot "iv"\n            let iv_next ← LLVM.buildSub builder iv (← constIntSizeT 1) "iv.next"\n
   LLVM.buildStore builder iv_next islot\n            let nv ← callLeanAllocCtor builder 1 2 0 "nv"\n            let argv_i_next_slot ← LLVM.buildGEP2 builder (← LLVM.voidPtrType llvmctx) argvval #[iv_next] "argv.i.ne
xt.slot"\n            let argv_i_next_val ← LLVM.buildLoad2 builder (← LLVM.voidPtrType llvmctx) argv_i_next_slot "argv.i.next.val"\n            let argv_i_next_val_str ← callLeanMkString builder argv_i_next_val "arg.
i.next.val.str"\n            callLeanCtorSet builder nv (← constIntUnsigned 0) argv_i_next_val_str\n            let inv ← LLVM.buildLoad2 builder inty inslot "inv"\n            callLeanCtorSet builder nv (← constIntUn
signed 1) inv\n            LLVM.buildStore builder nv inslot)\n        let world ← callLeanIOMkWorld builder\n        let inv ← LLVM.buildLoad2 builder inty inslot "inv"\n        let resv ← callLeanMainFn builder (arg
v? := .some inv) (world := world) "resv"\n        let _ ← LLVM.buildStore builder resv res\n        pure ShouldForwardControlFlow.yes\n      else\n          let world ← callLeanIOMkWorld builder\n          let resv ←
callLeanMainFn builder (argv? := .none) (world := world) "resv"\n          let _ ← LLVM.buildStore builder resv res\n          pure ShouldForwardControlFlow.yes\n  )\n\n  let retTy := env.find? `main |>.get! |>.type |
>.getForallBody\n  let retTy := retTy.appArg!\n  callLeanFinalizeTaskManager builder\n  let resv ← LLVM.buildLoad2 builder resty res "resv"\n  let res_is_ok ← callLeanIOResultIsOk builder resv "res_is_ok"\n  buildIfTh
enElse_ builder "res.is.ok" res_is_ok\n    (fun builder => if retTy.constName? == some ``UInt32 then do\n        let resv ← LLVM.buildLoad2 builder resty res "resv"\n        let retv ← callLeanUnboxUint32 builder (← c
allLeanIOResultGetValue builder resv "io_val") "retv"\n        let retv ← LLVM.buildSext builder retv (← LLVM.i64Type llvmctx) "retv_sext"\n        callLeanDecRef builder resv\n        let _ ← LLVM.buildRet builder re
tv\n        pure ShouldForwardControlFlow.no\n      else do\n        callLeanDecRef builder resv\n        let _ ← LLVM.buildRet builder (← constInt64 0)\n        pure ShouldForwardControlFlow.no\n\n    )\n    (fun bui
lder => do let resv ← LLVM.buildLoad2 builder resty res "resv"\n        callLeanIOResultShowError builder resv\n        callLeanDecRef builder resv\n        let _ ← LLVM.buildRet builder (← constInt64 1)\n        pure
 ShouldForwardControlFlow.no)\n  let _ ← LLVM.buildUnreachable builder', start=(1453, 1), end=(1561, 40), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.hasMainFn', code='def hasMainFn : M llvmctx Boo
l := do\n  let env ← getEnv\n  let decls := getDecls env\n  return decls.any (fun d => d.name == `main)', start=(1563, 1), end=(1566, 46), kind='commanddeclaration'), Premise(full_name='Lean.IR.EmitLLVM.emitMainFnIfNe
eded', code='def emitMainFnIfNeeded (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  if (← hasMainFn) then emitMainFn mod builder', start=(1568, 1), end=(1569, 47), kind='commandd
eclaration'), Premise(full_name='Lean.IR.EmitLLVM.main', code='def main : M llvmctx Unit := do\n  emitFnDecls\n  let builder ← LLVM.createBuilderInContext llvmctx\n  emitFns (← getLLVMModule) builder\n  emitInitFn (←
getLLVMModule) builder\n  emitMainFnIfNeeded (← getLLVMModule) builder', start=(1571, 1), end=(1576, 47), kind='commanddeclaration'), Premise(full_name='Lean.IR.getLeanHBcPath', code='def getLeanHBcPath : IO System.Fi
lePath := do\n  return (← getLibDir (← getBuildDir)) / "lean.h.bc"', start=(1579, 1), end=(1580, 53), kind='commanddeclaration'), Premise(full_name='Lean.IR.getModuleGlobals', code='partial def getModuleGlobals (mod :
 LLVM.Module llvmctx) : IO (Array (LLVM.Value llvmctx)) := do\n  let rec go (v : LLVM.Value llvmctx) (acc : Array (LLVM.Value llvmctx)) : IO (Array (LLVM.Value llvmctx)) := do\n    if v.isNull then return acc\n    els
e go (← LLVM.getNextGlobal v) (acc.push v)\n  go (← LLVM.getFirstGlobal mod) #[]', start=(1582, 1), end=(1587, 37), kind='commanddeclaration'), Premise(full_name='Lean.IR.getModuleFunctions', code='partial def getModu
leFunctions (mod : LLVM.Module llvmctx) : IO (Array (LLVM.Value llvmctx)) := do\n  let rec go (v : LLVM.Value llvmctx) (acc : Array (LLVM.Value llvmctx)) : IO (Array (LLVM.Value llvmctx)) := do\n    if v.isNull then r
eturn acc\n    else go (← LLVM.getNextFunction v) (acc.push v)\n  go (← LLVM.getFirstFunction mod) #[]', start=(1589, 1), end=(1594, 39), kind='commanddeclaration'), Premise(full_name='Lean.IR.emitLLVM', code='@[expor
t lean_ir_emit_llvm]\ndef emitLLVM (env : Environment) (modName : Name) (filepath : String) : IO Unit := do\n  LLVM.llvmInitializeTargetInfo\n  let llvmctx ← LLVM.createContext\n  let module ← LLVM.createModule llvmct
x modName.toString\n  let emitLLVMCtx : EmitLLVM.Context llvmctx := {env := env, modName := modName, llvmmodule := module}\n  let initState := { var2val := default, jp2bb := default : EmitLLVM.State llvmctx}\n  let ou
t? ← ((EmitLLVM.main (llvmctx := llvmctx)).run initState).run emitLLVMCtx\n  match out? with\n  | .ok _ => do\n         let membuf ← LLVM.createMemoryBufferWithContentsOfFile (← getLeanHBcPath).toString\n         let
modruntime ← LLVM.parseBitcode llvmctx membuf\n         \n         let runtimeGlobals ← (← getModuleGlobals modruntime).mapM (·.getName)\n         let filter func := do\n           if (← LLVM.isDeclaration func) then\
n             return none\n           else\n             return some (← func.getName)\n         let runtimeFunctions ← (← getModuleFunctions modruntime).filterMapM filter\n         LLVM.linkModules (dest := emitLLVMCt
x.llvmmodule) (src := modruntime)\n         for name in runtimeGlobals do\n           let some global ← LLVM.getNamedGlobal emitLLVMCtx.llvmmodule name\n              | throw <| IO.Error.userError s!"ERROR: linked mod
ule must have global from runtime module: \'{name}\'"\n           LLVM.setLinkage global LLVM.Linkage.internal\n         for name in runtimeFunctions do\n           let some fn ← LLVM.getNamedFunction emitLLVMCtx.llvm
module name\n              | throw <| IO.Error.userError s!"ERROR: linked module must have function from runtime module: \'{name}\'"\n           LLVM.setLinkage fn LLVM.Linkage.internal\n         if let some err ← LLV
M.verifyModule emitLLVMCtx.llvmmodule then\n           throw <| .userError err\n         LLVM.writeBitcodeToFile emitLLVMCtx.llvmmodule filepath\n         LLVM.disposeModule emitLLVMCtx.llvmmodule\n  | .error err => t
hrow (IO.Error.userError err)', start=(1596, 1), end=(1637, 49), kind='commanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Probing.lean'), imports=['.lake/packages/lean
4/src/lean/Lean/Compiler/LCNF/PassManager.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/ForEachExpr.lean', '.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean', '.lake/packages/lean4/src/lean/Le
an/Compiler/LCNF/CompilerM.lean'], premises=[Premise(full_name='Lean.Compiler.LCNF.Probe', code='abbrev Probe α β := Array α → CompilerM (Array β)', start=(14, 1), end=(14, 50), kind='commanddeclaration'), Premise(ful
l_name='Lean.Compiler.LCNF.Probe.map', code='@[inline]\ndef map (f : α → CompilerM β) : Probe α β := fun data => data.mapM f', start=(18, 1), end=(19, 69), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.
LCNF.Probe.filter', code='@[inline]\ndef filter (f : α → CompilerM Bool) : Probe α α := fun data => data.filterM f', start=(21, 1), end=(22, 78), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe
.sorted', code='@[inline]\ndef sorted [Inhabited α] [inst : LT α] [DecidableRel inst.lt] : Probe α α := fun data => return data.qsort (· < ·)', start=(24, 1), end=(25, 115), kind='commanddeclaration'), Premise(full_na
me='Lean.Compiler.LCNF.Probe.sortedBySize', code='@[inline]\ndef sortedBySize : Probe Decl (Nat × Decl) := fun decls =>\n  let decls := decls.map fun decl => (decl.size, decl)\n  return decls.qsort fun (sz₁, decl₁) (s
z₂, decl₂) =>\n    if sz₁ == sz₂ then Name.lt decl₁.name decl₂.name else sz₁ < sz₂', start=(27, 1), end=(31, 68), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.countUnique', code='def countUn
ique [ToString α] [BEq α] [Hashable α] : Probe α (α × Nat) := fun data => do\n  let mut map := HashMap.empty\n  for d in data do\n    if let some count := map.find? d then\n      map := map.insert d (count + 1)\n    e
lse\n      map := map.insert d 1\n  return map.toArray', start=(33, 1), end=(40, 21), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.countUniqueSorted', code='@[inline]\ndef countUniqueSorted
[ToString α] [BEq α] [Hashable α] [Inhabited α] : Probe α (α × Nat) :=\n  countUnique >=> fun data => return data.qsort (fun l r => l.snd < r.snd)', start=(42, 1), end=(44, 75), kind='commanddeclaration'), Premise(ful
l_name='Lean.Compiler.LCNF.Probe.getLetValues', code='partial def getLetValues : Probe Decl LetValue := fun decls => do\n  let (_, res) ← start decls |>.run #[]\n  return res\nwhere\n  go (c : Code) : StateRefT (Array
 LetValue) CompilerM Unit := do\n    match c with\n    | .let (decl : LetDecl) (k : Code) =>\n      modify fun s => s.push decl.value\n      go k\n    | .fun decl k | .jp decl k =>\n      go decl.value\n      go k\n
  | .cases (cases : CasesCore Code) => cases.alts.forM (go ·.getCode)\n    | .jmp .. | .return .. | .unreach .. => return ()\n  start (decls : Array Decl) : StateRefT (Array LetValue) CompilerM Unit :=\n    decls.forM
 (go ·.value)', start=(46, 1), end=(61, 28), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.getJps', code='partial def getJps : Probe Decl FunDecl := fun decls => do\n  let (_, res) ← start de
cls |>.run #[]\n  return res\nwhere\n  go (code : Code) : StateRefT (Array FunDecl) CompilerM Unit := do\n    match code with\n    | .let _ k => go k\n    | .fun decl k => go decl.value; go k\n    | .jp decl k => modi
fy (·.push decl); go decl.value; go k\n    | .cases cs => cs.alts.forM (go ·.getCode)\n    | .jmp .. | .return .. | .unreach .. => return ()\n\n  start (decls : Array Decl) : StateRefT (Array FunDecl) CompilerM Unit :
=\n    decls.forM fun decl => go decl.value', start=(63, 1), end=(76, 41), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.filterByLet', code='partial def filterByLet (f : LetDecl → CompilerM B
ool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code → CompilerM Bool\n  | .let decl k => do if (← f decl) then return true else go k\n  | .fun decl k | .jp decl k => go decl.value <||>
go k\n  | .cases cs => cs.alts.anyM (go ·.getCode)\n  | .jmp .. | .return .. | .unreach .. => return false', start=(78, 1), end=(85, 55), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.filterB
yFun', code='partial def filterByFun (f : FunDecl → CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code → CompilerM Bool\n  | .let _ k | .jp _ k  => go k\n  | .fun decl k =>
do if (← f decl) then return true else go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go ·.getCode)\n  | .jmp .. | .return .. | .unreach .. => return false', start=(87, 1), end=(94, 55), kind='commanddeclarat
ion'), Premise(full_name='Lean.Compiler.LCNF.Probe.filterByJp', code='partial def filterByJp (f : FunDecl → CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code → CompilerM Bo
ol\n  | .let _ k => go k\n  | .fun decl k => go decl.value <||> go k\n  | .jp decl k => do if (← f decl) then return true else go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go ·.getCode)\n  | .jmp .. | .retu
rn .. | .unreach .. => return false', start=(96, 1), end=(104, 55), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.filterByFunDecl', code='partial def filterByFunDecl (f : FunDecl → CompilerM
Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code → CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k => do if (← f decl) then return true else go decl.value <||> go
 k\n  | .cases cs => cs.alts.anyM (go ·.getCode)\n  | .jmp .. | .return .. | .unreach .. => return false', start=(106, 1), end=(113, 55), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.filterB
yCases', code='partial def filterByCases (f : Cases → CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code → CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k
 => go decl.value <||> go k\n  | .cases cs => do if (← f cs) then return true else cs.alts.anyM (go ·.getCode)\n  | .jmp .. | .return .. | .unreach .. => return false', start=(115, 1), end=(122, 55), kind='commanddecl
aration'), Premise(full_name='Lean.Compiler.LCNF.Probe.filterByJmp', code='partial def filterByJmp (f : FVarId → Array Arg → CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Co
de → CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k => go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go ·.getCode)\n  | .jmp fn var => f fn var\n  | .return .. | .unreach .. => return fal
se', start=(124, 1), end=(132, 45), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.filterByReturn', code='partial def filterByReturn (f : FVarId → CompilerM Bool) : Probe Decl Decl :=\n  filte
r (fun decl => go decl.value)\nwhere\n  go : Code → CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k => go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go ·.getCode)\n  | .jmp .. | .unreach .
. => return false\n  | .return var  => f var', start=(134, 1), end=(142, 26), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.filterByUnreach', code='partial def filterByUnreach (f : Expr → Com
pilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code → CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k => go decl.value <||> go k\n  | .cases cs => cs.alts.any
M (go ·.getCode)\n  | .jmp .. | .return .. => return false\n  | .unreach typ  => f typ', start=(144, 1), end=(152, 27), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.declNames', code='@[inlin
e]\ndef declNames : Probe Decl Name :=\n  Probe.map (fun decl => return decl.name)', start=(154, 1), end=(156, 43), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.toString', code='@[inline]\nd
ef toString [ToString α] : Probe α String :=\n  Probe.map (return ToString.toString ·)', start=(158, 1), end=(160, 41), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.count', code='@[inline]\n
def count : Probe α Nat := fun data => return #[data.size]', start=(162, 1), end=(163, 59), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.sum', code='@[inline]\ndef sum : Probe Nat Nat := fun
 data => return #[data.foldl (init := 0) (·+·)]', start=(165, 1), end=(166, 78), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.tail', code='@[inline]\ndef tail (n : Nat) : Probe α α := fun da
ta => return data[data.size - n:]', start=(168, 1), end=(169, 74), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.head', code='@[inline]\ndef head (n : Nat) : Probe α α := fun data => return d
ata[:n]', start=(171, 1), end=(172, 62), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.runOnModule', code='def runOnModule (moduleName : Name) (probe : Probe Decl β) (phase : Phase := Phase.b
ase): CoreM (Array β) := do\n  let ext := getExt phase\n  let env ← getEnv\n  let some modIdx := env.getModuleIdx? moduleName | throwError "module `{moduleName}` not found"\n  let decls := ext.getModuleEntries env mod
Idx\n  probe decls |>.run (phase := phase)', start=(174, 1), end=(179, 38), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.runGlobally', code='def runGlobally (probe : Probe Decl β) (phase : P
hase := Phase.base) : CoreM (Array β) := do\n  let ext := getExt phase\n  let env ← getEnv\n  let mut decls := #[]\n  for modIdx in [:env.allImportedModuleNames.size] do\n    decls := decls.append <| ext.getModuleEntr
ies env modIdx\n  probe decls |>.run (phase := phase)', start=(181, 1), end=(187, 38), kind='commanddeclaration'), Premise(full_name='Lean.Compiler.LCNF.Probe.toPass', code='def toPass [ToString β] (probe : Probe Decl
 β) (phase : Phase) : Pass where\n  phase := phase\n  name := `probe\n  run := fun decls => do\n    let res ← probe decls\n    trace[Compiler.probe] s!"{res}"\n    return decls', start=(189, 1), end=(195, 17), kind='c
ommanddeclaration')]), PremiseFile(path=PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Window.lean'), imports=['.lake/packages/lean4/src/lean/Lean/Data/Json.lean'], premises=[Premise(full_name='MessageType', c
ode='inductive MessageType where\n  | error\n  | warning\n  | info\n  | log', start=(11, 1), end=(15, 8), kind='commanddeclaration'), Premise(full_name='ShowMessageParams', code='structure ShowMessageParams where\n  t
ype    : MessageType\n  message : String\n  deriving FromJson, ToJson', start=(32, 1), end=(35, 28), kind='commanddeclaration'), Premise(full_name='MessageActionItem', code='structure MessageActionItem where\n  title
: String\n  deriving FromJson, ToJson', start=(37, 1), end=(39, 28), kind='commanddeclaration'), Premise(full_name='ShowMessageRequestParams', code='structure ShowMessageRequestParams where\n  type     : MessageType\n
  message  : String\n  actions? : Option (Array MessageActionItem)\n  deriving FromJson, ToJson', start=(41, 1), end=(45, 28), kind='commanddeclaration'), Premise(full_name='ShowMessageResponse', code='def ShowMessage
Response := Option MessageActionItem\n  deriving FromJson, ToJson', start=(47, 1), end=(48, 28), kind='commanddeclaration')]), PremiseFile(path=PosixPath('Debate.lean'), imports=['Comp/Oracle.lean', 'Debate/Cost.lean'
, 'Debate/Details.lean', 'Prob/Pmf.lean', 'Comp/Defs.lean', 'Prob/Defs.lean', 'Comp/Basic.lean', '.lake/packages/lean4/src/lean/Init.lean', 'Debate/Correct.lean', 'Debate/Protocol.lean'], premises=[])], files_traced=[
PosixPath('Debate.lean'), PosixPath('Comp/Basic.lean'), PosixPath('Comp/Defs.lean'), PosixPath('Comp/Oracle.lean'), PosixPath('Misc/If.lean'), PosixPath('Misc/Finset.lean'), PosixPath('Prob/Pmf.lean'), PosixPath('Prob
/Basics.lean'), PosixPath('Prob/Defs.lean'), PosixPath('Prob/Estimate.lean'), PosixPath('Prob/Arith.lean'), PosixPath('Prob/Chernoff.lean'), PosixPath('Prob/Cond.lean'), PosixPath('Prob/Bernoulli.lean'), PosixPath('De
bate/Correct.lean'), PosixPath('Debate/Cost.lean'), PosixPath('Debate/Protocol.lean'), PosixPath('Debate/Details.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake.lean'), PosixPath('.lake/packages/lean4/src/l
ean/Init.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Coe.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/ByCases.lean'), PosixPath('.lake/packages/
lean4/src/lean/Init/Ext.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Core.lean'), Posix
Path('.lake/packages/lean4/src/lean/Init/WF.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/MetaTypes.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/RCases.lean'), PosixPath('.lake/packages/lean4/src/lean
/Init/Meta.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Tactics.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Hints.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/System.lean'), PosixPath('.lak
e/packages/lean4/src/lean/Init/Dynamic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Guard.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/MacroTrace.lean'), PosixPath('.lake/packages/lean4/src/lean/Init
/TacticsExtra.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/SizeOfLemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Util.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/SimpLemmas.lean'), Posi
xPath('.lake/packages/lean4/src/lean/Init/Simproc.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/ShareCommon.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Prelude.lean'), PosixPath('.lake/packages/lean4
/src/lean/Init/SizeOf.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/BinderPredicates.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/PropLemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Class
ical.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Omega.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Notation.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/GetElem.lean'), PosixPath('.lake/pa
ckages/lean4/src/lean/Init/Conv.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/WFTactics.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/NotationExtra.lean'), PosixPath('.lake/packages/lean4/src/lean/Init
/Data/Sum.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/OfScientific.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Int.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Cast.lean'),
PosixPath('.lake/packages/lean4/src/lean/Init/Data/Float.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Random.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Format.lean'), PosixPath('.lake/pac
kages/lean4/src/lean/Init/Data/Nat.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Channel.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Queue.lean'), PosixPath('.lake/packages/lean4/src/lean/I
nit/Data/Hashable.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/ByteArray.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/BitVec.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Char.
lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Repr.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/UInt.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Option.lean'), PosixPath('.lak
e/packages/lean4/src/lean/Init/Data/Range.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/String.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/ToString.lean'), PosixPath('.lake/packages/lean4/s
rc/lean/Init/Data/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Array.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Prod.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Fin.l
ean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/List.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Bool.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/FloatArray.lean'), PosixPath('.
lake/packages/lean4/src/lean/Init/Data/Stream.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Ord.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/AC.lean'), PosixPath('.lake/packages/lean4/src/le
an/Init/Data/ByteArray/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Array/BinSearch.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Array/Subarray.lean'), PosixPath('.lake/packages/lean4
/src/lean/Init/Data/Array/Lemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Array/BasicAux.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Array/DecidableEq.lean'), PosixPath('.lake/packages
/lean4/src/lean/Init/Data/Array/InsertionSort.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Array/QSort.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean'), PosixPath('.lake/pack
ages/lean4/src/lean/Init/Data/Array/Mem.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Array/Subarray/Split.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/ToString/Basic.lean'), PosixPath('.lak
e/packages/lean4/src/lean/Init/Data/ToString/Macro.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/FloatArray/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Fin/Basic.lean'), PosixPath('.l
ake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Fin/Fold.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Fin/Iterate.lean'), PosixPath('.lake/pack
ages/lean4/src/lean/Init/Data/Fin/Log2.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean'), PosixPath('.lake/packages
/lean4/src/lean/Init/Data/Option/Instances.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Option/BasicAux.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/String/Extra.lean'), PosixPath('.lake/pa
ckages/lean4/src/lean/Init/Data/String/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/List/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/List/Impl.lean'), PosixPath('.lake/packages
/lean4/src/lean/Init/Data/List/Lemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/List/BasicAux.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/List/Control.lean'), PosixPath('.lake/packages/
lean4/src/lean/Init/Data/UInt/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/UInt/Log2.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Int/Pow.lean'), PosixPath('.lake/packages/lean4/src/l
ean/Init/Data/Int/DivMod.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Int/Gcd.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/
Init/Data/Int/Lemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Int/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Int/Bitwise.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Da
ta/Int/Order.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/BitVec/Bitblast.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/BitVec/Folds.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Dat
a/BitVec/Lemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/BitVec/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Char/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/
Format/Instances.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Format/Syntax.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Format/Macro.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/D
ata/Format/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Linear.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/SOM.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/
Dvd.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Mod.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Control.lean'
), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Lcm.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Simproc.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean'), PosixPa
th('.lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Compare.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Bitwise.lean'), PosixPath('.lak
e/packages/lean4/src/lean/Init/Data/Nat/Log2.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Power2.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/MinMax.lean'), PosixPath('.lake/package
s/lean4/src/lean/Init/Data/Nat/Div.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Bitwise/Lemmas.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Data/Nat/Bitwise/Basic.lean'), PosixPath('.lake/pa
ckages/lean4/src/lean/Init/Omega/Logic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Omega/IntList.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Omega/Constraint.lean'), PosixPath('.lake/packages/lean4
/src/lean/Init/Omega/LinearCombo.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Omega/Coeffs.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Omega/Int.lean'), PosixPath('.lake/packages/lean4/src/lean/Init
/Control/Lawful.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/Reader.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/State.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/St
ateRef.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/Id.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/Except.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/StateCps.lean'
), PosixPath('.lake/packages/lean4/src/lean/Init/Control/ExceptCps.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/Option.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/Basic.lean'), Posix
Path('.lake/packages/lean4/src/lean/Init/Control/EState.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/Lawful/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/Control/Lawful/Instances.lean'),
 PosixPath('.lake/packages/lean4/src/lean/Init/System/ST.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/System/Promise.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/System/Mutex.lean'), PosixPath('.lake
/packages/lean4/src/lean/Init/System/Uri.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/System/IOError.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/System/FilePath.lean'), PosixPath('.lake/packages/lea
n4/src/lean/Init/System/IO.lean'), PosixPath('.lake/packages/lean4/src/lean/Init/System/Platform.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Runtime
.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Widget.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Modifiers.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/ScopedEnvExtension.lean'), PosixPath(
'.lake/packages/lean4/src/lean/Lean/KeyedDeclsAttribute.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/BuiltinDocAttr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser.lean'), PosixPath('.lake/packag
es/lean4/src/lean/Lean/LazyInitExtension.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/LocalContext.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/DeclarationRange.lean'), PosixPath('.lake/packages/lean
4/src/lean/Lean/Syntax.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/LoadDynlib.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Declaration.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Linter.le
an'), PosixPath('.lake/packages/lean4/src/lean/Lean/ToExpr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/ReservedNameAction.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server.lean'), PosixPath('.lake
/packages/lean4/src/lean/Lean/ParserCompiler.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Exception.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/HeadIndex.lean'), PosixPath('.lake/packages/lean4/src/
lean/Lean/PrettyPrinter.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Eval.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/ImportingFlag.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab.lean'),
 PosixPath('.lake/packages/lean4/src/lean/Lean/Log.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Class.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Structure.lean'), PosixPath('.lake/packages/lean4/sr
c/lean/Lean/Meta.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Message.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/ReducibilityAttrs.lean'),
 PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/ProjFns.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/LabelAttribute.lean'), PosixPath('.lake/packa
ges/lean4/src/lean/Lean/Environment.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Attributes.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Replay.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/R
esolveName.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Hygiene.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/AuxRecursor.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/CoreM.lean'), PosixPath(
'.lake/packages/lean4/src/lean/Lean/Expr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/SubExpr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/MonadEnv.lean'), PosixPath('.lake/packages/lean4/src/lean/Le
an/MetavarContext.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/InternalExceptionId.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/DocString.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Level.l
ean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/OpenDecl.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/PersistentArray.lean'), Posi
xPath('.lake/packages/lean4/src/lean/Lean/Data/JsonRpc.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/HashMap.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Array.lean'), PosixPath('.lake/packa
ges/lean4/src/lean/Lean/Data/NameMap.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Trie.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/FuzzyMatching.lean'), PosixPath('.lake/packages/lean4/src
/lean/Lean/Data/Name.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Rat.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/PersistentHashMap.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Da
ta/Format.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/AssocList.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/LOption.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/PersistentHa
shSet.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Options.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/SMap.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/KVMap.lean'), PosixPa
th('.lake/packages/lean4/src/lean/Lean/Data/Parsec.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/PrefixTree.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/HashSet.lean'), PosixPath('.lake/pack
ages/lean4/src/lean/Lean/Data/RBTree.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Position.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Json.lean'), PosixPath('.lake/packages/lean4/src/lean
/Lean/Data/RBMap.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Xml.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/NameTrie.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/LBool.lean
'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/SSet.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Communication.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Diagnostics.lean'
), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Capabilities.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/CodeActions.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Window.l
ean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/InitShutdown.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Internal.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/TextSyn
c.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/LanguageFeatures.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Workspace.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp
/Utf16.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Extra.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Ipc.lean'
), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Lsp/Client.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Json/Parser.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Json/Printer.lean'), P
osixPath('.lake/packages/lean4/src/lean/Lean/Data/Json/Elab.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Json/FromToJson.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Json/Basic.lean'), Posi
xPath('.lake/packages/lean4/src/lean/Lean/Data/Json/Stream.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Xml/Parser.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Data/Xml/Basic.lean'), PosixPath('
.lake/packages/lean4/src/lean/Lean/Server/CodeActions.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/InfoUtils.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/FileWorker.lean'), PosixPath('.
lake/packages/lean4/src/lean/Lean/Server/Snapshots.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/FileSource.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/AsyncList.lean'), PosixPath('.lak
e/packages/lean4/src/lean/Lean/Server/Utils.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/CompletionItemData.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/GoTo.lean'), PosixPath('.lake/pa
ckages/lean4/src/lean/Lean/Server/Rpc.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/Completion.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/ImportCompletion.lean'), PosixPath('.lake/pack
ages/lean4/src/lean/Lean/Server/References.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/Watchdog.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/Requests.lean'), PosixPath('.lake/packages/
lean4/src/lean/Lean/Server/FileWorker/Utils.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/FileWorker/SetupFile.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/FileWorker/WidgetRequests.lean
'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/FileWorker/RequestHandling.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/Rpc/RequestHandling.lean'), PosixPath('.lake/packages/lean4/src/lean/Lea
n/Server/Rpc/Deriving.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/CodeActions/Basic.lean'), PosixPath('.lake/packages/lean4/src/l
ean/Lean/Server/CodeActions/Provider.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Server/CodeActions/Attr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Linter/Builtin.lean'), PosixPath('.lake/packages
/lean4/src/lean/Lean/Linter/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Linter/Util.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Linter/UnusedVariables.lean'), PosixPath('.lake/packages/lean4/
src/lean/Lean/Linter/Deprecated.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Linter/MissingDocs.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/PrettyPrinter/Parenthesizer.lean'), PosixPath('.lake/packa
ges/lean4/src/lean/Lean/PrettyPrinter/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/PrettyPrinter/Formatter.lean'), PosixPa
th('.lake/packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Options.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/TopDownAnalyze.lean'), PosixPath('.lake/packages/lean4/src/lean/
Lean/PrettyPrinter/Delaborator/FieldNotation.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/SubExp
r.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Builtins.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Attributes.lean'), PosixPath('.lake/packages/l
ean4/src/lean/Lean/Compiler/InitAttr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/NameMangling.lean'), PosixPath('.lake/packages/lean
4/src/lean/Lean/Compiler/Options.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/InlineAttrs.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/AtMostOnce.lean'), PosixPath('.lake/packages/l
ean4/src/lean/Lean/Compiler/FFI.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/Specialize.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/Old.lean'), PosixPath('.lake/packages/lean4/src/
lean/Lean/Compiler/CSimpAttr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/ClosedTermCache.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/ExportAttr.lean'), PosixPath('.lake/packages/l
ean4/src/lean/Lean/Compiler/NeverExtractAttr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/ConstFolding.lean'), PosixPath('.lake/pac
kages/lean4/src/lean/Lean/Compiler/BorrowedAnnotation.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/NoncomputableAttr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/Main.lean'), PosixP
ath('.lake/packages/lean4/src/lean/Lean/Compiler/ExternAttr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/ImplementedByAttr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/ToLCNF.l
ean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/CSE.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Comp
ilerM.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Main.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/ConfigOptions.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Co
mpiler/LCNF/LambdaLifting.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/PullLetDecls.lean'), PosixPath('.lake/package
s/lean4/src/lean/Lean/Compiler/LCNF/ScopeM.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean'), PosixPath('.lake/pa
ckages/lean4/src/lean/Lean/Compiler/LCNF/FloatLetIn.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/ToMono.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean'), Po
sixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/AuxDeclCache.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Level.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Othe
rDecl.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/ReduceJpArity.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/FixedParams.lean'), PosixPath('.lake/packages/lean4/src/lean/
Lean/Compiler/LCNF/DeclHash.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/ElimDead.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Probing.lean'), PosixPath('.lake/packages/le
an4/src/lean/Lean/Compiler/LCNF/MonoTypes.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Specialize.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/JoinPoints.lean'), PosixPath
('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/ToDecl.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/ElimDeadBranches.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Bind.l
ean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/AlphaEqv.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Renaming.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/L
CNF/DependsOn.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/LCtx.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/PullFunDecls.lean'), PosixPath('.lake/packages/lean4/src/lean/
Lean/Compiler/LCNF/ForEachExpr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/MonadScope.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/SpecInfo.lean'), PosixPath('.lake/packa
ges/lean4/src/lean/Lean/Compiler/LCNF/Closure.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/BaseTypes.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/CompatibleTypes.lean'), P
osixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/PrettyPrinter.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/FVarUtil.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF
/Testing.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Util.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Check.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compile
r/LCNF/Passes.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/ToExpr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean'), PosixPath('.lake/packages/lean4/src/lean/Le
an/Compiler/LCNF/ReduceArity.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Internalize.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpM.lean'), PosixPath('.lake/pack
ages/lean4/src/lean/Lean/Compiler/LCNF/Simp/ConstantFold.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/DiscrM.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Default
Alt.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Main.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/FunDeclInfo.lean'), PosixPath('.lake/packages/lean4/src/lean/L
ean/Compiler/LCNF/Simp/InlineCandidate.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpValue.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/JpCases.lean'), PosixP
ath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/InlineProj.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Config.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF
/Simp/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Used.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/CtorLayout.lean'), PosixPath('.lake/packages/lean4/src/lean/L
ean/Compiler/IR/NormIds.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/UnboxResult.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/EmitUtil.lean'), PosixPath('.lake/packages/lean4/
src/lean/Lean/Compiler/IR/Borrow.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/Format.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/SimpCase.lean'), PosixPath('.lake/packages/le
an4/src/lean/Lean/Compiler/IR/Checker.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/ExpandResetReuse.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/ResetReuse.lean'), PosixPath('
.lake/packages/lean4/src/lean/Lean/Compiler/IR/ElimDeadBranches.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/PushProj.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/Boxing.lean'
), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/RC.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/FreeVars.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.le
an'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/EmitLLVM.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/EmitC.
lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/LLVMBindings.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/LiveVars.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/
IR/Sorry.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Compiler/IR/ElimDeadVars.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/ParserCompiler/Attribute.lean'), PosixPath('.lake/packages/lean4/src/lean/L
ean/Parser/StrInterpolation.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Level.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/P
arser/Extension.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Tactic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Syntax.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Do.l
ean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Types.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Command.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Term.lean'), PosixPat
h('.lake/packages/lean4/src/lean/Lean/Parser/Module.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Extra.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Parser/Attr.lean'), PosixPath('.lake/package
s/lean4/src/lean/Lean/Elab/AutoBound.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/GenInjective.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Config.lean'), PosixPath('.lake/packages/lean4/sr
c/lean/Lean/Elab/Deriving.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/MatchExpr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/DeclModifiers.lean'), PosixPath('.lake/packages/lean4/src/lean/
Lean/Elab/Binders.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/InfoTree.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/BuiltinNotation.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/El
ab/AuxDef.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Attributes.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/BinderPredicates.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Se
tOption.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Eval.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/BuiltinTerm.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/DeclNameGen.lea
n'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/BindersUtil.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Frontend.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/DeclUtil.lean'), Posix
Path('.lake/packages/lean4/src/lean/Lean/Elab/Inductive.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Calc.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/DefView.lean'), PosixPath('.lake/packa
ges/lean4/src/lean/Lean/Elab/Syntax.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/ParseImportsFast.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/ElabRules.lean'), PosixPath('.lake/packages/le
an4/src/lean/Lean/Elab/StructInst.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Mixfix.lean'), PosixPath('.lake/packages/lean4/src
/lean/Lean/Elab/Structure.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean'), PosixPath('.lake/packages/lean4/sr
c/lean/Lean/Elab/Exception.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/MutualDef.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Open.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Ela
b/Command.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/ComputedFields.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/InheritDoc.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Decl
aration.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/MacroRules.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Extra.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/GuardMsgs.lean'
), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/CheckTactic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Do.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Arg.lean'), PosixPath('.lake/p
ackages/lean4/src/lean/Lean/Elab/BuiltinCommand.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Print.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic.lean'), PosixPath('.lake/packages/lean
4/src/lean/Lean/Elab/Match.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Level.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Util.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/No
tation.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Term.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Quotation.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/LetRec.lean'), Pos
ixPath('.lake/packages/lean4/src/lean/Lean/Elab/App.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/MatchAltView.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Import.lean'), PosixPath('.lake/pa
ckages/lean4/src/lean/Lean/Elab/MacroArgUtil.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Macro.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PatternVar.lean'), PosixPath('.lake/packages/lea
n4/src/lean/Lean/Elab/RecAppSyntax.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/Nonempty.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean'), PosixPath('.lake/packag
es/lean4/src/lean/Lean/Elab/Deriving/DecEq.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/Repr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/Hashable.lean'), PosixPath('.lake
/packages/lean4/src/lean/Lean/Elab/Deriving/BEq.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/SizeOf.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/TypeName.lean'), PosixPath
('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/FromToJson.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/Ord.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/Inhabited.lean'
), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/InfoTree/Main.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/InfoTree/Types.le
an'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/Main.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/Eqns.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreD
efinition/WF.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/MkInhabitant.lean'), PosixPath('.lake/packages/lean4
/src/lean/Lean/Elab/PreDefinition/Structural.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/GuessLex.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Termination
Argument.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Eqns.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Preprocess.lean'), PosixPath('.lake/packages/lean4/
src/lean/Lean/Elab/PreDefinition/WF/Fix.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/TerminationHint.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Rel.lean'
), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Ite.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Main.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Pr
eDefinition/WF/PackMutual.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Main.lean'), Posi
xPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Eqns.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/BRecOn.lean'), PosixPath('.lake/packages/lean4/src/lean/
Lean/Elab/PreDefinition/Structural/Preprocess.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/SmartUnfolding.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition
/Structural/FindRecArg.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/IndPred.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Meta.lean'), PosixPath('.lake/packag
es/lean4/src/lean/Lean/Elab/Tactic/Calc.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/LibrarySearch.lean'), PosixPath('.la
ke/packages/lean4/src/lean/Lean/Elab/Tactic/Simpa.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Injection.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Simp.lean'), PosixPath('.
lake/packages/lean4/src/lean/Lean/Elab/Tactic/Generalize.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/BuiltinTactic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Split.lean'),
PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/RCases.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Simproc.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean')
, PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Omega.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Congr.lean
'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Symm.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/ShowTerm.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Rewrites.
lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Change.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Ext.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Match.le
an'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Rfl.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Config.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Induction.
lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/NormCast.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/FalseOrByContra.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/T
actic/SolveByElim.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Delta.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Cache.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/E
lab/Tactic/Conv.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/SimpTrace.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Repeat.lean'), PosixPath('.lake/packages/lean4/src/lean/Lea
n/Elab/Tactic/Unfold.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Guard.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Rewrite.lean'), PosixPath('.lake/packages/lean4/src/lean/L
ean/Elab/Tactic/Conv/Pattern.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Rewrite.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Congr.lean'), PosixPath('.lake/package
s/lean4/src/lean/Lean/Elab/Tactic/Conv/Unfold.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Change.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Simp.lean'), PosixPath
('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Delta.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Omega/MinNatAb
s.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Omega/Frontend.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Tactic/Omega/OmegaM.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/E
lab/Tactic/Omega/Core.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Quotation/Util.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Elab/Quotation/Precheck.lean'), PosixPath('.lake/packages/lean4/src
/lean/Lean/Language/Lean.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Language/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Widget/TaggedText.lean'), PosixPath('.lake/packages/lean4/src/lean/Le
an/Widget/InteractiveCode.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Widget/InteractiveGoal.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Widget/InteractiveDiagnostic.lean'), PosixPath('.lake/packag
es/lean4/src/lean/Lean/Widget/UserWidget.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Widget/Diff.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Widget/Basic.lean'), PosixPath('.lake/packages/lean4/src
/lean/Lean/Widget/Types.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/Trace.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/SCC.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/Collec
tLevelParams.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/FileSetupInfo.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/HasConstCache.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util
/MonadCache.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/FindLevelMVar.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/OccursCheck.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/Pr
ofiler.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/FindExpr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/TestExtern.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/ReplaceLevel.
lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/Diff.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/FindMVar.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/FoldConsts.lean'), PosixPa
th('.lake/packages/lean4/src/lean/Lean/Util/PtrSet.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/CollectFVars.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/ForEachExprWhere.lean'), PosixPath(
'.lake/packages/lean4/src/lean/Lean/Util/Profile.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/ForEachExpr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean'), PosixPath('.lake/p
ackages/lean4/src/lean/Lean/Util/InstantiateLevelParams.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/MonadBacktrack.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/LakePath.lean'), PosixPath('
.lake/packages/lean4/src/lean/Lean/Util/Paths.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/Heartbeats.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/Sorry.lean'), PosixPath('.lake/packages/le
an4/src/lean/Lean/Util/LeanOptions.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/RecDepth.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/PPExt.lean'), PosixPath('.lake/packages/lean4/src/lean/
Lean/Util/ShareCommon.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/CollectMVars.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/Path.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Util/
Recognizers.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/CollectFVars.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Closure.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Transpa
rencyMode.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/SynthInstance.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Eqns.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/GeneralizeT
elescope.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/ArgsPacker.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Injective.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/DiscrTreeT
ypes.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Offset.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Instances.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/ExprDefEq.lean'),
PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/AppBuilder.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/KExprMap.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/CompletionName.lean'), Posix
Path('.lake/packages/lean4/src/lean/Lean/Meta/DecLevel.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Iterator.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/ExprTraverse.lean'), PosixPath('.la
ke/packages/lean4/src/lean/Lean/Meta/LevelDefEq.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/RecursorInfo.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Eval.lean'), PosixPath('.lake/packages
/lean4/src/lean/Lean/Meta/MatchUtil.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/SizeOf.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/LitValues.lean'), PosixPath('.lake/packages/lean4/src/le
an/Lean/Meta/Canonicalizer.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/GeneralizeVars.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/AbstractMVars.lean'), PosixPath('.lake/packages/lean4/src
/lean/Lean/Meta/ReduceEval.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/IndPredBelow.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/PPGoal.lean'), PosixPath('.lake/packages/lean4/src/lean/Lea
n/Meta/WHNF.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/DiscrTree.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/ExprLens.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/ForEachEx
pr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Inductive.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/GetUnfoldableConst.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/CollectM
Vars.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/AbstractNestedProofs.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/CheckTactic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Co
eAttr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/KAbstract.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/FunInfo.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/InferType.lean')
, PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Structure.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Constructions.lean'), PosixPa
th('.lake/packages/lean4/src/lean/Lean/Meta/Reduce.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/GlobalInstances.lean'), PosixPath('.lake/p
ackages/lean4/src/lean/Lean/Meta/Diagnostics.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Transform.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Coe.lean'), PosixPath('.lake/packages/lean4/
src/lean/Lean/Meta/LazyDiscrTree.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/CongrTheorems.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Check.lean'), PosixPath('.lake/packages/lean4/src/le
an/Lean/Meta/CtorRecognizer.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/NatInstTesters.lean'), PosixPath('.lake/packages/lean4/src/lean/L
ean/Meta/UnificationHint.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/ACLt.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/NormCast.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean
/Meta/Tactic/UnifyEq.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Constructor.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean'), PosixPath('.lake/packages/lean4/src/le
an/Lean/Meta/Tactic/Symm.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Rewrites.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean'), PosixPath('.lake/packages/lean4/
src/lean/Lean/Meta/Tactic/Induction.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Contradiction.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Rewrite.lean'), PosixPath('.lake/pa
ckages/lean4/src/lean/Lean/Meta/Tactic/SplitIf.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Injection.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/FVarSubst.lean'), PosixPath(
'.lake/packages/lean4/src/lean/Lean/Meta/Tactic/IndependentOf.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Delta.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean'), Posi
xPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Split.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp.lean'), PosixP
ath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/SolveByElim.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Refl.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean'), Po
sixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/AC.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Backtrack.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean'), Po
sixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/LibrarySearch.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Acy
clic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/FunInd.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/ElimInfo.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tacti
c/Generalize.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/TryThis.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/AuxLemma.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/M
eta/Tactic/Rename.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Congr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Replace.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean
/Meta/Tactic/Repeat.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Cleanup.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Rfl.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean
/Meta/Tactic/Unfold.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Revert.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean'), PosixPath('.lake/packages/lean4/src/lean/Le
an/Meta/Tactic/Subst.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Simp.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Solver.lean'), PosixPath('.lake/pac
kages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/M
ain.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Simp.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Solver.lean'), PosixPath('.lake/packages/lea
n4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/AC/Main.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/RegisterCommand.lean'
), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Simproc.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/S
imp/Attr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Diagnostics.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Rewrite.lean'), PosixPath('.lake/packages/lean4/src/le
an/Lean/Meta/Tactic/Simp/SimpTheorems.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/BuiltinSimprocs.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpCongrTheorems.lea
n'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpAll.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Types.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tacti
c/Simp/BuiltinSimprocs/UInt.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/BuiltinSimprocs/Util.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/BuiltinSimprocs/Nat.lean')
, PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/BuiltinSimprocs/Int.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/BuiltinSimprocs/Core.lean'), PosixPath('.lake/packages/lean4/
src/lean/Lean/Meta/Tactic/Simp/BuiltinSimprocs/BitVec.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/BuiltinSimprocs/String.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Sim
p/BuiltinSimprocs/Char.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Tactic/Simp/BuiltinSimprocs/Fin.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/ArgsPacker/Basic.lean'), PosixPath('.lake/pa
ckages/lean4/src/lean/Lean/Meta/Match/MatchEqsExt.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/Match.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/MatcherApp.lean'), PosixPath('.
lake/packages/lean4/src/lean/Lean/Meta/Match/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/MatchPatternAttr.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/CaseValues.lean'),
PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/MatchEqs.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/Value.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/CaseArraySizes.
lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/MatcherInfo.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/MVarRenaming.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Mat
ch/MatcherApp/Transform.lean'), PosixPath('.lake/packages/lean4/src/lean/Lean/Meta/Match/MatcherApp/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Version.lean'), PosixPath('.lake/packages/lean4/src/
lean/lake/Lake/Build.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Toml.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/DSL.lea
n'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Load.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/CLI.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Main.lean'), PosixPath('.lake/pack
ages/lean4/src/lean/lake/Lake/Load/Manifest.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Load/Main.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Load/Package.lean'), PosixPath('.lake/package
s/lean4/src/lean/lake/Lake/Load/Config.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Load/Materialize.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Load/Elab.lean'), PosixPath('.lake/packages
/lean4/src/lean/lake/Lake/Load/Toml.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/DSL/DeclUtil.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/DSL/Extensions.lean'), PosixPath('.lake/packages/l
ean4/src/lean/lake/Lake/DSL/Require.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/DSL/Config.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/DSL/Targets.lean'), PosixPath('.lake/packages/lean4/
src/lean/lake/Lake/DSL/Script.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/DSL/Meta.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/DSL/Package.lean'), PosixPath('.lake/packages/lean4/src/lean
/lake/Lake/DSL/Attributes.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Toml/ParserUtil.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Toml/Load.lean'), PosixPath('.lake/packages/lean4/src/lea
n/lake/Lake/Toml/Decode.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Toml/Elab.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Toml/Grammar.lean'), PosixPath('.lake/packages/lean4/src/lean/lak
e/Lake/Toml/Encode.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Toml/Data.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Toml/Data/Value.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/
Lake/Toml/Data/Dict.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Toml/Data/DateTime.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Toml/Elab/Expression.lean'), PosixPath('.lake/packages/lean4
/src/lean/lake/Lake/Toml/Elab/Value.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/ExternLibConfig.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Dependency.lean'), PosixPath('.la
ke/packages/lean4/src/lean/lake/Lake/Config/Module.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/LeanLib.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Package.lean'), PosixPath(
'.lake/packages/lean4/src/lean/lake/Lake/Config/WorkspaceConfig.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Glob.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Monad.lean'), Po
sixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Opaque.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Workspace.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Script.lean'
), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/LeanLibConfig.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Env.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Lang.l
ean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/TargetConfig.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/FacetConfig.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Co
nfig/LeanExeConfig.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/InstallPath.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/ExternLib.lean'), PosixPath('.lake/packages/lean4/src/
lean/lake/Lake/Config/LeanExe.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/Defaults.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Config/LeanConfig.lean'), PosixPath('.lake/packages/l
ean4/src/lean/lake/Lake/Config/Context.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/CLI/Main.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/CLI/Init.lean'), PosixPath('.lake/packages/lean4/sr
c/lean/lake/Lake/CLI/Build.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/CLI/Actions.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/CLI/Error.lean'), PosixPath('.lake/packages/lean4/src/lean/l
ake/Lake/CLI/Serve.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/CLI/Help.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/CLI/Translate.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lak
e/CLI/Translate/Lean.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/CLI/Translate/Toml.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Topological.lean'), PosixPath('.lake/packages/lean4/s
rc/lean/lake/Lake/Build/Index.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Basic.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Store.lean'), PosixPath('.lake/packages/lean4/src/l
ean/lake/Lake/Build/Facets.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Package.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Trace.lean'), PosixPath('.lake/packages/lean4/src/le
an/lake/Lake/Build/Data.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Key.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Info.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/
Lake/Build/Run.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Imports.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Executable.lean'), PosixPath('.lake/packages/lean4/src/lean/lake
/Lake/Build/Actions.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Module.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Library.lean'), PosixPath('.lake/packages/lean4/src/lean/lak
e/Lake/Build/Targets.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Job.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Build/Fetch.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/La
ke/Build/Common.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/OrdHashSet.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Git.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake
/Util/Store.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Error.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Log.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Loc
k.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Name.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Binder.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/EquipT.lean
'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Compare.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/OrderedTagAttribute.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/T
ask.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Family.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/EStateT.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/RBArra
y.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Exit.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Sugar.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Casing.lean'
), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Newline.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/IO.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Lift.lean'), PosixP
ath('.lake/packages/lean4/src/lean/lake/Lake/Util/MainM.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/NativeLib.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/FilePath.lean'), PosixP
ath('.lake/packages/lean4/src/lean/lake/Lake/Util/Cli.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/List.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/StoreInsts.lean'), PosixPath('
.lake/packages/lean4/src/lean/lake/Lake/Util/Proc.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/DRBMap.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Opaque.lean'), PosixPath('.lake/
packages/lean4/src/lean/lake/Lake/Util/Message.lean'), PosixPath('.lake/packages/lean4/src/lean/lake/Lake/Util/Cycle.lean'), PosixPath('.lake/packages/aesop/Aesop.lean'), PosixPath('.lake/packages/aesop/Aesop/Main.lea
n'), PosixPath('.lake/packages/aesop/Aesop/RuleSet.lean'), PosixPath('.lake/packages/aesop/Aesop/Frontend.lean'), PosixPath('.lake/packages/aesop/Aesop/Tracing.lean'), PosixPath('.lake/packages/aesop/Aesop/Percent.lea
n'), PosixPath('.lake/packages/aesop/Aesop/Rule.lean'), PosixPath('.lake/packages/aesop/Aesop/Exception.lean'), PosixPath('.lake/packages/aesop/Aesop/Check.lean'), PosixPath('.lake/packages/aesop/Aesop/BuiltinRules.le
an'), PosixPath('.lake/packages/aesop/Aesop/Constants.lean'), PosixPath('.lake/packages/aesop/Aesop/Index.lean'), PosixPath('.lake/packages/aesop/Aesop/Script.lean'), PosixPath('.lake/packages/aesop/Aesop/Options.lean
'), PosixPath('.lake/packages/aesop/Aesop/ElabM.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleTac.lean'), PosixPath('.lake/packages/aesop/Aesop/Builder.lean'), PosixPath('.lake/packages/aesop/Aesop/RulePattern.lea
n'), PosixPath('.lake/packages/aesop/Aesop/Tree.lean'), PosixPath('.lake/packages/aesop/Aesop/Nanos.lean'), PosixPath('.lake/packages/aesop/Aesop/Index/Basic.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleSet/Filte
r.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleSet/Member.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleSet/Name.lean'), PosixPath('.lake/packages/aesop/Aesop/Stats/Report.lean'), PosixPath('.lake/packages/ae
sop/Aesop/Stats/Basic.lean'), PosixPath('.lake/packages/aesop/Aesop/Stats/Extension.lean'), PosixPath('.lake/packages/aesop/Aesop/Search/Main.lean'), PosixPath('.lake/packages/aesop/Aesop/Search/RuleSelection.lean'),
PosixPath('.lake/packages/aesop/Aesop/Search/SearchM.lean'), PosixPath('.lake/packages/aesop/Aesop/Search/Expansion.lean'), PosixPath('.lake/packages/aesop/Aesop/Search/ExpandSafePrefix.lean'), PosixPath('.lake/packag
es/aesop/Aesop/Search/Queue.lean'), PosixPath('.lake/packages/aesop/Aesop/Search/Queue/Class.lean'), PosixPath('.lake/packages/aesop/Aesop/Search/Expansion/Simp.lean'), PosixPath('.lake/packages/aesop/Aesop/Search/Exp
ansion/Norm.lean'), PosixPath('.lake/packages/aesop/Aesop/Search/Expansion/Basic.lean'), PosixPath('.lake/packages/aesop/Aesop/Frontend/Extension.lean'), PosixPath('.lake/packages/aesop/Aesop/Frontend/Tactic.lean'), P
osixPath('.lake/packages/aesop/Aesop/Frontend/Attribute.lean'), PosixPath('.lake/packages/aesop/Aesop/Frontend/Command.lean'), PosixPath('.lake/packages/aesop/Aesop/Frontend/Basic.lean'), PosixPath('.lake/packages/aes
op/Aesop/Frontend/RuleExpr.lean'), PosixPath('.lake/packages/aesop/Aesop/Frontend/Extension/Init.lean'), PosixPath('.lake/packages/aesop/Aesop/Builder/Tactic.lean'), PosixPath('.lake/packages/aesop/Aesop/Builder/Basic
.lean'), PosixPath('.lake/packages/aesop/Aesop/Builder/Apply.lean'), PosixPath('.lake/packages/aesop/Aesop/Builder/Constructors.lean'), PosixPath('.lake/packages/aesop/Aesop/Builder/Forward.lean'), PosixPath('.lake/pa
ckages/aesop/Aesop/Builder/Cases.lean'), PosixPath('.lake/packages/aesop/Aesop/Builder/Default.lean'), PosixPath('.lake/packages/aesop/Aesop/Builder/NormSimp.lean'), PosixPath('.lake/packages/aesop/Aesop/Builder/Unfol
d.lean'), PosixPath('.lake/packages/aesop/Aesop/Rule/Name.lean'), PosixPath('.lake/packages/aesop/Aesop/Rule/Basic.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleTac/ElabRuleTerm.lean'), PosixPath('.lake/packages/a
esop/Aesop/RuleTac/Forward.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleTac/Apply.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleTac/Tactic.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleTac/Basic.lean'), P
osixPath('.lake/packages/aesop/Aesop/RuleTac/Cases.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleTac/Preprocess.lean'), PosixPath('.lake/packages/aesop/Aesop/RuleTac/Forward/Basic.lean'), PosixPath('.lake/packages
/aesop/Aesop/Tree/ExtractProof.lean'), PosixPath('.lake/packages/aesop/Aesop/Tree/Tracing.lean'), PosixPath('.lake/packages/aesop/Aesop/Tree/Traversal.lean'), PosixPath('.lake/packages/aesop/Aesop/Tree/RunMetaM.lean')
, PosixPath('.lake/packages/aesop/Aesop/Tree/Check.lean'), PosixPath('.lake/packages/aesop/Aesop/Tree/AddRapp.lean'), PosixPath('.lake/packages/aesop/Aesop/Tree/Free.lean'), PosixPath('.lake/packages/aesop/Aesop/Tree/
State.lean'), PosixPath('.lake/packages/aesop/Aesop/Tree/ExtractScript.lean'), PosixPath('.lake/packages/aesop/Aesop/Tree/TreeM.lean'), PosixPath('.lake/packages/aesop/Aesop/Tree/Data.lean'), PosixPath('.lake/packages
/aesop/Aesop/Tree/UnsafeQueue.lean'), PosixPath('.lake/packages/aesop/Aesop/Script/SpecificTactics.lean'), PosixPath('.lake/packages/aesop/Aesop/Script/ScriptBuilder.lean'), PosixPath('.lake/packages/aesop/Aesop/Scrip
t/TacticState.lean'), PosixPath('.lake/packages/aesop/Aesop/Script/UnstructuredScriptBuilder.lean'), PosixPath('.lake/packages/aesop/Aesop/Script/StructuredScriptBuilder.lean'), PosixPath('.lake/packages/aesop/Aesop/O
ptions/Public.lean'), PosixPath('.lake/packages/aesop/Aesop/Options/Internal.lean'), PosixPath('.lake/packages/aesop/Aesop/Util/UnorderedArraySet.lean'), PosixPath('.lake/packages/aesop/Aesop/Util/Tactic.lean'), Posix
Path('.lake/packages/aesop/Aesop/Util/EqualUpToIds.lean'), PosixPath('.lake/packages/aesop/Aesop/Util/Basic.lean'), PosixPath('.lake/packages/aesop/Aesop/Util/UnionFind.lean'), PosixPath('.lake/packages/aesop/Aesop/Bu
iltinRules/Split.lean'), PosixPath('.lake/packages/aesop/Aesop/BuiltinRules/Subst.lean'), PosixPath('.lake/packages/aesop/Aesop/BuiltinRules/DestructProducts.lean'), PosixPath('.lake/packages/aesop/Aesop/BuiltinRules/
Assumption.lean'), PosixPath('.lake/packages/aesop/Aesop/BuiltinRules/ApplyHyps.lean'), PosixPath('.lake/packages/aesop/Aesop/BuiltinRules/Intros.lean'), PosixPath('.lake/packages/aesop/Aesop/BuiltinRules/Ext.lean'),
PosixPath('.lake/packages/Qq/Qq.lean'), PosixPath('.lake/packages/Qq/Qq/Delab.lean'), PosixPath('.lake/packages/Qq/Qq/Macro.lean'), PosixPath('.lake/packages/Qq/Qq/Match.lean'), PosixPath('.lake/packages/Qq/Qq/Typ.lea
n'), PosixPath('.lake/packages/Qq/Qq/MetaM.lean'), PosixPath('.lake/packages/Qq/Qq/AssertInstancesCommute.lean'), PosixPath('.lake/packages/Qq/Qq/SortLocalDecls.lean'), PosixPath('.lake/packages/Qq/Qq/ForLean/ToExpr.l
ean'), PosixPath('.lake/packages/Qq/Qq/ForLean/Do.lean'), PosixPath('.lake/packages/Qq/Qq/ForLean/ReduceEval.lean'), PosixPath('.lake/packages/batteries/Batteries.lean'), PosixPath('.lake/packages/batteries/Batteries/
StdDeprecations.lean'), PosixPath('.lake/packages/batteries/Batteries/Logic.lean'), PosixPath('.lake/packages/batteries/Batteries/WF.lean'), PosixPath('.lake/packages/batteries/Batteries/CodeAction.lean'), PosixPath('
.lake/packages/batteries/Batteries/Linter.lean'), PosixPath('.lake/packages/batteries/Batteries/Classes/Cast.lean'), PosixPath('.lake/packages/batteries/Batteries/Classes/RatCast.lean'), PosixPath('.lake/packages/batt
eries/Batteries/Classes/Order.lean'), PosixPath('.lake/packages/batteries/Batteries/Classes/BEq.lean'), PosixPath('.lake/packages/batteries/Batteries/Classes/SatisfiesM.lean'), PosixPath('.lake/packages/batteries/Batt
eries/Util/ExtendedBinder.lean'), PosixPath('.lake/packages/batteries/Batteries/Util/CheckTactic.lean'), PosixPath('.lake/packages/batteries/Batteries/Util/Cache.lean'), PosixPath('.lake/packages/batteries/Batteries/U
til/Pickle.lean'), PosixPath('.lake/packages/batteries/Batteries/Util/LibraryNote.lean'), PosixPath('.lake/packages/batteries/Batteries/Util/ProofWanted.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Cas
e.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Classical.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Lint.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Instances.lean'),
 PosixPath('.lake/packages/batteries/Batteries/Tactic/SqueezeScope.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Init.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Basic.lean'), PosixPath
('.lake/packages/batteries/Batteries/Tactic/Where.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/PrintPrefix.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/ShowUnused.lean'), PosixPath('.la
ke/packages/batteries/Batteries/Tactic/OpenPrivate.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/NoMatch.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Congr.lean'), PosixPath('.lake/packa
ges/batteries/Batteries/Tactic/Unreachable.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/SeqFocus.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Exact.lean'), PosixPath('.lake/packages/bat
teries/Batteries/Tactic/Alias.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/PermuteGoals.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/PrintDependents.lean'), PosixPath('.lake/packages/ba
tteries/Batteries/Tactic/Lint/Simp.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Lint/Basic.lean'), PosixPath('.lake/packages/b
atteries/Batteries/Tactic/Lint/TypeClass.lean'), PosixPath('.lake/packages/batteries/Batteries/Tactic/Lint/Misc.lean'), PosixPath('.lake/packages/batteries/Batteries/Test/Internal/DummyLabelAttr.lean'), PosixPath('.la
ke/packages/batteries/Batteries/Data/DList.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Rat.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Sum.lean'), PosixPath('.lake/packages/batteries/Batt
eries/Data/Fin.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/BinomialHeap.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/List.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Pairing
Heap.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/BitVec.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/String.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/UInt.lean'), PosixPat
h('.lake/packages/batteries/Batteries/Data/AssocList.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Bool.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/MLList.lean'), PosixPath('.lake/packages/
batteries/Batteries/Data/Range.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Int.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/LazyList.lean'), PosixPath('.lake/packages/batteries/Batteries/D
ata/UnionFind.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/RBMap.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Nat.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/HashMap.lean'),
PosixPath('.lake/packages/batteries/Batteries/Data/Char.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Array.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Option.lean'), PosixPath('.lake/packa
ges/batteries/Batteries/Data/ByteArray.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Range/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/List/Pairwise.lean'), PosixPath('.lake/packages
/batteries/Batteries/Data/List/EraseIdx.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/List/Perm.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/List/Basic.lean'), PosixPath('.lake/packages/batt
eries/Batteries/Data/List/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/List/Count.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/List/Init/Attach.lean'), PosixPath('.lake/packages/batt
eries/Batteries/Data/List/Init/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/BinomialHeap/Lemmas.lean'), PosixPath('.la
ke/packages/batteries/Batteries/Data/RBMap/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean'), PosixPath('.lake/
packages/batteries/Batteries/Data/RBMap/WF.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Array/Basic.lean'), PosixPath('.lake/package
s/batteries/Batteries/Data/Array/Monadic.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Array/Merge.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Array/Lemmas.lean'), PosixPath('.lake/packages
/batteries/Batteries/Data/Array/Match.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Array/Init/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/UnionFind/Lemmas.lean'), PosixPath('.lake/p
ackages/batteries/Batteries/Data/UnionFind/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Nat/Gcd.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Nat/Lemmas.lean'), PosixPath('.lake/packag
es/batteries/Batteries/Data/Nat/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Option/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Int/Order.lean'), PosixPath('.lake/packages/bat
teries/Batteries/Data/Int/DivMod.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Int/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Fin/Lemmas.lean'), PosixPath('.lake/packages/batteries/
Batteries/Data/Fin/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Sum/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Sum/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries
/Data/MLList/Heartbeats.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/MLList/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/MLList/IO.lean'), PosixPath('.lake/packages/batteries/Batterie
s/Data/BitVec/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/HashMap/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batte
ries/Data/HashMap/WF.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/String/Matcher.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/String/Basic.lean'), PosixPath('.lake/packages/batteries/Batter
ies/Data/String/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Data/Rat/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/C
odeAction/Deprecated.lean'), PosixPath('.lake/packages/batteries/Batteries/CodeAction/Misc.lean'), PosixPath('.lake/packages/batteries/Batteries/CodeAction/Attr.lean'), PosixPath('.lake/packages/batteries/Batteries/Co
deAction/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Control/ForInStep.lean'), PosixPath('.lake/packages/batteries/Batteries/Control/Lemmas.lean'), PosixPath('.lake/packages/batteries/Batteries/Control
/Nondet/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Control/ForInStep/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Control/ForInStep/Lemmas.lean'), PosixPath('.lake/packages/batteries/Ba
tteries/Linter/UnnecessarySeqFocus.lean'), PosixPath('.lake/packages/batteries/Batteries/Linter/UnreachableTactic.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/HashSet.lean'), PosixPath('.lake/packages/ba
tteries/Batteries/Lean/HashMap.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/NameMapAttribute.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Syntax.lean'), PosixPath('.lake/packages/batteries/
Batteries/Lean/Delaborator.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Json.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/NameMap.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/
TagAttribute.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Position.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/SMap.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Float.lean'),
 PosixPath('.lake/packages/batteries/Batteries/Lean/MonadBacktrack.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/PersistentHashSet.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Except.lean'),
 PosixPath('.lake/packages/batteries/Batteries/Lean/Name.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/AttributeExtra.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Expr.lean'), PosixPath('.la
ke/packages/batteries/Batteries/Lean/PersistentHashMap.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Util/Path.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Util/EnvSearch.lean'), PosixPath('
.lake/packages/batteries/Batteries/Lean/System/IO.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Meta/Expr.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Meta/Simp.lean'), PosixPath('.lake/pack
ages/batteries/Batteries/Lean/Meta/SavedState.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Meta/InstantiateMVars.lean'), PosixPath('.
lake/packages/batteries/Batteries/Lean/Meta/Clear.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Meta/Inaccessible.lean'), PosixP
ath('.lake/packages/batteries/Batteries/Lean/Meta/DiscrTree.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/Meta/AssertHypotheses.lean'), PosixPath('.lake/packages/batteries/Batteries/Lean/IO/Process.lean')
, PosixPath('.lake/packages/importGraph/ImportGraph/Imports.lean'), PosixPath('.lake/packages/importGraph/ImportGraph/RequiredModules.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Sign.lean'), PosixPath('.lak
e/packages/mathlib/Mathlib/Data/Tree.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Quot.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Bracket.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Su
btype.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/HashMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/SProd.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Rel.lean'), PosixPath('.lake/pac
kages/mathlib/Mathlib/Data/ULift.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Part.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Option/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/O
ption/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Option/NAry.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/ENat/Lattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/ENat/Basic.lean'
), PosixPath('.lake/packages/mathlib/Mathlib/Data/Sym/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Vector/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Vector/Basic.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/Data/ZMod/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/ZMod/Quotient.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/ZMod/IntUnitsPower.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Data/ZMod/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Num/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/NNRat/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/D
ata/Finite/Set.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finite/Card.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finite/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finite/Defs.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Complex/BigOperators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Complex/Cardinality.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Complex/Mod
ule.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Complex/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Complex/Abs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Complex/Exponential.le
an'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Complex/ExponentialBounds.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/PNat/Defs.lean
'), PosixPath('.lake/packages/mathlib/Mathlib/Data/PNat/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/Lattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean'), PosixPat
h('.lake/packages/mathlib/Mathlib/Data/Fintype/Vector.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/BigOperators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/Prod.lean'), PosixPath('
.lake/packages/mathlib/Mathlib/Data/Fintype/Option.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/Sum.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Data/Fintype/Perm.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/CardEmbedding.lean'), PosixPath('.lake/packages/m
athlib/Mathlib/Data/Fintype/Powerset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/List.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/Pi.lean'), PosixPath('.lake/packages/mathlib/Math
lib/Data/Fintype/Sort.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/Sigma.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fintype/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Su
m/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Sum/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Setoid/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/W/Basic.lean'), Posix
Path('.lake/packages/mathlib/Mathlib/Data/W/Cardinal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/FunLike/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/FunLike/Embedding.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/Data/FunLike/Equiv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Factors.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Pairing.lean'), PosixPath('.lake/packages/ma
thlib/Mathlib/Data/Nat/ModEq.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Bits.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/SuccPred.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/N
at/Log.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Count.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Multiplicity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Totient.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Bitwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/MaxPowDiv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/WithBot.lean'), PosixPath('.
lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Set.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Prime.lean'), PosixPath('.lake/packages/mathlib
/Mathlib/Data/Nat/Periodic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/S
ize.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/PrimeFin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Lattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Order/Lemmas.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Choose/Sum.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean'), Pos
ixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Cast/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Cast/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Cast/Field.lean'), PosixPath('
.lake/packages/mathlib/Mathlib/Data/Nat/Cast/WithTop.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Cast/Commute.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Cast/NeZero.lean'), PosixPath('.l
ake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/GCD/BigOperators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/GCD/Basic.lean'), PosixPath('.lake
/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Real/Sqrt.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/Data/Real/EReal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Real/ConjExponents.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Real/Basic.lean'), PosixPath('.lake/packages
/mathlib/Mathlib/Data/Real/Cardinality.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Real/Archimedean.lean'), PosixPath('.lake/packages/mathl
ib/Mathlib/Data/Real/Pointwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/BoolIndicator.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Sigma.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/Data/Set/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Function.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Finite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Basic.le
an'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Image.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/MemPartition.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/UnionLift.lean'), Posix
Path('.lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Accumulate.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Functor.lean'), PosixPath('.lake/p
ackages/mathlib/Mathlib/Data/Set/Semiring.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Subsingleton.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Countable.lean'), PosixPath('.lake/packages/
mathlib/Mathlib/Data/Set/NAry.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/List.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/
Pointwise/ListOfFn.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Pointwise/BigOperators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Finite.lean'), PosixPath('.lake/packages/mathli
b/Mathlib/Data/Set/Pointwise/SMul.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Interval.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Data/Set/Pairwise/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Prod/Lex.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean'), PosixPath('.lake/packages/mathlib/M
athlib/Data/Prod/TProd.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Prod/PProd.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/ENNRe
al/Inv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/ENNReal/Operations.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Array/Defs.l
ean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/DFinsupp/Encodable.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/FinsetOps.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Range.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/NatAntidiagonal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Sor
t.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Sections.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Powerset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Fold.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Dedup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Antidiagonal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Lattic
e.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Bind.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Sum.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Nodup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Multiset/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Rat/Defs.lean'), PosixPath('.lake
/packages/mathlib/Mathlib/Data/Rat/BigOperators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Rat/Floor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Rat/Encodable.lean'), PosixPath('.lake/packages/m
athlib/Mathlib/Data/Rat/Denumerable.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Rat/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Rat/Init.lean'), PosixPath('.lake/packages/mathlib/Mathlib/D
ata/Rat/Cast/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Rat/Cast/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Rat/Cast/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Rat
/Cast/CharZero.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Matrix/Invertible.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Matrix/Basis.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Matrix
/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Matrix/Block.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Matrix/DMatrix.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Matrix/RowCol.lea
n'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Matrix/Notation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Bool/Set.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Bool/Basic.lean'), PosixPath('
.lake/packages/mathlib/Mathlib/Data/Fin/VecNotation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fin/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fin/Tuple/Basic.lean'), PosixPath('.lake/pack
ages/mathlib/Mathlib/Data/Finsupp/Fintype.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finsupp/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finsupp/Antidiagonal.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Data/Finsupp/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finsupp/Indicator.lean'), PosixPath('.lake/packages/m
athlib/Mathlib/Data/Finsupp/Encodable.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean'), PosixPath('.lake/packages/mathlib/
Mathlib/Data/Finsupp/Notation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finsupp/ToDFinsupp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean'), PosixPath('.lake/packages/mathlib/Ma
thlib/Data/List/TFAE.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Dedup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Palindrome.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List
/NatAntidiagonal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Pairwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/OfFn.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Nodup.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Cycle.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Permutation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Sublists.lean'), Po
sixPath('.lake/packages/mathlib/Mathlib/Data/List/GetD.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Rotate.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Zip.lean'), PosixPath('.lake/packag
es/mathlib/Mathlib/Data/List/Chain.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Enum.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Range.lean'), PosixPath('.lake/packages/mathlib/Mathlib/D
ata/List/FinRange.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Join.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/ProdSigma.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Basi
c.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Sort.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Infix.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Prime.lean'), PosixPath(
'.lake/packages/mathlib/Mathlib/Data/List/Indexes.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Duplicate.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/InsertNth.lean'), PosixPath('.lake/pa
ckages/mathlib/Mathlib/Data/List/NodupEquivFin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Perm.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Forall2.lean'), PosixPath('.lake/packages/mat
hlib/Mathlib/Data/List/Lattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Lex.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Li
st/MinMax.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/List/Count.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Countable/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Countable/Basic.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Pointwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Union.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Sigma.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Order.lean'), PosixPath('.
lake/packages/mathlib/Mathlib/Data/Finset/NoncommProd.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Fold.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Update.lean'), PosixPath('.lake/pa
ckages/mathlib/Mathlib/Data/Finset/Powerset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Attr.lean'), PosixPath('.lake/packages/mathli
b/Mathlib/Data/Finset/Image.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Sort.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Fi
nset/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/NatAntidiagonal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Option.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finse
t/Card.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Antidiagonal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Piecew
ise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Pairwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Finset/Sum.lean'
), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/ModEq.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/Sqrt.lean'), PosixPath('.lake/pa
ckages/mathlib/Mathlib/Data/Int/CharZero.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/Bitwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/Interval.lean'), PosixPath('.lake/packages/mathlib
/Mathlib/Data/Int/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/LeastGreatest.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/SuccPred.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Dat
a/Int/GCD.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/ConditionallyCompleteOrder.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/Cast/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Da
ta/Int/Cast/Field.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/Cast/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/C
ast/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/Order/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Int/Order/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Sigma/Ba
sic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/Sigma/Lex.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Data/String/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Function.lean'), PosixPath
('.lake/packages/mathlib/Mathlib/Init/Set.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Core.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/ZeroOne.lean'), PosixPath('.lake/packages/mathlib/Mathlib/In
it/Classical.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Align.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Logic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Quot.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/Init/Control/Combinators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/Quot.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/Prod.lean'), PosixPath('.lake/packages/
mathlib/Mathlib/Init/Data/Sigma/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/Sigma/Lex.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/Nat/Basic.lean'), PosixPath('.lake/packages/mathl
ib/Mathlib/Init/Data/Nat/Notation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/Nat/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/Ordering/Basic.lean'), PosixPath('.lake/packages/mat
hlib/Mathlib/Init/Data/List/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/List/Instances.lean'), PosixPath('.lake/packages/ma
thlib/Mathlib/Init/Data/Fin/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/Bool/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Data/Int/Basic.lean'), PosixPath('.lake/packages/mathlib
/Mathlib/Init/Data/Int/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Algebra/Classes.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean'), PosixPath('.lake/packages/mathlib/Ma
thlib/Init/Order/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Combinatorics/Enumerative/Composition.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Combinatorics/Enumerative/Partition.lean'), PosixPath('.l
ake/packages/mathlib/Mathlib/Lean/Name.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Lean/Meta.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Lean/EnvExtension.lean'), PosixPath('.lake/packages/mathlib/Mathlib/
Lean/Elab/Term.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Lean/Elab/Tactic/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Lean/PrettyPrinter/Delaborator.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/Lean/Meta/Simp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Lean/Meta/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Lean/Meta/CongrTheorems.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Lean/Expr/
ReplaceRec.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Lean/Expr/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Lean/Expr/ExtraRecognizers.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Probability/P
robabilityMassFunction/Constructions.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Probability/ProbabilityMassFunction/Monad.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Probability/ProbabilityMassFunction/In
tegrals.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Probability/ProbabilityMassFunction/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Dynamics/PeriodicPts.lean'), PosixPath('.lake/packages/mathlib/Math
lib/Dynamics/Ergodic/MeasurePreserving.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Dynamics/FixedPoints/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Notation.lean'), PosixPath('.lake/packages/ma
thlib/Mathlib/Order/ULift.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Compare.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/MinMax.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/SupClose
d.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Minimal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/SymmDiff.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/CompleteBooleanAlgebra.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Order/PartialSups.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Chain.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/PiLex.lean'), PosixPath('.lake/package
s/mathlib/Mathlib/Order/Nat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/WellFounded.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/PropInstances.lean'), PosixPath('.lake/packages/mathlib/Mathlib/O
rder/GaloisConnection.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/InitialSeg.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Cop
y.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/OmegaCompletePartialOrder.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/ModularLattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/RelCla
sses.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Disjoint.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/BooleanAlgebra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/OrderIsoNat.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/Order/Zorn.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Iterate.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Atoms.lean'), PosixPath('.lake/packages/math
lib/Mathlib/Order/WellFoundedSet.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Cover.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/SupIndep.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/L
attice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/LatticeIntervals.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Bounded.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/ZornAtoms.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Order/Max.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Synonym.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Antisymmetrization.lean'), PosixPath('.lake/
packages/mathlib/Mathlib/Order/Directed.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Closure.lean'), PosixPath('.lake/packages/mathlib
/Mathlib/Order/Circular.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/RelSeries.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Co
mpleteLatticeIntervals.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Antichain.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/WithBot.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Basic.le
an'), PosixPath('.lake/packages/mathlib/Mathlib/Order/FixedPoints.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/JordanHolder.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Disjointed.lean'), PosixPa
th('.lake/packages/mathlib/Mathlib/Order/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/SetNotation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Multiset.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Order/Interval/Set/Disjoint.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Set/OrderIso.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Set/OrdConnectedComponent.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Set/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Set/OrderEmbedding.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Inter
val/Set/UnorderedInterval.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Set/ProjIcc.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Set/WithBotTop.lean'), PosixPath('.lake/packages/
mathlib/Mathlib/Order/Interval/Set/Infinite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Set/Image.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Set/Basic.lean'), PosixPath('.lak
e/packages/mathlib/Mathlib/Order/Interval/Set/OrdConnected.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Finset/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Finset/Nat.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Finset/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Interval/Finset/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/SuccPred/Bas
ic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/SuccPred/CompleteLinearOrder.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/SuccPred/Relation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order
/SuccPred/Limit.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Heyting/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/CountableSeparatingOn.lean'), PosixPath('.lake/packages/mathlib/Math
lib/Order/Filter/Archimedean.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/EventuallyConst.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/CountableInter.lean'), PosixPath('.lake/packag
es/mathlib/Mathlib/Order/Filter/Ultrafilter.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/SmallSets.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Subsingleton.lean'), PosixPath('.lake
/packages/mathlib/Mathlib/Order/Filter/Bases.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Germ.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean'), PosixPath('.lake/packages/ma
thlib/Mathlib/Order/Filter/AtTopBot.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Cofinite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Lift.lean'), PosixPath('.lake/packages/mathlib
/Mathlib/Order/Filter/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Ker.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Interval.lean'), PosixPath('.lake/packages/mathlib/Mathlib/
Order/Filter/NAry.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Extr.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/ENNReal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filt
er/IndicatorFunction.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Pointwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Filter/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/C
onditionallyCompleteLattice/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Finset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Group.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Hom/Set.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Hom/Bounded.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Hom/Basic.lean'), PosixPath('
.lake/packages/mathlib/Mathlib/Order/Hom/CompleteLattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Hom/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Hom/Lattice.lean'), PosixPath('.lake/p
ackages/mathlib/Mathlib/Order/Monotone/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Monotone/Monovary.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/CompactlyGenerated/Basic.lean'), PosixPath
('.lake/packages/mathlib/Mathlib/Order/CompactlyGenerated/Intervals.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Bounds/OrderIso.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/Order/UpperLower/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/RelIso/Set.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Order/RelIso/Basic.lean'), PosixPat
h('.lake/packages/mathlib/Mathlib/Control/Bifunctor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Control/Applicative.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Control/Basic.lean'), PosixPath('.lake/packag
es/mathlib/Mathlib/Control/ULift.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Control/Functor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Control/EquivFunctor.lean'), PosixPath('.lake/packages/mathlib/Mathl
ib/Control/Traversable/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Control/Monad/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Mathport/Notation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/
Mathport/Rename.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Mathport/Attributes.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Finiteness.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheor
y/UniqueFactorizationDomain.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/IntegralDomain.lean'), PosixPath('.lake/packages/mathl
ib/Mathlib/RingTheory/MatrixAlgebra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Congruence.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/ZMod.lean'), PosixPath('.lake/packages/mathlib/M
athlib/RingTheory/Algebraic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/PolynomialAlgebra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/OrzechProperty.lean'), PosixPath('.lake/packages/
mathlib/Mathlib/RingTheory/SimpleModule.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/EuclideanDomain.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/IntegralClosure.lean'), PosixPath('.lak
e/packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Noetherian.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/AlgebraTower.lean'), Posi
xPath('.lake/packages/mathlib/Mathlib/RingTheory/FiniteType.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/JacobsonIdeal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/TensorProduct/Basic.l
ean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/NonUnitalSubring/Basic.lean'), PosixPath('.lake/packages/mathlib/Math
lib/RingTheory/Nilpotent/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Nilpotent/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Nilpotent/Defs.lean'), PosixPath('.lake/package
s/mathlib/Mathlib/RingTheory/Localization/FractionRing.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/RootsOfUnity/Basic.le
an'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Ideal/Colon.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Ideal/B
asic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Ideal/Maps.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Ring
Theory/Ideal/Quotient.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Ideal/LocalRing.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Ideal/IsPrimary.lean'), PosixPath('.lake/packages/mathlib
/Mathlib/RingTheory/Polynomial/Tower.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Polynomial/IntegralNormalization.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Quotient.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Pol
ynomial/Nilpotent.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Polynomial/ScaleRoots.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Int/Basic.lean'), PosixPath('.lake/packages/mathlib/Mat
hlib/RingTheory/Coprime/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Coprime/Ideal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Coprime/Basic.lean'), PosixPath('.lake/packages/ma
thlib/Mathlib/RingTheory/Adjoin/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Adjoin/Tower.lean'), PosixPath('.lake/packages/mathlib/Mathlib/RingTheory/Adjoin/FG.lean'), PosixPath('.lake/packages/
mathlib/Mathlib/Logic/Pairwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Denumerable.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Relator.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logi
c/Unique.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Nonempty.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Relation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean'), PosixP
ath('.lake/packages/mathlib/Mathlib/Logic/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Equiv/Nat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean'), PosixPath('.lake/packages/ma
thlib/Mathlib/Logic/Equiv/PartialEquiv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Equiv/Option.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Equiv/List.lean'), PosixPath('.lake/packages/mathlib/
Mathlib/Logic/Equiv/TransferInstance.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Equiv/Set.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean'), PosixPath('.lake/packages/mathlib/Math
lib/Logic/Equiv/Embedding.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Equiv/Fintype.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Equiv/Functor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/L
ogic/Equiv/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Nontrivial/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/S
mall/Set.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Small/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Small/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Embedding/Set.lea
n'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Function/Conjugate.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Function/Iterate.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Function/CompTypeclasses.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Encodable
/Lattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Logic/Encodable/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Periodic.l
ean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Opposites.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/SMulWithZero.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Associated.lean'), Po
sixPath('.lake/packages/mathlib/Mathlib/Algebra/NeZero.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Quotient.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/PUnitInstances.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/Algebra/FreeAlgebra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GeomSum.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Bounds.lean'), PosixPath('.lake/packages/math
lib/Mathlib/Algebra/ModEq.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Nat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean'), PosixPath('.lake/packages/mathlib/Mat
hlib/Algebra/GCDMonoid/Multiset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Finset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Field/Equiv.lean'), PosixPath('.lake/packages/mathli
b/Mathlib/Algebra/Field/Opposite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Field/Rat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Field/Basic.lean'), PosixPath('.lake/packages/mathlib/Math
lib/Algebra/Field/IsField.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Field/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Field/Subfield.lean'), PosixPath('.lake/packages/mathlib/Mathlib
/Algebra/Order/AbsoluteValue.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Kleene.lean'), PosixPath('.lake/packages/mathlib/M
athlib/Algebra/Order/Floor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Invertible.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean'), PosixPath('.lake/packages/mat
hlib/Mathlib/Algebra/Order/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Archimedean.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monovary.lean'), PosixPath('.lake/packages/math
lib/Mathlib/Algebra/Order/Sub/Canonical.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Sub/WithTop.lean'), PosixPath('.lake/pac
kages/mathlib/Mathlib/Algebra/Order/GroupWithZero/Synonym.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/GroupWi
thZero/Canonical.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Int.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Nat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Al
gebra/Order/Group/OrderIso.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Indicator.lean'), PosixPath('.lake/packages/m
athlib/Mathlib/Algebra/Order/Group/PosPart.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Synonym.lean'), PosixPath('.l
ake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Instances.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/TypeTags.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/MinMax.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group
/InjSurj.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Action.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Group/Lattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Alg
ebra/Order/CauSeq/BigOperators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/Completion.lean'), PosixPath('.lake/pa
ckages/mathlib/Mathlib/Algebra/Order/Ring/Cast.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Canonical.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean'), PosixPath
('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Finset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/WithTop.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Rat.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/InjSurj.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Synonym.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Po
w.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Int.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Abs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/
CharZero.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Nat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Interval/Finset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algeb
ra/Order/Interval/Set/Group.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Interval/Set/Monoid.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Interval/Set/Instances.lean'), PosixPath(
'.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/WithTop.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/TypeTags.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ord
er/Monoid/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/OrderDual.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Units.lean'), PosixPath('.lake/packages/mathlib/Ma
thlib/Algebra/Order/Monoid/Submonoid.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Unbundled/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Unbundled/MinMax.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean'), PosixPath('.lake/packages/mathlib/Mathlib/A
lgebra/Order/Monoid/Canonical/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/BigOperators/Ring/Multiset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/BigOperators/Ring/Finset.le
an'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/BigOperators/Ring/List.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/BigOperators/Group/Finset.lean'), PosixPath('.lake/packages/mathlib/
Mathlib/Algebra/Order/BigOperators/Group/List.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/BigOperators/Group/Multiset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Hom/Ring.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Hom/Monoid.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Hom/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Nonneg/Flo
or.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Nonneg/Ring.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Nonneg/Field.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ord
er/Module/Synonym.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Module/OrderedSMul.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Module/Pointwise.lean'), PosixPath('.lake/packages/m
athlib/Mathlib/Algebra/Order/Module/Algebra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Module/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean'), PosixPath('.l
ake/packages/mathlib/Mathlib/Algebra/Order/Field/Power.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Field/InjSurj.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Field/Defs.lean'), P
osixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Field/Rat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Field/Canonical/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Fie
ld/Canonical/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Order/Positive/Ring.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/MvPolynomial/Variables.lean'), PosixPath('.lake/packages/mathl
ib/Mathlib/Algebra/MvPolynomial/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/MvPolynomial/CommRing.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/MvPolynomial/Degrees.lean'), PosixPath('.
lake/packages/mathlib/Mathlib/Algebra/MvPolynomial/Equiv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/MvPolynomial/Rename.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/FreeMonoid/Basic.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Algebra/CharP/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/CharP/Two.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/CharP/Invertible.lean'), Posi
xPath('.lake/packages/mathlib/Mathlib/Algebra/CharP/ExpChar.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/CharP/Algebra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/CharP/Basic.lean'), PosixPa
th('.lake/packages/mathlib/Mathlib/Algebra/CharP/Reduced.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Star/StarAlgHom.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Star/Pi.lean'), PosixPath('.
lake/packages/mathlib/Mathlib/Algebra/Star/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Star/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Star/Module.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Algebra/Star/Pointwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Star/Center.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Star/Subalgebra.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Algebra/Star/BigOperators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Star/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Star/SelfAdjoint.lean'), PosixPath('.lake/pa
ckages/mathlib/Mathlib/Algebra/Star/Unitary.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/EuclideanDomain/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/EuclideanDomain/Instances.lean'), P
osixPath('.lake/packages/mathlib/Mathlib/Algebra/EuclideanDomain/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/RestrictScalars.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra
/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebr
a/Algebra/Operations.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/Equiv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/Tower.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Al
gebra/Algebra/Bilinear.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/NonUnitalHom.lean'), PosixPath('.lake/packages/mathlib/Ma
thlib/Algebra/Algebra/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/Opposite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean'), PosixPath('.lake/packages/mathlib/Ma
thlib/Algebra/Algebra/Subalgebra/Tower.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/Subalgebra/Operations.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/Subalgebra/Basic.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Algebra/Subalgebra/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/DirectSum/Finsupp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/DirectSu
m/Module.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/DirectSum/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Inductions.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Alge
bra/Polynomial/Div.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Identities.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Coeff.lean'), PosixPath('.lake/packages/mathlib/M
athlib/Algebra/Polynomial/Derivative.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Roots.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Expand.lean'), PosixPath('.lake/pack
ages/mathlib/Mathlib/Algebra/Polynomial/Eval.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Laurent.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/BigOperators.lean'), Posix
Path('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Induction.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Monomial.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Basi
c.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/RingDivision.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/CancelLeads.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Al
gebra/Polynomial/Monic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Reverse.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/FieldDivision.lean'), PosixPath('.lake/packages/
mathlib/Mathlib/Algebra/Polynomial/EraseLead.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/AlgebraMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Module/Basic.lean'), Po
sixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Degree/Definitions.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Polynomial/Degree/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebr
a/Polynomial/Degree/TrailingDegree.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Regular/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Regular/Pow.lean'), PosixPath('.lake/packages/mathli
b/Mathlib/Algebra/Regular/SMul.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/MinimalAxioms.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Hom.lean'), PosixPath('.lake/packages/math
lib/Mathlib/Algebra/Module/ULift.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Defs.lean'), PosixPath('.lake/packages/mathlib/Math
lib/Algebra/Module/Opposites.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean'), PosixPath('.lake/packages/mathlib/Ma
thlib/Algebra/Module/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/BigOperators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean'), PosixPath('.lake/packages/mathlib/
Mathlib/Algebra/Module/Submodule/IterateMapComap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Range.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Pointwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/M
odule/Submodule/RestrictScalars.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/LinearMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Bilinear.lean'), PosixPat
h('.lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/Linear
Map/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/End.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/A
lgebra/Divisibility/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/NoZeroDivisors.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Degree.lean'), PosixPath('.lake/
packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Support.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Division.lea
n'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Option.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOp
erators/NatAntidiagonal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/RingEquiv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/WithTop.lean'), PosixPath('.lake/packages
/mathlib/Mathlib/Algebra/BigOperators/Associated.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Module.lean'), Pos
ixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Interv
als.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Group/List.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra
/BigOperators/Group/Multiset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Group/Finset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Ring/Multiset.lean'), PosixPath('
.lake/packages/mathlib/Mathlib/Algebra/BigOperators/Ring/List.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/BigOperators/GroupWithZero/Finset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/CharZ
ero/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/CharZero/Quotient.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/CharZero/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/
Squarefree/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Invertible.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Prod.lean'), PosixPath('.lake/packages/mathli
b/Mathlib/Algebra/GroupWithZero/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Commute.lean'), PosixPath('.lake
/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Indicator.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/ULift.lean
'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/Algebra/GroupWithZero/InjSurj.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/WithZero.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NeZero.lean'), PosixPath('.lake/
packages/mathlib/Mathlib/Algebra/GroupWithZero/Hom.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Semiconj.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.l
ean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Equiv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib
/Algebra/Group/TypeTags.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Opposite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/A
lgebra/Group/UniqueProds.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Centralizer.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Aut.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/Algebra/Group/Int.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/ConjFinite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Embedding.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/Algebra/Group/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Commutator.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Support.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/Algebra/Group/Indicator.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Center.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Even.lean'), PosixPath('.lake/packages/mathlib/Mathlib/A
lgebra/Group/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/ULift.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Gr
oup/FiniteSupport.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/InjSurj.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/
Group/Conj.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Nat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Equiv/TypeTags.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/G
roup/Equiv/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Submonoid/Membership.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Submonoid/Pointwise.lean'), PosixPath('.lake/packag
es/mathlib/Mathlib/Algebra/Group/Submonoid/MulOpposite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Submonoid/Operations.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Submonoid/Bas
ic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Action/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Subsemigroup/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algeb
ra/Group/Subsemigroup/Operations.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Subsemigroup/Membership.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Units/Equiv.lean'), PosixPath('.
lake/packages/mathlib/Mathlib/Algebra/Group/Units/Hom.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean'), PosixPat
h('.lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Instances.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Hom/CompTypeclasses.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Hom/End
.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Semiconj/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Semiconj/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/G
roup/Semiconj/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Hom.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Basic.lean'), PosixPath('.lake/packages/mathlib/M
athlib/Algebra/Group/Commute/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Invertible/Defs.lean'), PosixPath('.lake/
packages/mathlib/Mathlib/Algebra/Group/Invertible/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Lemmas.lean'), PosixP
ath('.lake/packages/mathlib/Mathlib/Algebra/Group/WithOne/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Subgroup/Pointwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Subgrou
p/Finite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Subgroup/Actions.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Subgroup/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/Algebra/Group/Subgroup/MulOpposite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Group/Subgroup/ZPowers.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Regular.lean'), PosixPath('.lake/pac
kages/mathlib/Mathlib/Algebra/Ring/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Aut.lean'), PosixPath('.lake/packages/mathlib
/Mathlib/Algebra/Ring/Idempotents.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Center.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/AddAut.lean'), PosixPath('.lake/packages/mathlib/M
athlib/Algebra/Ring/Parity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Nat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Commute.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Al
gebra/Ring/NegOnePow.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Centralizer.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Alge
bra/Ring/Invertible.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/CompTypeclasses.lean'), PosixPath('.lake/packages/mathlib/Mathlib
/Algebra/Ring/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/InjSurj.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Int.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/R
ing/Semiconj.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Opposite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Rat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Pi
.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/ULift.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Action/Subobjects.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Action/
Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Subring/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Subring/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra
/Ring/Subsemiring/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/Ring/Divisibility/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean'), PosixPath('.lake/packages/ma
thlib/Mathlib/Algebra/GroupPower/IterateHom.lean'), PosixPath('.lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean'), PosixPath('.lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/FieldTheory/Finiteness.lean'), PosixPath('.lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Field.lean'), PosixPath('.lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Basic.lean'), PosixP
ath('.lake/packages/mathlib/Mathlib/LinearAlgebra/LinearPMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Prod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/BilinearMap.lean'), Pos
ixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/InvariantBasisNumber.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/DFinsupp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Finite
Dimensional.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Ray.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Fin
supp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Sp
an.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Isomorphisms.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Linea
rAlgebra/Projection.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean'), PosixPath('.lake/packages/mathlib/Mathlib/L
inearAlgebra/GeneralLinearGroup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/FinsuppVectorSpace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Pi.lean'), PosixPath('.lake/packages/m
athlib/Mathlib/LinearAlgebra/Basis/VectorSpace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Alternating/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Multilinear/Basic.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Multilinear/Basis.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlg
ebra/Dimension/FreeAndStrongRankCondition.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/RankNullity.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/L
inearAlgebra/Dimension/LinearMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Constructions.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/DivisionRing.lean'), P
osixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Free.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/MvPolynomial.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra
/Matrix/NonsingularInverse.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Transvection.lean'), PosixPat
h('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/GeneralLinearGroup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Polynomial.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgeb
ra/Matrix/Basis.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Reindex.lean'), PosixPath('.lake/packages/mathlib/Mat
hlib/LinearAlgebra/Matrix/Adjugate.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Trace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean'), PosixPath('
.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Charpoly/LinearMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlge
bra/Matrix/Determinant/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/TensorProduct/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/TensorProduct/Tower.lean'), PosixPath('.
lake/packages/mathlib/Mathlib/LinearAlgebra/TensorProduct/Basis.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Independent.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/A
ffineSpace/FiniteDimensional.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Midpoint.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean'), PosixPa
th('.lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Slope.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlg
ebra/AffineSpace/Restrict.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Basis.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean'), PosixPath('.l
ake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Direct
Sum/Finsupp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/Charpoly/Basic.lean'), PosixPath('.lake/packages/math
lib/Mathlib/LinearAlgebra/FreeModule/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/FreeModule/StrongRankCondition.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/FreeModule/Fini
te/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Propose.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tact
ic/ProjectionNotation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FBinop.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Says.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Contrapose.l
ean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/GuardGoalNums.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Lemma.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Core.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/Tactic/SimpRw.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Hint.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/SimpIntro.lean'), PosixPath('.lake/packages/mathlib/Math
lib/Tactic/FinCases.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/WLOG.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linter.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/CasesM.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Continuity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Ring.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Substs.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Tactic/DeriveToExpr.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Variable.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NthRewrite.lean'), PosixPath('.lake/packages/mathlib/M
athlib/Tactic/Observe.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Check.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ByContra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FieldSimp
.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Congr!.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/DefEqTransformations.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/SuppressCompilati
on.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Spread.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Group.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Find.lean'), PosixPath('.lake/
packages/mathlib/Mathlib/Tactic/Constructor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/IntervalCases.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Trace.lean'), PosixPath('.lake/packages/mathl
ib/Mathlib/Tactic/Peel.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ComputeDegree.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Set.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NormN
um.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/MkIffOfInductiveProp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/IrreducibleDef.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FailIfN
oProgress.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/TFAE.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Tauto.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/TermCongr.lean'), PosixPa
th('.lake/packages/mathlib/Mathlib/Tactic/SudoSetOption.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ExtendDoc.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ApplyCongr.lean'), PosixPath('.lake/p
ackages/mathlib/Mathlib/Tactic/HigherOrder.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Measurability.lean'), PosixPath('.lake/packages/mat
hlib/Mathlib/Tactic/TypeStar.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ExtractGoal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Common.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tacti
c/LinearCombination.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ExtractLets.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/HaveI.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ApplyWit
h.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/PPWithUniv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Conv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Existsi.lean'), PosixPath('.
lake/packages/mathlib/Mathlib/Tactic/GCongr.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/AdaptationNote.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/InferParam.lean'), PosixPath('.lake/packages
/mathlib/Mathlib/Tactic/Clear_.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Eqns.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/SetLike.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Po
sitivity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ToExpr.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ClearExcept.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/TryThis.lean'), Po
sixPath('.lake/packages/mathlib/Mathlib/Tactic/PushNeg.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ClearExclamation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Cases.lean'), PosixPath('.lake/
packages/mathlib/Mathlib/Tactic/Abel.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/GeneralizeProofs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ApplyAt.lean'), PosixPath('.lake/packages/mathlib
/Mathlib/Tactic/Lift.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Inhabit.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ApplyFun.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Convert.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Coe.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Rename.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ScopedNS.lean'), PosixPath('.lake/p
ackages/mathlib/Mathlib/Tactic/RSuffices.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Nontriviality.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/SuccessIfFailWithMsg.lean'), PosixPath('.lake/pa
ckages/mathlib/Mathlib/Tactic/Use.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FunProp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/UnsetOption.lean'), PosixPath('.lake/packages/mathlib/Mathlib
/Tactic/Monotonicity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Congrm.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ToLevel.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Basic.lean
'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/SwapVar.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/SplitIfs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/GuardHypNums.lean'), PosixPath('.
lake/packages/mathlib/Mathlib/Tactic/RenameBVar.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Choose.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/TypeCheck.lean'), PosixPath('.lake/packages/math
lib/Mathlib/Tactic/Zify.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/HelpCmd.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/ToAdditive.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Rec
over.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/CancelDenoms/Core.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Continuity/Init.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Relatio
n/Trans.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Relation/Rfl.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Nontriviality/Core.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Ring/B
asic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Ring/RingNF.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Ring/PNat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Widget/SelectInsert
ParamsClass.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Widget/SelectPanelUtils.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Widget/Calc.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tacti
c/Widget/Conv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Widget/Congrm.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Monotonicity/Attr.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/
Monotonicity/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Monotonicity/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FunProp/Elab.lean'), PosixPath('.lake/packages/mathlib/Mathlib/T
actic/FunProp/Mor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FunProp/Attr.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FunProp/Theorems.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tacti
c/FunProp/StateList.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FunProp/Decl.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FunProp/FunctionData.lean'), PosixPath('.lake/packages/mathlib/Mathlib
/Tactic/FunProp/Core.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FunProp/ToBatteries.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/FunProp/Types.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/Tactic/FunProp/RefinedDiscrTree.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith/Datatypes.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith/Lemmas.lean'), PosixPath('.lake/packages/
mathlib/Mathlib/Tactic/Linarith/Verification.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith/Frontend.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith/Parsing.lean'), PosixPath('.lak
e/packages/mathlib/Mathlib/Tactic/Linarith/Preprocessing.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith/Simp
lexAlgorithm/SimplexAlgorithm.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith/SimplexAlgorithm/Datatypes.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith/SimplexAlgorithm/PositiveVec
tor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linarith/SimplexAlgorithm/Gauss.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NormNum/Ineq.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tact
ic/NormNum/Result.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NormNum/Inv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NormNum/OfScientific.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Ta
ctic/NormNum/GCD.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NormNum/Eq.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NormNum/Pow.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NormNu
m/DivMod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NormNum/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/NormNum/Core.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Simps/Basi
c.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Simps/NotationClass.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Attr/Core.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Attr/Register.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linter/GlobalAttributeIn.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Linter/HashCommandLinter.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tac
tic/Linter/Lint.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Measurability/Init.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/Positivity/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/T
actic/Positivity/Core.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/GCongr/ForwardAttr.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Tactic/GCongr/Core.lean'), PosixPath('.lake/packages/mathlib/Mathlib/
Util/Delaborators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Util/AssertExists.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Util/CountHeartbeats.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Util/Disch
argerAsTactic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Util/SynthesizeUsing.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Util/Tactic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Util/AtomM.lean'), P
osixPath('.lake/packages/mathlib/Mathlib/Util/WithWeakNamespace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Util/WhatsNew.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Util/CompileInductive.lean'), PosixPath
('.lake/packages/mathlib/Mathlib/Util/Qq.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Util/MemoFix.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Commutator.lean'), PosixPath('.lake/packages/mathli
b/Mathlib/GroupTheory/Finiteness.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Coset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/PGroup.lean'), PosixPath('.lake/packages/mathlib/Mathl
ib/GroupTheory/Index.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/NoncommPiCoprod.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Divisible.lean'), PosixPath('.lake/packages/mathlib/Math
lib/GroupTheory/QuotientGroup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Archimedean.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean'), PosixPath('.lake/packages/ma
thlib/Mathlib/GroupTheory/Torsion.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/MonoidLocalization.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Congruence.lean'), PosixPath('.lake/pack
ages/mathlib/Mathlib/GroupTheory/Exponent.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Simple.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Centralizer.lean'), PosixP
ath('.lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Center.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Subsemi
group/Centralizer.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Center.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Pointwise.lean'), PosixPath('.lake/packages
/mathlib/Mathlib/GroupTheory/GroupAction/ConjAct.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Prod.lean'), P
osixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Hom.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupActi
on/BigOperators.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Quotient.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Basic.lean'), PosixPath('.lake/packages/math
lib/Mathlib/GroupTheory/GroupAction/Opposite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/SubMulAction.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Ring.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Gr
oupAction/SubMulAction/Pointwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/DomAct/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Center.lean'), PosixPath(
'.lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Centralizer.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/Fin.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/Option.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lea
n'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/List.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/Finite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/Closure
.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Type.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/GroupTheo
ry/Perm/Cycle/Factors.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/MeanInequalities.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean'), PosixPath('.lake/packages/mathlib/Mathlib/A
nalysis/MeanInequalitiesPow.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecificLimits/Normed.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecificLimits/Basic.lean'), PosixPath('.lake/pac
kages/mathlib/Mathlib/Analysis/NormedSpace/AddTorsor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Pointwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Basic.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/ConformalLinearMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/LinearIsometry.lean'), PosixPath('.lake/packages/mathlib/Mathl
ib/Analysis/NormedSpace/FiniteDimension.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/RieszLemma.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/IndicatorFunction.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Real.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/ContinuousLinearMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analys
is/NormedSpace/BoundedLinearMaps.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/AffineIsometry.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Span.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/Analysis/NormedSpace/Units.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Multilinear/Curry.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Mu
ltilinear/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Star/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean'), PosixPath('.lake/pack
ages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Bilinear.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/NNNorm.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Nor
medSpace/OperatorNorm/NormedSpace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Completeness.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/As
ymptotics.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Mul.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Asymptotics/Theta.lean'), PosixPath('.lake/packages/mathlib/
Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Asymptotics/Asymptotics.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/RCLike/Basic.lean'), Posi
xPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Star.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Strict.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Slope.lean'), Posix
Path('.lake/packages/mathlib/Mathlib/Analysis/Convex/Between.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Topology.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Jensen.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Segment.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Combination.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Hull.le
an'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Mul.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Normed.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Basic.lean
'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/Function.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analys
is/Normed/MulAction.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Order/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Order/Lattice.lean'), PosixPath('.lake/packages/mathl
ib/Mathlib/Analysis/Normed/Field/UnitBall.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Field/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Lemmas.lean'), PosixPath(
'.lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Seminorm.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Quotient.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Group/I
nfiniteSum.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Group/BallSphere.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Group/AddCircle.lean'), PosixPath('.lake/packages/mathlib
/Mathlib/Analysis/Normed/Group/Hom.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Pointwise.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/Analysis/Normed/Group/AddTorsor.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/LocallyConvex/Bounded.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/LocallyConvex/Wit
hSeminorms.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/LocallyConvex/Basic.lean'), PosixPath('.lake/packages/mat
hlib/Mathlib/Analysis/SpecialFunctions/Exp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Trigonometric
/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean'), PosixPat
h('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis
/SpecialFunctions/Pow/Continuity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/An
alysis/SpecialFunctions/Complex/Arg.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Taylor.lean'), PosixPath(
'.lake/packages/mathlib/Mathlib/Analysis/Calculus/MeanValue.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calcul
us/TangentCone.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Conformal/NormedSpace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Equiv.lean'), PosixPath('.lake/packag
es/mathlib/Mathlib/Analysis/Calculus/FDeriv/Comp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Add.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Bilinear.lean'
), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Mul.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Cal
culus/FDeriv/RestrictScalars.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Linear.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Prod.lean'), PosixPath('.lake/p
ackages/mathlib/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus
/ContDiff/RCLike.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean'), PosixPath('.lake/packages/m
athlib/Mathlib/Analysis/Calculus/LocalExtr/Rolle.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/LocalExtr/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Mul.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Linear.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Inverse.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/C
alculus/Deriv/Inv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Comp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Slope.lean'), PosixPath('.lake/packages/mathli
b/Mathlib/Analysis/Calculus/Deriv/Add.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Pow.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/AffineMap.lean'), PosixPath
('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Shift.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Complex/Circle.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Complex/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Complex/C
onformal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Complex/RealDeriv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Analysis/Complex/Asymptotics.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Me
asureTheory/PiSystem.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/NullMeasurable.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Trim.lean'), PosixPath('.lake/package
s/mathlib/Mathlib/MeasureTheory/Measure/OpenPos.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/AEDisjoint.lean'), PosixPath('.lake/packages/mathlib/Mathlib
/MeasureTheory/Measure/Typeclasses.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MutuallySingular.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Count.lean'), PosixPa
th('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/WithDensity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Measure/AEMeasurable.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory
/Measure/Dirac.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Induced.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean'), PosixPath('.lake/packages/
mathlib/Mathlib/MeasureTheory/OuterMeasure/Caratheodory.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/AE
.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/OfFunction.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Operations.lean'), PosixPath('.lake/packages/mathli
b/Mathlib/MeasureTheory/Function/AEMeasurableSequence.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFuncDense.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/S
impleFuncDenseLp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/L1Space.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/AEEqFun.lean'), PosixPath('.lake/packages/math
lib/Mathlib/MeasureTheory/Function/SimpleFunc.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/EssSup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/LpOrder.lean'), Po
sixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/LpSpace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Measur
eTheory/Function/LpSeminorm/ChebyshevMarkov.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/LpSeminorm/CompareExp.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/LpSem
inorm/TriangleInequality.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/SpecialFunctions/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Function/StronglyMeasurable/Basi
c.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Integral/IntegrableOn.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Bochner.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/MeasureTheory/Integral/Lebesgue.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Integral/SetToL1.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Integral/MeanInequalities.lean'), Posi
xPath('.lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean'), PosixPath('.lake/packages/mathlib/Ma
thlib/MeasureTheory/MeasurableSpace/Defs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Construction
s/BorelSpace/Real.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Complex.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Metric.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean'), PosixPath('.lake/packages
/mathlib/Mathlib/MeasureTheory/Group/Arithmetic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/MeasureTheory/Order/Lattice.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Continuum.lean'), Posi
xPath('.lake/packages/mathlib/Mathlib/SetTheory/Cardinal/ToNat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Finite.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Subfield.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Cardinal/ENat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Cardinal
/Cofinality.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Cardinal/PartENat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Cardinal/SchroederBernstein.lean'), PosixPath('.lake/packages/mathl
ib/Mathlib/SetTheory/Cardinal/Ordinal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Ordinal/FixedPoint.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Principal.lean'), PosixPath('.la
ke/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/Topology/IndicatorConstPointwise.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UnitInterval.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/CompactOp
en.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Separation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/DiscreteSubset.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order.lean'
), PosixPath('.lake/packages/mathlib/Mathlib/Topology/QuasiSeparated.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Clopen.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/GDelta.lean'), PosixPat
h('.lake/packages/mathlib/Mathlib/Topology/Maps.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/NhdsSet.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/DenseEmbedding.lean'), PosixPath('.lake/pac
kages/mathlib/Mathlib/Topology/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Homeomorph.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Constructions.lean'), PosixPath('.lake/packages/mat
hlib/Mathlib/Topology/SeparatedMap.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/ExtendFrom.lean'), PosixPath('.lake/packages/mathli
b/Mathlib/Topology/Bases.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Sequences.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Support.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topolo
gy/Irreducible.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/NoetherianSpace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Semicontinuous.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Top
ology/Inseparable.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/PartialHomeomorph.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/LocallyFinite.lean'), PosixPath('.lake/packages/mathlib/Mathlib
/Topology/IsLocalHomeomorph.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/IsLUB.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/MonotoneConvergence.lean'), PosixPath('.lake/packages
/mathlib/Mathlib/Topology/Order/MonotoneContinuity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/ProjIcc.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/OrderClosed.lean'), PosixPat
h('.lake/packages/mathlib/Mathlib/Topology/Order/T5.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/LocalExtr.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/ExtendFrom.lean'), PosixP
ath('.lake/packages/mathlib/Mathlib/Topology/Order/LeftRight.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/Lattice.lean'), Posi
xPath('.lake/packages/mathlib/Mathlib/Topology/Order/IntermediateValue.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/DenselyOrdered.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/M
onotone.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Order/LeftRightNhds.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Metrizable/Uniformity.lean'), PosixPath('.lake/packages/mathlib/Mathlib
/Topology/Metrizable/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Bornology/Absorbs.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Bornology/Constructions.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Topology/Bornology/BoundedOperation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Bornology/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Bornology/Hom.lean'), Posix
Path('.lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Lipschitz.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpac
e/UniformConvergence.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/Compact.lean'), PosixPath('.lake/packages/math
lib/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/Separation.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/C
ompleteSeparated.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/Pi.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/Completion.lean'), PosixPath('.lake/packages/mathlib/
Mathlib/Topology/UniformSpace/AbstractCompletion.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/Cauchy.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/UniformEmbedding.
lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/CompactConvergence.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/UniformSpace/Equiv.lean'), PosixPath('.lake/packages/mathlib/Mathli
b/Topology/UniformSpace/Equicontinuity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/Lipschitz.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/Cauchy.lean'), PosixPath('
.lake/packages/mathlib/Mathlib/Topology/MetricSpace/Equicontinuity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricS
pace/Isometry.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/Dilation.lean'), PosixPath('.lake/packages/
mathlib/Mathlib/Topology/MetricSpace/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/Bounded.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/ProperSpace.lean'), Posi
xPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/Antilipschitz.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/IsometricSMul.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/
MetricSpace/Thickening.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/DilationEquiv.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/MetricSpace/Algebra.lean'), PosixPath('.lake/packa
ges/mathlib/Mathlib/Topology/ContinuousFunction/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/ContinuousFunction/Ordered.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/ContinuousFunction
/Bounded.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/ContinuousFunction/Algebra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/ContinuousFunction/Compact.lean'), PosixPath('.lake/packages/ma
thlib/Mathlib/Topology/Connected/PathConnected.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Connected/LocallyConnected.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Connected/TotallyDisconne
cted.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Connected/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Algebra.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Alg
ebra/Field.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/FilterBasis.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/UniformGroup.lean'), PosixPath('.lake/packages/mathlib/Mathl
ib/Topology/Algebra/Equicontinuity.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Monoid.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/MulAction.lean'), PosixPath('.lake/packag
es/mathlib/Mathlib/Topology/Algebra/UniformMulAction.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/GroupWithZero.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/UniformConvergen
ce.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Star.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Affine.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/C
onstMulAction.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Constructions.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean'), PosixPath('.lake/packages/mathlib/M
athlib/Topology/Algebra/InfiniteSum/Ring.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Order.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean')
, PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean'), PosixPath('.lake/packages/mathlib/Math
lib/Topology/Algebra/InfiniteSum/Module.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Real.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Group.lean'),
PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Determinant.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Top
ology/Algebra/Module/StrongTopology.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Module/LocallyConvex.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean'), Posix
Path('.lake/packages/mathlib/Mathlib/Topology/Algebra/Module/FiniteDimension.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Simple.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/
Algebra/Module/Star.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Multilinear/Bounded.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Multilinear/Basic.lean'), Pos
ixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Multilinear/Topology.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Ring/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topol
ogy/Algebra/Ring/Ideal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Order/LiminfLimsup.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Order/Compact.lean'), PosixPath('.lake/pa
ckages/mathlib/Mathlib/Topology/Algebra/Order/Group.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Order/Field.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Order/Rolle.lean'),
 PosixPath('.lake/packages/mathlib/Mathlib/Topology/Algebra/Order/Archimedean.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Defs/Sequences.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Defs/F
ilter.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Defs/Induced.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Sets/Close
ds.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Sets/Opens.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Sets/Compacts.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Instances/Re
al.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Instances/Sign.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Instances/Matrix.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Insta
nces/Int.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Instances/RealVectorSpace.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Instances/AddCircle.lean'), PosixPath('.lake/packages/mathlib/Ma
thlib/Topology/Instances/EReal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Instances/Nat.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Instances/Discrete.lean'), PosixPath('.lake/packages/m
athlib/Mathlib/Topology/Instances/ENNReal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Instances/NNReal.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Instances/Rat.lean'), PosixPath('.lake/p
ackages/mathlib/Mathlib/Topology/Compactness/Compact.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Compactness/SigmaCompact.lean'), PosixPath('.lake/packages/mathlib/Mathlib/Topology/Compactness/LocallyCo
mpact.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Compat.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Cancellable.lean'), Posi
xPath('.lake/packages/proofwidgets/ProofWidgets/Util.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Component/Recharts.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Component/MakeEditLink.le
an'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Component/FilterDetails.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Component/InteractiveSvg.lean'), PosixPath('.lake/packages/proofwidgets/Pro
ofWidgets/Component/Basic.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Component/OfRpcMethod.lean'), PosixPath('.lake/pa
ckages/proofwidgets/ProofWidgets/Component/PenroseDiagram.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Component/Panel/GoalTypePanel.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Component
/Panel/SelectionPanel.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Component/Panel/Basic.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Presentation/Expr.lean'), PosixPath('.lake/packages/p
roofwidgets/ProofWidgets/Data/Svg.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Data/Html.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Rubiks.lean'), PosixPath('.lake/packages/proofw
idgets/ProofWidgets/Demos/Conv.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Jsx.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Svg.lean'), PosixPath('.lake/packages/proofwidgets
/ProofWidgets/Demos/SelectInsertConv.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Venn.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Plot.lean'), PosixPath('.lake/packages/proo
fwidgets/ProofWidgets/Demos/Macro.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Euclidean.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/Dynkin.lean'), PosixPath('.lake/packages/
proofwidgets/ProofWidgets/Demos/RbTree.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/ExprPresentation.lean'), PosixPath('.lake/packages/proofwidgets/ProofWidgets/Demos/LazyComputation.lean'), Posix
Path('.lake/packages/proofwidgets/ProofWidgets/Demos/InteractiveSvg.lean')], pr_url=None)]
(raylet) [2024-11-07 00:55:17,191 E 3380705 3380734] (raylet) file_system_monitor.cc:111: /data/yingzi_ma/lean_project/tmp/ray/session_2024-11-07_00-53-41_795314_3263099 is over 95% full, available space: 5275193344;
capacity: 1000000000000. Object creation will fail if spilling is required.
(pid=3381000) [2024-11-07 00:55:18,185] [INFO] [real_accelerator.py:219:get_accelerator] Setting ds_accelerator to cuda (auto detect)
2024-11-07 00:55:42.716 | INFO     | __main__:prove_sorry_theorems:886 - Found 0 sorry theorems to prove
Processing theorems from google-deepmind/debate: 0theorem [00:00, ?theorem/s](ProverActor pid=3381000) /data/yingzi_ma/miniconda3/envs/ReProver/lib/python3.10/site-packages/torch/storage.py:414: FutureWarning: You are
 using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during un
pickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions
 that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recom
mend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
Processing theorems from google-deepmind/debate: 0theorem [00:00, ?theorem/s](ProverActor pid=3381000)   return torch.load(io.BytesIO(b))

(raylet) [2024-11-07 00:55:27,210 E 3380705 3380734] (raylet) file_system_monitor.cc:111: /data/yingzi_ma/lean_project/tmp/ray/session_2024-11-07_00-53-41_795314_3263099 is over 95% full, available space: 9604247552;
capacity: 1000000000000. Object creation will fail if spilling is required.
2024-11-07 00:55:42.717 | INFO     | __main__:save_progress:838 - Saving encountered theorems...
2024-11-07 00:55:42.720 | INFO     | __main__:prove_sorry_theorems:937 - Finished attempting to prove sorry theorems
(raylet) [2024-11-07 00:55:47,251 E 3380705 3380734] (raylet) file_system_monitor.cc:111: /data/yingzi_ma/lean_project/tmp/ray/session_2024-11-07_00-53-41_795314_3263099 is over 95% full, available space: 9600634880;
capacity: 1000000000000. Object creation will fail if spilling is required. [repeated 2x across cluster]
(raylet) [2024-11-07 00:56:07,288 E 3380705 3380734] (raylet) file_system_monitor.cc:111: /data/yingzi_ma/lean_project/tmp/ray/session_2024-11-07_00-53-41_795314_3263099 is over 95% full, available space: 11416535040;
 capacity: 1000000000000. Object creation will fail if spilling is required. [repeated 2x across cluster]
(raylet) [2024-11-07 00:56:17,307 E 3380705 3380734] (raylet) file_system_monitor.cc:111: /data/yingzi_ma/lean_project/tmp/ray/session_2024-11-07_00-53-41_795314_3263099 is over 95% full, available space: 11375026176;
 capacity: 1000000000000. Object creation will fail if spilling is required.
(raylet) [2024-11-07 00:56:27,326 E 3380705 3380734] (raylet) file_system_monitor.cc:111: /data/yingzi_ma/lean_project/tmp/ray/session_2024-11-07_00-53-41_795314_3263099 is over 95% full, available space: 11332841472;
 capacity: 1000000000000. Object creation will fail if spilling is required.
(raylet) [2024-11-07 00:56:37,346 E 3380705 3380734] (raylet) file_system_monitor.cc:111: /data/yingzi_ma/lean_project/tmp/ray/session_2024-11-07_00-53-41_795314_3263099 is over 95% full, available space: 10677014528;
 capacity: 1000000000000. Object creation will fail if spilling is required.
2024-11-07 00:56:46.683 | INFO     | __main__:main:1749 - Finished searching for proofs of sorry theorems
2024-11-07 00:56:46.684 | INFO     | __main__:main:1768 - Finished processing the repository
2024-11-07 00:56:46.684 | INFO     | __main__:main:1770 - current epoch: 6
(raylet) [2024-11-07 00:56:47,368 E 3380705 3380734] (raylet) file_system_monitor.cc:111: /data/yingzi_ma/lean_project/tmp/ray/session_2024-11-07_00-53-41_795314_3263099 is over 95% full, available space: 10675568640;
 capacity: 1000000000000. Object creation will fail if spilling is required.
(base) yingzi_ma@compute-permanent-node-471:~/lean_project/ReProver$
